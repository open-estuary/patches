From b01772164c14302715bf0c3ded24d0f8a2e6a3c5 Mon Sep 17 00:00:00 2001
From: Zhangfei Gao <zhangfei.gao@linaro.org>
Date: Wed, 19 Feb 2014 09:36:55 +0800
Subject: [PATCH 1/5] misc: add sirdes driver

To be reverted.
Sirdes operation will move to uefi and will be replaced later,
so simply port sirdes driver here.
Also port phy driver inside for debug, which is commented now.

Signed-off-by: Zhangfei Gao <zhangfei.gao@linaro.org>
---
 drivers/misc/Kconfig               |     4 +-
 drivers/misc/Makefile              |     7 +-
 drivers/misc/serdes/Kconfig        |    10 +
 drivers/misc/serdes/Makefile       |     5 +
 drivers/misc/serdes/SRE_base.h     |   242 +
 drivers/misc/serdes/SRE_drv.c      |   391 ++
 drivers/misc/serdes/SRE_drv.h      |   341 ++
 drivers/misc/serdes/SRE_errno.h    |   238 +
 drivers/misc/serdes/SRE_ge.c       |  5464 ++++++++++++++++++
 drivers/misc/serdes/SRE_ge.h       |  1087 ++++
 drivers/misc/serdes/SRE_ge1.h      |   853 +++
 drivers/misc/serdes/SRE_memmap.h   |  6122 ++++++++++++++++++++
 drivers/misc/serdes/SRE_phydrv.c   |  1675 ++++++
 drivers/misc/serdes/SRE_phydrv.h   |   201 +
 drivers/misc/serdes/SRE_rawmutex.h |   373 ++
 drivers/misc/serdes/SRE_serdes.c   | 10568 +++++++++++++++++++++++++++++++++++
 drivers/misc/serdes/SRE_serdes.h   |    65 +
 17 files changed, 27637 insertions(+), 9 deletions(-)
 create mode 100644 drivers/misc/serdes/Kconfig
 create mode 100644 drivers/misc/serdes/Makefile
 create mode 100644 drivers/misc/serdes/SRE_base.h
 create mode 100644 drivers/misc/serdes/SRE_drv.c
 create mode 100644 drivers/misc/serdes/SRE_drv.h
 create mode 100644 drivers/misc/serdes/SRE_errno.h
 create mode 100644 drivers/misc/serdes/SRE_ge.c
 create mode 100644 drivers/misc/serdes/SRE_ge.h
 create mode 100644 drivers/misc/serdes/SRE_ge1.h
 create mode 100644 drivers/misc/serdes/SRE_memmap.h
 create mode 100644 drivers/misc/serdes/SRE_phydrv.c
 create mode 100644 drivers/misc/serdes/SRE_phydrv.h
 create mode 100644 drivers/misc/serdes/SRE_rawmutex.h
 create mode 100644 drivers/misc/serdes/SRE_serdes.c
 create mode 100644 drivers/misc/serdes/SRE_serdes.h

diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 8d988a3..c44f950 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -549,7 +549,5 @@ source "drivers/misc/mei/Kconfig"
 source "drivers/misc/vmw_vmci/Kconfig"
 source "drivers/misc/mic/Kconfig"
 source "drivers/misc/genwqe/Kconfig"
-source "drivers/misc/echo/Kconfig"
-source "drivers/misc/cxl/Kconfig"
-source "drivers/misc/hisi-djtag/Kconfig"
+source "drivers/misc/serdes/Kconfig"
 endmenu
diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index 1c51bd1..360df7c 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -53,9 +53,4 @@ obj-$(CONFIG_LATTICE_ECP3_CONFIG)	+= lattice-ecp3-config.o
 obj-$(CONFIG_SRAM)		+= sram.o
 obj-y				+= mic/
 obj-$(CONFIG_GENWQE)		+= genwqe/
-obj-$(CONFIG_ECHO)		+= echo/
-obj-$(CONFIG_VEXPRESS_SYSCFG)	+= vexpress-syscfg.o
-obj-$(CONFIG_CXL_BASE)		+= cxl/
-obj-$(CONFIG_HISI_DJTAG)	+= hisi-djtag/
-obj-$(CONFIG_HISI_LPC)          += hisi-lpc/
-obj-$(CONFIG_HI6220_SYSCFG)     += hi6220-sysconfig.o
+obj-$(CONFIG_HIP04_SERDES)	+= serdes/
diff --git a/drivers/misc/serdes/Kconfig b/drivers/misc/serdes/Kconfig
new file mode 100644
index 0000000..b8a585a
--- /dev/null
+++ b/drivers/misc/serdes/Kconfig
@@ -0,0 +1,10 @@
+#
+# HISILICON serdes configuration
+#
+
+config HIP04_SERDES
+	bool "Hisilicon SERDES"
+	default y
+	depends on (ARM && ARCH_HIP04)
+	---help---
+	  to be removed
diff --git a/drivers/misc/serdes/Makefile b/drivers/misc/serdes/Makefile
new file mode 100644
index 0000000..8f998c9
--- /dev/null
+++ b/drivers/misc/serdes/Makefile
@@ -0,0 +1,5 @@
+#
+# Makefile for the HISILICON network device drivers.
+#
+
+obj-$(CONFIG_HIP04_SERDES) += SRE_drv.o SRE_serdes.o SRE_phydrv.o SRE_ge.o
diff --git a/drivers/misc/serdes/SRE_base.h b/drivers/misc/serdes/SRE_base.h
new file mode 100644
index 0000000..83d4010
--- /dev/null
+++ b/drivers/misc/serdes/SRE_base.h
@@ -0,0 +1,242 @@
+/**
+ * @file SRE_typedef.h
+ *
+ * Copyright(C), 2008-2050, Huawei Tech. Co., Ltd. ALL RIGHTS RESERVED. \n
+ *
+ * 描述：定义基本数据类型和数据结构。 \n
+ */
+
+/**
+ * @addtogroup SRE_sys 系统基本功能接口
+ * @ingroup
+ * @{
+*/
+
+#ifndef _SRE_TYPEDEF_H
+#define _SRE_TYPEDEF_H
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+#ifdef SRE_WIN
+#include <windows.h>
+#include <mmsystem.h>
+#include <malloc.h>
+#include <stdio.h>
+
+#define INLINE                                              static __inline
+#else
+#if 1
+#define EXPR_STAT_NOT_SUPPORT
+#define INLINE                                              static __inline
+#else
+#define INLINE                                              static inline
+#endif
+#endif
+
+
+
+#ifdef EXPR_STAT_NOT_SUPPORT
+#define SRE_MACRO_S  do{
+#define SRE_MACRO_E  }while(0)
+#else
+/* 编译器支持语句表达式时，使用以下宏，提高代码覆盖率 */
+#define SRE_MACRO_S  \
+    /*lint -save -e160 -e522 */ \
+    ({
+#define SRE_MACRO_E  \
+    }) \
+    /*lint -restore */
+#endif
+
+#ifndef SRE_TYPE_DEF
+#define SRE_TYPE_DEF
+
+/* type definitions */
+#ifdef SRE_WIN
+typedef unsigned __int64                                    UINT64;
+typedef signed   __int64                                    INT64;
+typedef unsigned int                                        UINTPTR;
+typedef signed int                                          INTPTR;
+typedef unsigned short                                      UINT16;
+typedef unsigned int                                        UINT32;
+typedef unsigned char                                       UINT8;
+typedef signed char                                         INT8;
+typedef signed short                                        INT16;
+typedef signed int                                          INT32;
+typedef float                                               FLOAT;
+typedef double                                              DOUBLE;
+typedef char                                                CHAR;
+#else
+typedef unsigned char                                       UINT8;
+typedef unsigned short                                      UINT16;
+typedef unsigned int                                        UINT32;
+typedef signed short                                        INT16;
+typedef signed int                                          INT32;
+typedef float                                               FLOAT;
+typedef double                                              DOUBLE;
+typedef char                                                CHAR;
+typedef unsigned long long                                  UINT64;
+typedef signed long long                                    INT64;
+typedef unsigned int                                        UINTPTR;
+typedef signed int                                          INTPTR;
+typedef unsigned int                                        BOOL;
+typedef signed char                                         INT8;
+#endif
+
+#define VOID                                                void
+
+#endif  /*end of #ifndef SRE_TYPE_DEF*/
+
+#ifndef FALSE
+#define FALSE                                               ((BOOL)0)
+#endif
+
+#ifndef TRUE
+#define TRUE                                                ((BOOL)1)
+#endif
+
+#ifndef NULL
+#define NULL                                                ((VOID *)0)
+#endif
+
+#ifdef  YES
+#undef  YES
+#endif
+#define YES                                                 (1)
+
+#ifdef  NO
+#undef  NO
+#endif
+#define NO                                                  (0)
+
+#define OS_NULL_BYTE                                        ((UINT8)0xff)
+#define OS_NULL_SHORT                                       ((UINT16)0xffff)
+#define OS_NULL_INT                                         ((UINT32)0xffffffff)
+#define OS_SUCCESS                                          (0)
+#define OS_FAIL                                             (1)
+#define OS_ERROR                                            (-1)
+#define OS_INVALID                                          (-1)
+
+//#define GDB_TEST_SWITCH
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+
+/*cavium65XX 驱动 基本数据类型和数据结构*/
+
+#ifndef __std_H
+#define __std_H
+
+
+#ifndef _ASMLANGUAGE
+
+/* *类型定义 */
+typedef int INT;
+
+typedef signed char     S8;
+typedef signed short    S16;
+typedef signed int      S32;
+
+#ifndef VC_DEBUG_MODE
+typedef long long       S64;
+#else
+typedef __int64         S64;
+#endif
+
+#ifndef U8
+typedef unsigned char   U8;
+#endif
+
+#ifndef U16
+typedef unsigned short  U16;
+#endif
+
+#ifndef U32
+typedef unsigned int    U32;
+#endif
+
+#ifndef VC_DEBUG_MODE
+typedef unsigned long long  U64;
+#else
+typedef unsigned __int64 U64;
+#endif
+
+#ifndef LONG
+typedef long    LONG;
+#endif
+
+/*
+#ifndef CHAR
+typedef char    CHAR;
+#endif
+*/
+
+typedef volatile unsigned char  V8;
+typedef volatile unsigned short V16;
+typedef volatile unsigned int   V32;
+
+#ifndef VC_DEBUG_MODE
+typedef volatile unsigned long long  V64;
+#else
+typedef volatile unsigned __int64 V64;
+#endif
+
+#ifndef VC_DEBUG_MODE
+typedef  char           BYTE;
+#endif
+
+typedef  unsigned char  UBYTE;
+typedef  short          HWORD;
+typedef  unsigned short UHWORD;
+
+#ifndef VC_DEBUG_MODE
+/*typedef  long           WORD;*/
+typedef  unsigned long  UWORD;
+#endif
+
+
+
+
+typedef  volatile char           VBYTE;
+typedef  volatile unsigned char  VUBYTE;
+typedef  volatile short          VHWORD;
+typedef  volatile unsigned short VUHWORD;
+typedef  volatile long           VWORD;
+typedef  volatile unsigned long  VUWORD;
+
+#define REG64(Addr) (*(volatile unsigned long long *)(Addr))
+#define REG32(Addr) (*(volatile unsigned int *)(Addr))
+#define REG16(Addr) (*(volatile unsigned short *)(Addr))
+#define REG8(Addr)  (*(volatile unsigned char *)(Addr))
+
+U32 vxImmrGet (void);
+
+#endif
+
+/* BEGIN: Added by l52061, 2007/8/17 */
+#define SIZE_1        1
+#define SIZE_4        4
+#define SIZE_59      59
+/* END:   Added by l52061, 2007/8/17 */
+#endif /* __std_H */
+
+#endif /* _SRE_TYPEDEF_H */
+
+/**
+ * @}
+*/
+
+/**
+ * History:
+ *
+ * vi: set expandtab ts=4 sw=4 tw=80:
+*/
+
diff --git a/drivers/misc/serdes/SRE_drv.c b/drivers/misc/serdes/SRE_drv.c
new file mode 100644
index 0000000..322825b
--- /dev/null
+++ b/drivers/misc/serdes/SRE_drv.c
@@ -0,0 +1,391 @@
+#include "SRE_drv.h"
+#include "SRE_memmap.h"
+#include "SRE_serdes.h"
+#include "SRE_phydrv.h"
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <uapi/asm-generic/errno-base.h>
+#include <asm/string.h>
+
+#ifdef __cplusplus
+ #if __cplusplus
+extern "C" {
+ #endif
+#endif /* __cplusplus */
+
+UINT32 g_uwPrintkLevel = MCSS_PRINTK_INFO;
+
+/* 寄存器映射空间 */
+// 1
+#define MCSS_BMU_SPACE_NAME             "mcss bmu space"
+#define MCSS_BMU_REG_BASE               SRE_BMU_REG_BASE_ADDR
+#define MCSS_BMU_REG_SIZE               0x400000
+// 2
+#define MCSS_PPE_TNL_SPACE_NAME         "mcss ppe tnl space"
+#define MCSS_PPE_TNL_REG_BASE           SRE_PPE_TNL_BASE
+#define MCSS_PPE_TNL_REG_SIZE           0x90000
+// 3
+#define MCSS_XGE_SPACE_NAME             "mcss xge space"
+#define MCSS_XGE_REG_BASE               SRE_XGE_BASE
+#define MCSS_XGE_REG_SIZE               0x10000
+// 4
+#define MCSS_PPE_COMMON_SPACE_NAME      "mcss ppe common space"
+#define MCSS_PPE_COMMON_REG_BASE        SRE_PPE_COMMON_BASE
+#define MCSS_PPE_COMMON_REG_SIZE        0x10000
+// 5
+#define MCSS_SERDES1_SPACE_NAME         "mcss serdes1 space"
+#define MCSS_SERDES1_REG_BASE           SERDES1_BASE_ADDR
+#define MCSS_SERDES1_REG_SIZE           0x10000
+// 6
+#define MCSS_MDIO_SPACE_NAME            "mcss mdio space"
+#define MCSS_MDIO_REG_BASE              MDIO_BASE_ADDR
+#define MCSS_MDIO_REG_SIZE              0x2000
+// 7
+#define MCSS_SERDES0_LOW_SPACE_NAME     "mcss serdes0 low space"
+#define MCSS_SERDES0_LOW_REG_BASE       SERDES0_LOW_BASE_ADDR
+#define MCSS_SERDES0_LOW_REG_SIZE       0x1000
+// 8
+#define MCSS_SERDES0_HIGHT_SPACE_NAME   "mcss serdes0 hight space"
+#define MCSS_SERDES0_HIGHT_REG_BASE     SERDES0_HIGHT_BASE_ADDR
+#define MCSS_SERDES0_HIGHT_REG_SIZE     0x1000
+// 9
+#define MCSS_IOCTRL0_SPACE_NAME         "mcss ioctrl0 space"
+#define MCSS_IOCTRL0_REG_BASE           IOCTRL0_BASE_ADDR
+#define MCSS_IOCTRL0_REG_SIZE           0x1000
+// 10
+#define MCSS_POE_SPACE_NAME             "mcss poe space"
+#define MCSS_POE_REG_BASE               SRE_POE_BASE
+#define MCSS_POE_REG_SIZE               0x800000
+// 11
+#if 0
+#define MCSS_POE_NORMAL_SPACE_NAME      "mcss poe normal space"
+#define MCSS_POE_NORMAL_REG_BASE        SRE_POE_NORMAL_BASE
+#define MCSS_POE_NORMAL_REG_SIZE        0x800000
+#endif
+// 12
+#define MCSS_SYS_SPACE_NAME             "mcss sys space"
+#define MCSS_SYS_REG_BASE               SRE_SYS_REG_BASEADDR
+#define MCSS_SYS_REG_SIZE               0x100000
+// 13
+#define MCSS_TM_SPACE_NAME              "mcss tm space"
+#define MCSS_TM_REG_BASE                SRE_TM_BASE
+#define MCSS_TM_REG_SIZE                0x800000
+// 14
+#define MCSS_GPIO_SPACE_NAME            "mcss gpio space"
+#define MCSS_GPIO_REG_BASE              SRE_GPIO_REG_BASE_ADDR
+#define MCSS_GPIO_REG_SIZE              0x5000
+// 15
+#define MCSS_SPI_SPACE_NAME             "mcss spi space"
+#define MCSS_SPI_REG_BASE               SPI_REG_BASE_ADDR
+#define MCSS_SPI_REG_SIZE               0x2000
+// 16
+#define MCSS_IOCONFIG_SPACE_NAME        "mcss ioconfig space"
+#define MCSS_IOCONFIG_REG_BASE          IOCONFIG_REG_BASE_ADDR
+#define MCSS_IOCONFIG_REG_SIZE          0x1000
+// 17
+#define MCSS_SERDES3_SPACE_NAME         "mcss serdes3 space"
+#define MCSS_SERDES3_REG_BASE           SERDES3_BASE_ADDR
+#define MCSS_SERDES3_REG_SIZE           0x1000
+// 18
+#define MCSS_IOCTRL1_SPACE_NAME         "mcss ioctrl1 space"
+#define MCSS_IOCTRL1_REG_BASE           IOCTRL1_BASE_ADDR
+#define MCSS_IOCTRL1_REG_SIZE           0x1000
+// 19
+#define MCSS_SERDES2_SPACE_NAME         "mcss serdes2 space"
+#define MCSS_SERDES2_REG_BASE           SERDES2_BASE_ADDR
+#define MCSS_SERDES2_REG_SIZE           0x10000
+// 20
+#define MCSS_SRIO_SPACE_NAME            "mcss srio space"
+#define MCSS_SRIO_REG_BASE              OS_SRE_SRIO_BASE_ADDR
+#define MCSS_SRIO_REG_SIZE              0x1000
+// 21
+#define MCSS_MPE_SPACE_NAME            "mcss mpe space"
+#define MCSS_MPE_REG_BASE              OS_SRE_MPE_BASE_ADDR
+#define MCSS_MPE_REG_SIZE              0x1000
+
+#define MCSS_REG_SPACE_NUM  9//10//20//21
+typedef struct
+{
+    UINT32 uwRegBase;
+    UINT32 uwSize;
+    char*  name;
+} MCSS_REG_ADDR_MAP_S;
+
+MCSS_REG_ADDR_MAP_S g_astRegAddrMap[MCSS_REG_SPACE_NUM] =
+{
+#if 0
+    {MCSS_BMU_REG_BASE, MCSS_BMU_REG_SIZE, MCSS_BMU_SPACE_NAME},
+    {MCSS_PPE_TNL_REG_BASE, MCSS_PPE_TNL_REG_SIZE, MCSS_PPE_TNL_SPACE_NAME},
+    {MCSS_XGE_REG_BASE, MCSS_XGE_REG_SIZE, MCSS_XGE_SPACE_NAME},
+    {MCSS_PPE_COMMON_REG_BASE, MCSS_PPE_COMMON_REG_SIZE, MCSS_PPE_COMMON_SPACE_NAME},
+#endif
+    {MCSS_SERDES1_REG_BASE, MCSS_SERDES1_REG_SIZE, MCSS_SERDES1_SPACE_NAME},
+#if 0
+    {MCSS_MDIO_REG_BASE, MCSS_MDIO_REG_SIZE, MCSS_MDIO_SPACE_NAME},
+#endif
+    {MCSS_SERDES0_LOW_REG_BASE, MCSS_SERDES0_LOW_REG_SIZE, MCSS_SERDES0_LOW_SPACE_NAME},
+    {MCSS_SERDES0_HIGHT_REG_BASE, MCSS_SERDES0_HIGHT_REG_SIZE, MCSS_SERDES0_HIGHT_SPACE_NAME},
+    {MCSS_IOCTRL0_REG_BASE, MCSS_IOCTRL0_REG_SIZE, MCSS_IOCTRL0_SPACE_NAME},
+#if 0
+    {MCSS_POE_REG_BASE, MCSS_POE_REG_SIZE, MCSS_POE_SPACE_NAME},
+    {MCSS_POE_NORMAL_REG_BASE, MCSS_POE_NORMAL_REG_SIZE, MCSS_POE_NORMAL_SPACE_NAME},
+#endif
+    {MCSS_SYS_REG_BASE, MCSS_SYS_REG_SIZE, MCSS_SYS_SPACE_NAME},
+#if 0
+    {MCSS_TM_REG_BASE, MCSS_TM_REG_SIZE, MCSS_TM_SPACE_NAME},
+    {MCSS_GPIO_REG_BASE, MCSS_GPIO_REG_SIZE, MCSS_GPIO_SPACE_NAME},
+    {MCSS_SPI_REG_BASE, MCSS_SPI_REG_SIZE, MCSS_SPI_SPACE_NAME},
+    {MCSS_IOCONFIG_REG_BASE, MCSS_IOCONFIG_REG_SIZE, MCSS_IOCONFIG_SPACE_NAME},
+#endif
+    {MCSS_SERDES3_REG_BASE, MCSS_SERDES3_REG_SIZE, MCSS_SERDES3_SPACE_NAME},
+    {MCSS_IOCTRL1_REG_BASE, MCSS_IOCTRL1_REG_SIZE, MCSS_IOCTRL1_SPACE_NAME},
+    {MCSS_SERDES2_REG_BASE, MCSS_SERDES2_REG_SIZE, MCSS_SERDES2_SPACE_NAME},
+    {MCSS_SRIO_REG_BASE, MCSS_SRIO_REG_SIZE, MCSS_SRIO_SPACE_NAME},
+#if 0
+    {MCSS_MPE_REG_BASE, MCSS_MPE_REG_SIZE, MCSS_MPE_SPACE_NAME},
+#endif
+};
+
+UINT32 g_uwRegSpaceNum = 0; /* 当前已映射的寄存器空间数量 */
+UINT32 g_uwDdrSpaceNum = 0; /* 当前已映射的DDR空间数量 */
+
+MCSS_ADDR_MAP_ST g_astRegMap[MCSS_REG_SPACE_MAX_NUM];
+MCSS_ADDR_MAP_ST g_astDdrMap[MCSS_DDR_SPACE_MAX_NUM];
+
+struct mcss_mana
+{
+    void __iomem    *reg_iomem[MCSS_REG_SPACE_MAX_NUM];
+    struct resource *reg_ioarea[MCSS_REG_SPACE_MAX_NUM];
+    void __iomem    *ddr_iomem[MCSS_DDR_SPACE_MAX_NUM];
+    struct resource *ddr_ioarea[MCSS_DDR_SPACE_MAX_NUM];
+};
+static struct  mcss_mana mcss_manager;
+
+INT32 mcss_add_reg_space(UINT32 phy_addr, UINT32 size, const char* name)
+{
+    INT32 rc = 0;
+
+    if (MCSS_REG_SPACE_MAX_NUM <= g_uwRegSpaceNum)
+    {
+		printk(": mcss_add_reg_space, reg space full, can not add\n");
+        SRE_printf(": mcss_add_reg_space, reg space full, can not add\n");
+        return OS_FAIL;
+    }
+
+    /* 申请寄存器 io内存 */
+    mcss_manager.reg_iomem[g_uwRegSpaceNum] = request_mem_region(phy_addr, size, name);
+    if (!mcss_manager.reg_iomem[g_uwRegSpaceNum])
+    {
+		printk(": Reg region(%d) busy, addr[%#x],size[%d]\n", g_uwRegSpaceNum, phy_addr, size);
+        rc = -EBUSY;
+        //goto out;//检查资源是否被占用
+    }
+
+    mcss_manager.reg_ioarea[g_uwRegSpaceNum] = ioremap(phy_addr, size);
+    if (!mcss_manager.reg_ioarea[g_uwRegSpaceNum])
+    {
+        printk(": could not ioremap MCSS reg%d,addr[%#x],size[%d]\n", g_uwRegSpaceNum, phy_addr, size);
+        rc = -ENXIO;
+        goto out_mem_region;
+    }
+
+    g_astRegMap[g_uwRegSpaceNum].phy_addr = phy_addr;
+    g_astRegMap[g_uwRegSpaceNum].size = size;
+    g_astRegMap[g_uwRegSpaceNum].vir_addr = mcss_manager.reg_ioarea[g_uwRegSpaceNum];
+    g_uwRegSpaceNum++;
+    goto out;
+
+out_mem_region:
+    release_resource(mcss_manager.reg_iomem[g_uwRegSpaceNum]);
+out:
+    return rc;
+}
+
+void mcss_clear_reg_space(void)
+{
+    UINT32 loop;
+
+    for (loop = 0; loop < g_uwRegSpaceNum; loop++)
+    {
+        iounmap(mcss_manager.reg_ioarea[loop]);
+        release_resource(mcss_manager.reg_iomem[loop]);
+    }
+    g_uwRegSpaceNum = 0;
+}
+
+INT32 mcss_add_ddr_space(UINT32 phy_addr, UINT32 size, const char* name)
+{
+    INT32 rc = 0;
+
+    if (MCSS_DDR_SPACE_MAX_NUM <= g_uwDdrSpaceNum)
+    {
+        SRE_printf(": mcss_add_ddr_space, reg space full, can not add\n");
+        return OS_FAIL;
+    }
+
+    /* 申请寄存器 io内存 */
+    mcss_manager.ddr_iomem[g_uwDdrSpaceNum] = request_mem_region(phy_addr, size, name);
+    if (!mcss_manager.ddr_iomem[g_uwDdrSpaceNum])
+    {
+        SRE_printf(": Ddr region(%d) busy, addr[%#x],size[%d]\n", g_uwDdrSpaceNum, phy_addr, size);
+        rc = -EBUSY;
+        goto out;
+    }
+
+    mcss_manager.ddr_ioarea[g_uwDdrSpaceNum] = ioremap(phy_addr, size);
+    if (!mcss_manager.ddr_ioarea[g_uwDdrSpaceNum])
+    {
+        SRE_printf(": could not ioremap MCSS ddr%d,addr[%#x],size[%d]\n", g_uwDdrSpaceNum, phy_addr, size);
+        rc = -ENXIO;
+        goto out_mem_region;
+    }
+
+    g_astDdrMap[g_uwDdrSpaceNum].phy_addr = phy_addr;
+    g_astDdrMap[g_uwDdrSpaceNum].size = size;
+    g_astDdrMap[g_uwDdrSpaceNum].vir_addr = mcss_manager.ddr_ioarea[g_uwDdrSpaceNum];
+    g_uwDdrSpaceNum++;
+    goto out;
+
+out_mem_region:
+    release_resource(mcss_manager.ddr_iomem[g_uwDdrSpaceNum]);
+out:
+    return rc;
+}
+
+void mcss_clear_ddr_space(void)
+{
+    UINT32 loop;
+
+    for (loop = 0; loop < g_uwDdrSpaceNum; loop++)
+    {
+        iounmap(mcss_manager.ddr_ioarea[loop]);
+        release_resource(mcss_manager.ddr_iomem[loop]);
+    }
+    g_uwDdrSpaceNum = 0;
+}
+
+
+UINT32 SRE_GetCoreID(void)
+{
+    UINT32 uwTmp;
+    __asm volatile(
+                "MRC p15, 0, %0, c0, c0, 5"
+                    :"=&r"(uwTmp));
+
+    return uwTmp & 0x1f;//core < 2^5=32
+}
+
+void SRE_DelayCycle(UINT32 cycle)
+{
+    volatile UINT32 uwLoop = cycle;
+    while (uwLoop > 0)
+    {
+        uwLoop--;
+    }
+}
+void MCSS_DumpMem(U8 *addr, UINT32 size)
+{
+    int i;
+    for (i=0; i< size; i++)
+    {
+        MC_PRINTK_WARNING(" 0x%02x", addr[i]);
+        if (15 == i%16)
+        {
+            MC_PRINTK_WARNING("\n");
+        }
+    }
+    MC_PRINTK_WARNING("\n");
+}
+
+void MCSS_SetPrintkLevel(UINT32 printlevel)
+{
+    g_uwPrintkLevel = printlevel;
+}
+
+void MCSS_PrintkBuildTime(void)
+{
+#define	MC_MOD_VERSION "Euler Test"
+    printk("mcss_mod version: %s, build time: %s %s\n", MC_MOD_VERSION, __DATE__, __TIME__);
+}
+
+UINT32 SRE_IoMemInit(VOID)
+{
+    int rc = 0;
+	int loop = 0;
+
+    /* step1: mmap寄存器 */
+    memset(&mcss_manager, 0, sizeof(struct mcss_mana));
+
+    /* 申请寄存器 io内存 */
+    for (loop = 0; loop < MCSS_REG_SPACE_NUM; loop++)
+    {
+        OS_DBG_PRINT("mcss_add_reg_space %#x, %d, %s\n", g_astRegAddrMap[loop].uwRegBase, g_astRegAddrMap[loop].uwSize, g_astRegAddrMap[loop].name);
+        rc = mcss_add_reg_space(g_astRegAddrMap[loop].uwRegBase, g_astRegAddrMap[loop].uwSize, g_astRegAddrMap[loop].name);
+        if (rc)
+        {
+            printk(KERN_ERR "mcss_add_reg_space fail, %#x, %d, %s\n", g_astRegAddrMap[loop].uwRegBase, g_astRegAddrMap[loop].uwSize, g_astRegAddrMap[loop].name);
+			mcss_clear_reg_space();
+        }
+    }
+	return rc;
+}
+
+/*#include <linux/module.h>
+#include <linux/kernel.h>
+#include "SRE_serdes.h"
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Maroleo");
+MODULE_DESCRIPTION("Maroleo's serdes Module");
+*/
+
+int serdes_init(void)
+{
+    unsigned int ret = OS_SUCCESS;
+	
+	ret = SRE_IoMemInit();
+
+    if (OS_SUCCESS != ret)
+    {
+        SRE_printf( "SRE_IoMemInit failed at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return -1;
+    }
+    
+/*
+	//comment here, replaced by drivers/net/ethernet/hisilicon/hip04_mdio.c
+	ret = SRE_StdPhySet(0); 
+    if (OS_SUCCESS != ret)
+	{
+        SRE_printf( "SRE_StdPhySet failed at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+		mcss_clear_reg_space();
+		return -1;
+	}
+*/
+	ret =  SRE_SerdesInit();
+    if (OS_SUCCESS != ret)
+	{
+        SRE_printf( "SRE_SerdesInit failed at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+		mcss_clear_reg_space();
+		return -1;
+	}
+	
+    return ret;
+}
+
+void serdes_exit(void)
+{
+	mcss_clear_reg_space();
+}
+
+
+subsys_initcall(serdes_init);
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+
diff --git a/drivers/misc/serdes/SRE_drv.h b/drivers/misc/serdes/SRE_drv.h
new file mode 100644
index 0000000..e533ccf
--- /dev/null
+++ b/drivers/misc/serdes/SRE_drv.h
@@ -0,0 +1,341 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : SRE_drv.h
+  版 本 号   : 初稿
+  作    者   : z00200342
+  生成日期   : 2013年3月18日
+  最近修改   :
+  功能描述   : SRE_drv.c头文件，common通用适配层
+  函数列表   :
+              SRE_MemFree
+  修改历史   :
+  1.日    期   : 2013年3月18日
+    作    者   : z00200342
+    修改内容   : 创建文件
+
+******************************************************************************/
+
+/*----------------------------------------------*
+ * 外部变量说明                                 *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 外部函数原型说明                             *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 内部函数原型说明                             *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 全局变量                                     *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 模块级变量                                   *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 常量定义                                     *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 宏定义                                       *
+ *----------------------------------------------*/
+
+
+#ifndef _SRE_DRV_H_
+#define _SRE_DRV_H_
+
+#include <linux/kernel.h>   /* printk() */
+#include <linux/delay.h>    /* mdelay */
+#include "SRE_base.h"
+#include "SRE_errno.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+#define MCSS_INTERRUPT_EN           1   /* MCSS KO收包是否中断通知用户态的开关 */
+#define MCSS_POE_INTERRUPT_EN       0   /* MCSS POE收包是否中断方式开关 1:中断 0:轮询 */
+
+///////////打印相关////////////////////////////////
+typedef enum
+{
+    MCSS_PRINTK_NONE    = 0x0,       /* 无打印 */
+    MCSS_PRINTK_ERROR   = 0x1,       /* 错误打印 */
+    MCSS_PRINTK_WARNING = 0x2,       /* 告警级别 */
+    MCSS_PRINTK_INFO    = 0x4,       /* 最低级别打印 信息 */
+} MCSS_PRINTK_LEVEL_E;
+
+extern UINT32 g_uwPrintkLevel;
+
+#define MC_PRINTK(printlevel, fmt, arg...)  \
+    do                                      \
+    {                                       \
+            (VOID)printk(fmt, ##arg);       \
+    } while (0);
+
+#define MC_PRINTK_INFO(fmt, arg...)      MC_PRINTK(MCSS_PRINTK_INFO, fmt, ##arg)
+#define MC_PRINTK_WARNING(fmt, arg...)   MC_PRINTK(MCSS_PRINTK_WARNING, fmt, ##arg)
+#define MC_PRINTK_ERROR(fmt, arg...)     MC_PRINTK(MCSS_PRINTK_ERROR, fmt, ##arg)
+
+#define SRE_printf                      MC_PRINTK_WARNING
+#define OS_DBG_PRINT                    MC_PRINTK_INFO
+
+extern void MCSS_SetPrintkLevel(UINT32 printlevel);
+
+#define OS_LIKELY(x)                (x)
+#define OS_UNLIKELY(x)              (x)
+#define OS_EMBED_ASM                __asm
+#define OS_SYNC                     //OS_EMBED_ASM("MCR p15, 0, 0, c7, c10, 5; MCR p15, 0, 0, c7, c10, 4"); /* DMB & DSB */
+#define OS_DMB                      //OS_EMBED_ASM("MCR p15, 0, 0, c7, c10, 5");
+#define OS_DSB                      //OS_EMBED_ASM("MCR p15, 0, 0, c7, c10, 4");
+
+#define SRE_MemCpy memcpy
+
+#if 1
+#define OS_MAX_CORE_NUM             16UL
+#define OS_MAX_VCPU_NUM             16UL
+#define OS_MAX_GRP_NUM              32UL
+#define OS_MAX_QUE_PER_GRP          8UL
+#define OS_MAX_QUE_NUM              256UL
+
+#endif
+
+/* 大小端转换 */
+#if 0
+#define BYTE_SWAP32(x)        ((((unsigned)(x) & 0x000000ff) << 24) | \
+			                             (((x) & 0x0000ff00) <<  8) | \
+			                             (((x) & 0x00ff0000) >>  8) | \
+			                             (((x) & 0xff000000) >> 24))
+#endif
+#define BYTE_SWAP32(x)        (x)
+
+#define OS_DataRev(uwValue)         ((UINT32)(BYTE_SWAP32(uwValue)))
+
+/* 定义结构体用于存储映射的地址 */
+typedef struct
+{
+    void * vir_addr;
+    UINT32 phy_addr;
+    UINT32 size;
+} MCSS_ADDR_MAP_ST;
+
+/*数据面寄存器区 760M(4+4+4+4+8+8+8+16+64+64+32+32+128+128+256 =760)*/
+#define MCSS_REG_SPACE_MAX_NUM  32  /* 允许映射的REG空间的数量 */
+#define MCSS_DDR_SPACE_MAX_NUM  32 /* 允许映射的DDR空间的数量 */
+
+extern UINT32 g_uwRegSpaceNum; /* 当前已映射的寄存器空间数量 */
+extern UINT32 g_uwDdrSpaceNum; /* 当前已映射的DDR空间数量 */
+
+extern MCSS_ADDR_MAP_ST g_astRegMap[MCSS_REG_SPACE_MAX_NUM];
+extern MCSS_ADDR_MAP_ST g_astDdrMap[MCSS_DDR_SPACE_MAX_NUM];
+
+
+INLINE UINT32 REG_VA2PA(void* vir_addr)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwRegSpaceNum; uwLoop ++)
+    {
+        if (((UINT32)vir_addr >= (UINT32)g_astRegMap[uwLoop].vir_addr) &&
+        ((UINT32)vir_addr < ((UINT32)g_astRegMap[uwLoop].vir_addr + g_astRegMap[uwLoop].size)))
+        {
+            return ((UINT32)vir_addr - (UINT32)g_astRegMap[uwLoop].vir_addr + (UINT32)g_astRegMap[uwLoop].phy_addr);
+        }
+    }
+
+    SRE_printf("REG_VA2PA: vir_Reg %#x invalid \n", (UINT32)vir_addr);
+
+    return 0;
+}
+
+INLINE UINT32 REG_PA2VA(void* phy_addr)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwRegSpaceNum; uwLoop ++)
+    {
+        if (((UINT32)phy_addr >= g_astRegMap[uwLoop].phy_addr) &&
+        ((UINT32)phy_addr < (g_astRegMap[uwLoop].phy_addr + g_astRegMap[uwLoop].size)))
+        {
+            return ((UINT32)phy_addr - (UINT32)g_astRegMap[uwLoop].phy_addr + (UINT32)g_astRegMap[uwLoop].vir_addr);
+        }
+    }
+
+    SRE_printf("REG_PA2VA:Reg %#x invalid \n", (UINT32)phy_addr);
+
+    return 0;
+}
+
+/* 地址是否处于映射区间内, 1:yes 0: no  */
+INLINE UINT32 REG_IsMmaped(UINT32 uwPA)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwRegSpaceNum; uwLoop ++)
+    {
+        if ((uwPA >= g_astRegMap[uwLoop].phy_addr) &&
+        (uwPA < (g_astRegMap[uwLoop].phy_addr + g_astRegMap[uwLoop].size)))
+        {
+            return 1;
+        }
+    }
+
+    return 0;
+}
+
+INLINE UINT32 OS_READ_REG(UINT32 pRegBase, UINT32 uwRegIndex)
+{
+    UINT32 uwTemp;
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwRegSpaceNum; uwLoop ++)
+    {
+        if (((pRegBase + uwRegIndex) >= g_astRegMap[uwLoop].phy_addr) &&
+        ((pRegBase + uwRegIndex) < (g_astRegMap[uwLoop].phy_addr + g_astRegMap[uwLoop].size)))
+        {
+            uwTemp = ((volatile UINT32 *)((UINT32)g_astRegMap[uwLoop].vir_addr + (pRegBase - g_astRegMap[uwLoop].phy_addr)))[(uwRegIndex)];
+            return OS_DataRev(uwTemp);
+        }
+    }
+
+    SRE_printf("OS_READ_REG:Reg %#x index %#x invalid \n", pRegBase, uwRegIndex);
+
+    return 0;
+}
+
+INLINE UINT32 OS_WRITE_REG(UINT32 pRegBase, UINT32 uwRegIndex, UINT32 uwValue)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwRegSpaceNum; uwLoop ++)
+    {
+        if (((pRegBase + uwRegIndex) >= g_astRegMap[uwLoop].phy_addr) &&
+        ((pRegBase + uwRegIndex) < (g_astRegMap[uwLoop].phy_addr + g_astRegMap[uwLoop].size)))
+        {
+            (( volatile UINT32 *)((UINT32)g_astRegMap[uwLoop].vir_addr + (pRegBase - g_astRegMap[uwLoop].phy_addr)))[(uwRegIndex)] = (OS_DataRev(uwValue));
+            return OS_SUCCESS;
+        }
+    }
+
+    SRE_printf("OS_WRITE_REG:Reg %#x index %#x invalid \n", pRegBase, uwRegIndex);
+
+    return OS_FAIL;
+}
+
+INLINE UINT32 DDR_VA2PA(void* vir_addr)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwDdrSpaceNum; uwLoop ++)
+    {
+        if (((UINT32)vir_addr >= (UINT32)g_astDdrMap[uwLoop].vir_addr) &&
+        ((UINT32)vir_addr < ((UINT32)g_astDdrMap[uwLoop].vir_addr + g_astDdrMap[uwLoop].size)))
+        {
+            MC_PRINTK_INFO("pool ioremap info: %#x, %#x, %#x;input %#x\n",
+                g_astDdrMap[uwLoop].phy_addr,
+                (UINT32)g_astDdrMap[uwLoop].vir_addr,
+                g_astDdrMap[uwLoop].size,
+                (UINT32)vir_addr);
+            return ((UINT32)vir_addr - (UINT32)g_astDdrMap[uwLoop].vir_addr + (UINT32)g_astDdrMap[uwLoop].phy_addr);
+        }
+    }
+
+    SRE_printf("%s %d: %#x \n", __FUNCTION__, __LINE__, (UINT32)vir_addr);
+
+    return 0;
+}
+
+INLINE UINT32 DDR_PA2VA(void* phy_addr)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwDdrSpaceNum; uwLoop ++)
+    {
+        if (((UINT32)phy_addr >= g_astDdrMap[uwLoop].phy_addr) &&
+        ((UINT32)phy_addr < (g_astDdrMap[uwLoop].phy_addr + g_astDdrMap[uwLoop].size)))
+        {
+            MC_PRINTK_INFO("pool ioremap info: %#x, %#x, %#x;input %#x\n",
+                g_astDdrMap[uwLoop].phy_addr,
+                (UINT32)g_astDdrMap[uwLoop].vir_addr,
+                g_astDdrMap[uwLoop].size,
+                (UINT32)phy_addr);
+            return ((UINT32)phy_addr - (UINT32)g_astDdrMap[uwLoop].phy_addr + (UINT32)g_astDdrMap[uwLoop].vir_addr);
+        }
+    }
+
+    SRE_printf("%s %d: %#x \n", __FUNCTION__, __LINE__, (UINT32)phy_addr);
+
+    return 0;
+}
+
+/* 地址是否处于映射区间内, 1:yes 0: no  */
+INLINE UINT32 DDR_IsMmaped(UINT32 uwPA)
+{
+    UINT32 uwLoop;
+
+    for (uwLoop = 0; uwLoop < g_uwDdrSpaceNum; uwLoop ++)
+    {
+        if ((uwPA >= g_astDdrMap[uwLoop].phy_addr) &&
+        (uwPA < (g_astDdrMap[uwLoop].phy_addr + g_astDdrMap[uwLoop].size)))
+        {
+            return 1;
+        }
+    }
+
+    SRE_printf("%s %d: %#x \n", __FUNCTION__, __LINE__, uwPA);
+
+    return 0;
+}
+
+extern int serdes_init(void);
+extern void serdes_exit(void); 
+
+extern UINT32 SRE_GetCoreID(void);
+
+#define SRE_DelayMs(ms) mdelay(ms)
+extern void SRE_DelayCycle(UINT32 cycle);
+
+#if 0
+extern void* MC_FromPhysToVirt(UINT64 ullPhyAddr);
+extern UINT32 MC_FromVirtToPhys(void *pVirtAddr);
+extern UINT32 SRE_MemFree(UINT32 uwMid, void *pAddr);
+
+
+typedef VOID* SRE_SPECLOCKID_T; /* 仅用于规避对SRE原有代码的修改，无实际意义 depend by SRE_mcc_p650.h line 313 */
+
+#define SRE_HwiCreate(intNo, intHandle, para) OS_SUCCESS  //need implement
+#define SRE_HwiEnable(intNo)    OS_SUCCESS
+#define HWI_PROC_FUNC           (void*)
+
+//显示编译时间
+extern void MCSS_PrintkBuildTime(void);
+
+/* P650单板类型 */
+typedef enum
+{
+    MC_BOARD_TYPE_UBBP_Y = 0,    /* 业务验证板 */
+    MC_BOARD_TYPE_UBBP_T,    /* t 板 */
+    MC_BOARD_TYPE_UBBP_V,    /* v 板 */
+} MC_BOARD_TYPE_ENUM;
+
+#define MC_BOARD_TYPE MC_BOARD_TYPE_UBBP_Y  //T板不初始化PHY/MDIO
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+
+#endif /* _SRE_DRV_H_ */
+
+
diff --git a/drivers/misc/serdes/SRE_errno.h b/drivers/misc/serdes/SRE_errno.h
new file mode 100644
index 0000000..0a89185
--- /dev/null
+++ b/drivers/misc/serdes/SRE_errno.h
@@ -0,0 +1,238 @@
+/**
+ * @file SRE_errno.h
+ *
+ * Copyright(C), 2008-2050, Huawei Tech. Co., Ltd. ALL RIGHTS RESERVED. \n
+ *
+ * 描述：通用错误码定义头文件。 \n
+ */
+
+/**
+ * @addtogroup SRE_err  错误处理
+ * @ingroup SRE_inspect
+ * @{
+*/
+
+#ifndef _SRE_ERRNO_H
+#define _SRE_ERRNO_H
+
+#include "SRE_base.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C" {
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+#define SRE_ErrHandle(pcFileName, uwLineNo, uwErrorNo, uwPara1, uwPara2) \
+    SRE_printf("%s,%d:%#x,%#x,%#x\n", pcFileName, uwLineNo, uwErrorNo, uwPara1, uwPara2);
+
+#define SRE_DotSet(pcFileName, uwLineNo, uwPara1, uwPara2) \
+    SRE_printf("%s,%d:%#x,%#x\n", pcFileName, uwLineNo, uwPara1, uwPara2)
+
+/* 0x00表示OS,0xFF表示DRV,应用系统可以使用 1~254 来标示应用各个子系统 */
+#define SRE_ERRNO_OS_ID                                     ((UINT32)0x00 << 16)
+
+/* 定义错误的等级 */
+#define SRE_ERRTYPE_NORMAL                                  ((UINT32)0x00 << 24)
+#define SRE_ERRTYPE_WARN                                    ((UINT32)0x01 << 24)
+#define SRE_ERRTYPE_ERROR                                   ((UINT32)0x02 << 24)
+#define SRE_ERRTYPE_FATAL                                   ((UINT32)0x03 << 24)
+
+/**
+ * @brief 定义OS致命错误
+ *
+ * @description
+ * 宏定义，定义OS致命错误
+ *
+ * @attention 无
+
+ * @param[in]   MID 模块ID编号。
+ * @param[in]   ERRNO 错误码编号。
+ *
+ * @retval 无
+ * @depend
+ * SRE_errno.h: 该宏定义所在的头文件。
+ * @since SRE V100R001
+ * @see SRE_ERRNO_OS_ERROR | SRE_ERRNO_OS_WARN | SRE_ERRNO_OS_NORMAL
+ */
+#define SRE_ERRNO_OS_FATAL(MID,ERRNO)   \
+            (SRE_ERRNO_OS_ID | ((UINT32)(MID) << 8) | SRE_ERRTYPE_FATAL | (ERRNO))
+
+
+/**
+ * @brief 定义OS严重错误
+ *
+ * @description
+ * 宏定义，定义OS严重错误
+ *
+ * @attention 无
+ * @param[in]   MID 模块ID编号。
+ * @param[in]   ERRNO 错误码编号。
+ *
+ * @retval 无
+ * @depend
+ * SRE_errno.h: 该宏定义所在的头文件。
+ * @since SRE V100R001
+ * @see SRE_ERRNO_OS_FATAL | SRE_ERRNO_OS_WARN | SRE_ERRNO_OS_NORMAL
+ */
+#define SRE_ERRNO_OS_ERROR(MID,ERRNO)  \
+            (SRE_ERRNO_OS_ID | ((UINT32)(MID) << 8) | SRE_ERRTYPE_ERROR | (ERRNO))
+
+
+/**
+ * @brief 定义OS告警信息
+ *
+ * @description
+ * 宏定义，定义OS告警
+ *
+ * @attention 无
+ * @param[in]   MID 模块ID编号。
+ * @param[in]   ERRNO 错误码编号。
+ *
+ * @retval 无
+ * @depend
+ * SRE_errno.h: 该宏定义所在的头文件。
+ * @since SRE V100R001
+ * @see SRE_ERRNO_OS_FATAL | SRE_ERRNO_OS_ERROR | SRE_ERRNO_OS_NORMAL
+ */
+#define SRE_ERRNO_OS_WARN(MID,ERRNO)  \
+            (SRE_ERRNO_OS_ID | ((UINT32)(MID) << 8) | SRE_ERRTYPE_WARN | (ERRNO))
+
+
+/**
+ * @brief 定义OS提示信息
+ *
+ * @description
+ * 宏定义，定义OS提示信息
+ *
+ * @attention 无
+ * @param[in]   MID 模块ID编号。
+ * @param[in]   ERRNO 错误码编号。
+ *
+ * @retval 无
+ * @depend
+ * @li SRE_errno.h: 该宏定义所在的头文件。
+ * @since SRE V100R001
+ * @see SRE_ERRNO_OS_FATAL | SRE_ERRNO_OS_ERROR | SRE_ERRNO_OS_WARN
+ */
+#define SRE_ERRNO_OS_NORMAL(MID,ERRNO)  \
+        (SRE_ERRNO_OS_ID | ((UINT32)(MID) << 8) | SRE_ERRTYPE_NORMAL | (ERRNO)); \
+
+
+/**
+*@brief 错误信息记录
+*
+*@description
+*记录出错信息
+*
+*@attention  无
+*
+*@param[in] uwErrLine,类型#UINT32 出错行号
+*@param[in] uwErrNo,  类型#UINT32 错误编号
+*@param[in] uwPara1,  类型#UINT32 记录信息1
+*@param[in] uwPara2,  类型#UINT32 记录信息2
+*
+*@retval 无
+*@depend
+*@li SRE_errno.h
+*@since SRE V100R001
+*@see SRE_ErrHandle
+*/
+#define REPORT_ERROR(uwErrLine, uwErrNo, uwPara1, uwPara2)  \
+    SRE_MACRO_S \
+        SRE_ErrHandle(__FILE__, uwErrLine, uwErrNo, (UINT32)(uwPara1), (UINT32)(uwPara2)); \
+    SRE_MACRO_E
+
+/**
+*@brief 错误信息记录并返回错误编号
+*
+*@description
+*遇到异常时记录错误发生地点和附加信息，\n
+*并返回错误编号
+*
+*@attention 无
+*
+*@param[in] uwErrLine,类型#UINT32 出错行号
+*@param[in] uwErrNo,  类型#UINT32 错误编号
+*@param[in] uwPara1,  类型#UINT32 记录信息1
+*@param[in] uwPara2,  类型#UINT32 记录信息2
+*
+*@retval uwErrNo,类型#UINT32 错误编号
+*@depend
+*@li SRE_errno.h
+*@since SRE V001R001
+*@see SRE_ErrHandle
+*/
+#define RETURN_ERROR(uwErrLine, uwErrNo, uwPara1, uwPara2) \
+    SRE_MACRO_S \
+        SRE_ErrHandle(__FILE__, uwErrLine, uwErrNo, (UINT32)(uwPara1), (UINT32)(uwPara2)); \
+        \
+        return uwErrNo; \
+    SRE_MACRO_E
+
+/**
+*@brief 错误跳转
+*@description
+*错误发生时记录错误信息，并跳转到错误执行处#ErrHandler
+*
+*@attention
+*@li 本语句只适合多异常分支的情形，以减少代码尺寸
+*@li 使用本宏的函数必须定义局部变量uwErrNo类型UINT32,uwErrLine类型UINT32,
+*uwPara1类型UINT32,uwPara2类型UINT32
+*
+*@param[in] uwErrNo,  类型#UINT32 错误编号
+*@param[in] uwP1,  类型#UINT32 记录信息1
+*@param[in] uwP2,  类型#UINT32 记录信息2
+*
+*@depend
+*@li SRE_errno.h
+*@since SRE V001R001
+*@see 无
+*/
+#define GOTO_ERR_HANDLER(uwErrorNo, uwP1, uwP2) \
+    SRE_MACRO_S \
+        uwErrNo    = uwErrorNo; \
+        uwErrLine  = __LINE__; \
+        uwPara1 = (UINT32)(uwP1); \
+        uwPara2 = (UINT32)(uwP2); \
+        goto ErrHandler; \
+    SRE_MACRO_E
+
+/**
+*@brief 记录初始化打点信息
+*@description
+*记录初始化打点信息；如果系统日志已初始化成功，同时记录日志信息
+*
+*@attention
+*
+*@param[in] uwP1,  类型#UINT32 打点信息1
+*@param[in] uwP2,  类型#UINT32 打点信息2
+*
+*@depend
+*@li SRE_errno.h
+*@since SRE V001R001
+*@see 无
+*/
+#define SRE_INIT_DOT(uwP1, uwP2) \
+    SRE_MACRO_S \
+        SRE_DotSet(__FILE__, __LINE__, (uwP1), (uwP2));\
+    SRE_MACRO_E
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif /* __cpluscplus */
+#endif /* __cpluscplus */
+
+#endif /* _SRE_ERRNO_H */
+
+/**
+ * @}
+*/
+
+/**
+ * History:
+ *
+ * vi: set expandtab ts=4 sw=4 tw=80:
+*/
+
diff --git a/drivers/misc/serdes/SRE_ge.c b/drivers/misc/serdes/SRE_ge.c
new file mode 100644
index 0000000..3e45d56
--- /dev/null
+++ b/drivers/misc/serdes/SRE_ge.c
@@ -0,0 +1,5464 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+文 件 名   	: mc_gmac_arch.c
+版 本 号   	: 初稿
+作    者       	:  w63320
+生成日期   	: 2009年6月15日
+最近修改   	:
+功能描述   	: ARM 网口驱动
+函数列表   	:
+修改历史   	:
+作    者   		: w63320
+修改内容   	: 创建文件
+
+******************************************************************************/
+
+#include "SRE_ge.h"
+#include "SRE_ge1.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+SRE_NET_DRV_SHARE_S g_stSreNetDrvShare; //by zqg
+#if 0
+extern SRE_NET_PERF_CFG_S gstrMcPerfCfg; //by zqg
+extern MC_MEM_POOL_CFG gastrMcMemPoolCfg[SRE_MEM_POOL_MAX_NUM];
+#endif
+/* BEGIN: Modified by f63884, 2012/8/14 */
+#if 0
+extern SRE_BLKMEM_SHARE_S *gpstrMcBlkmemShare;
+#endif
+/* END:   Modified by f63884, 2012/8/14 */
+//extern UINT32 SRE_GetPoePktNum(VOID); //by zqg: not use
+extern UINT32 SRE_UpdateAnLinkTime(UINT32 uwPort, UINT32 uwAnLinkTime);
+
+extern UINT32 MAR1512_Write(UINT32 uwRegAddr, UINT32 uwPage, UINT32 uwVal);//def in SRE_phydrv.c
+//extern UINT32 MAR1512_Read(UINT32 uwRegAddr, UINT32 uwPage, UINT32 *puwVal);//zqg:not use
+
+UINT32 SRE_PhyDelayUs(UINT32 uwTime)
+{
+    UINT32 i;
+    volatile UINT32 j;
+    for(i = 0;i<uwTime; i++)
+
+    {
+        j = i;
+    }
+    (void)j;
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GeResetDreq
+ 功能描述  : GE软复位去请求接口
+ 输入参数  : VOID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年6月9日
+    作    者   : wugao
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GeRstDreq(VOID)
+{
+    OS_WRITE_REG(SRE_SC_GE_RESET_DREQ_REG, 0, 0xffffffff);    /* ge tx&rx rstdreq */
+    OS_WRITE_REG(SRE_SC_MAC_CFG_RESET_DREQ_REG, 0, 0xffffffff);    /* ge cfg rstdreq */
+    OS_WRITE_REG(SRE_SC_MAC_RESET_DREQ_REG, 0, 0xffffffff);    /* ge eth&mac rstdreq */
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_WaitMdioReady
+ 功能描述  :等待mdio接口操作完成
+ 输入参数  : uwMdioID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_WaitMdioReady(UINT32 uwMdioID)
+{
+    MDIO_COMMAND_REG_U  unMdioCmd;
+    UINT32              uwTimeout = 1000;
+
+    while (uwTimeout)
+    {
+        --uwTimeout;
+
+        MDIO_REG_READ(uwMdioID, MDIO_COMMAND_REG, unMdioCmd.u32);
+        if (0 == unMdioCmd.bits.Mdio_Start)
+        {
+            return OS_SUCCESS;
+        }
+
+        //SRE_DelayUs(1000);
+        SRE_PhyDelayUs(1000);
+    }
+
+    return OS_FAIL;
+}
+
+/*****************************************************************************
+  RE_MdioStartPhyRead
+ 功能描述  :执行读操作
+ 输入参数  : uwMdioID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+VOID SRE_MdioStartPhyRead(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum)
+{
+    MDIO_COMMAND_REG_U unMdioCmdReg;
+
+    /* Step 2; 配置命令寄存器，发出读命令  */
+    unMdioCmdReg.u32             = 0;
+    unMdioCmdReg.bits.Mdio_St    = MDIO_ST_CLAUSE_22;       /* 配置当前的mdio为clause22  */
+    unMdioCmdReg.bits.Mdio_Op    = MDIO_CLAUSE_22_READ;     /* 配置当前的操作为读操作  */
+    unMdioCmdReg.bits.Mdio_Prtad = (UINT16)uwPhyAddr;        /* 当mdio_st为2’b01时，表示要访问的外部的PHY地址  */
+    unMdioCmdReg.bits.Mdio_Devad = uwPhyRegNum;                /* 当mdio_st为2’b01时，表示要访问的外部PHY的寄存器地址  */
+    unMdioCmdReg.bits.Mdio_Start = 1;                       /* 启动操作  */
+    MDIO_REG_WRITE(uwMdioID, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+
+    return;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MdioStartPhyRead
+ 功能描述  :执行mdio写操作
+ 输入参数  : mdio_id，phy地址，寄存器号，写入的值
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+VOID SRE_MdioPhyWrite(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 uwWriteValue)
+{
+    MDIO_COMMAND_REG_U  unMdioCmdReg;
+    MDIO_WDATA_REG_U    unMdioWDataReg;
+
+    /* Step 1; 将需要写入的值先写入写访问数据寄存器  */
+    MDIO_REG_READ(uwMdioID, MDIO_WDATA_REG, unMdioWDataReg.u32);
+    unMdioWDataReg.bits.Mdio_Wdata = uwWriteValue;
+    MDIO_REG_WRITE(uwMdioID, MDIO_WDATA_REG, unMdioWDataReg.u32);
+
+    /* Step 2; 配置写操作命令  */
+    unMdioCmdReg.u32             = 0;
+    unMdioCmdReg.bits.Mdio_St    = MDIO_ST_CLAUSE_22;       /* 配置当前的mdio为clause22  */
+    unMdioCmdReg.bits.Mdio_Op    = MDIO_CLAUSE_22_WRITE;    /* 配置当前的操作为写操作  */
+    unMdioCmdReg.bits.Mdio_Prtad = (UINT16)uwPhyAddr;       /* 当mdio_st为2’b01时，表示要访问的外部的PHY地址  */
+    unMdioCmdReg.bits.Mdio_Devad = uwPhyRegNum;             /* 当mdio_st为2’b01时，表示要访问的外部PHY的寄存器地址  */
+    unMdioCmdReg.bits.Mdio_Start = 1;                       /* 启动操作  */
+    MDIO_REG_WRITE(uwMdioID, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MdioRead
+ 功能描述  : MDIO接口的读操作函数
+ 输入参数  : mdio组id，phy地址，要读的寄存器号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_MdioRead(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 *puwRegValue)
+{
+    MDIO_RDATA_REG_U    unMdioRDataReg;
+    MDIO_STA_REG_U      unMdioStaReg;
+    //SRE_printf("SRE_MdioRead para check begin\n");
+    /* 输入参数合法性判断 */
+    if (uwMdioID >= SRE_MDIO_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwMdioID(%d) Error!"
+            "\n[ %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_ID, uwMdioID, 0, 0, 0);
+	   	RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_ID, 0, 0);
+    }
+
+    if (uwPhyAddr > SRE_PHY_ADDR_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwPhyAddr(%d) Error!"
+            "\n[ %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_PHY_ADDR, uwPhyAddr, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_PHY_ADDR, 0, 0);
+    }
+
+    if (uwPhyRegNum > SRE_PHY_REG_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwPhyRegNum(%d) Error!"
+            "\n[ %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_PHY_REG, uwPhyRegNum, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_PHY_REG, 0, 0);
+    }
+
+    if (NULL == puwRegValue)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: puwRegValue is NULL!"
+            "\n[ %d, %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_INPUT_PTR_NULL, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_INPUT_PTR_NULL, 0, 0);
+    }
+
+    /* Step 1; 先判断MDIO_COMMAND_REG的mdio_start位是否为0，因为只有为0的时候，才可以进行读写操作  */
+    if (SRE_WaitMdioReady(uwMdioID) != OS_SUCCESS)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Mdio busy!"
+            "\n[ %d, %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_BUSY, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_BUSY, 0, 0);
+    }
+    //SRE_printf("SRE_MdioRead para check end\n");
+    /* Step 2; 配置命令寄存器，发出读命令  */
+    SRE_MdioStartPhyRead(uwMdioID, uwPhyAddr, uwPhyRegNum);
+
+    /* Step 3; 查询MDIO_COMMAND_REG的mdio_start位是否为0， 检查此时读命令是否完成  */
+    if (SRE_WaitMdioReady(uwMdioID) != OS_SUCCESS)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Read timeout!"
+            "\n[ %d, %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_READ, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_READ, 0, 0);
+    }
+    //SRE_printf("SRE_MdioRead step 3.1 ok\n");
+
+    MDIO_REG_READ(uwMdioID, MDIO_STA_REG, unMdioStaReg.u32);
+    if (unMdioStaReg.bits.Mdio_Sta) /* 表示读操作异常  */
+    {
+        SRE_printf("[SRE_HISGMAC]: Mdio Read fail!\n");
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_READ, 0, 0);
+    }
+    //SRE_printf("SRE_MdioRead step 3.2 ok\n");
+
+    /* Step 4; 读出数据  */
+    MDIO_REG_READ(uwMdioID, MDIO_RDATA_REG, unMdioRDataReg.u32);
+    *puwRegValue = unMdioRDataReg.bits.Mdio_Rdata;
+
+	return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MdioWrite
+ 功能描述  : MDIO接口的写操作函数
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_MdioWrite(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 uwWriteValue)
+{
+    /* 输入参数合法性判断 */
+    if (uwMdioID >= SRE_MDIO_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwMdioID(%d) Error!"
+            "\n[ %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_ID, uwMdioID, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_ID, 0, 0);
+    }
+
+    if (uwPhyAddr > SRE_PHY_ADDR_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwPhyAddr(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_PHY_ADDR, uwPhyAddr, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_PHY_ADDR, 0, 0);
+    }
+
+    if (uwPhyRegNum > SRE_PHY_REG_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: uwPhyRegNum(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_PHY_REG, uwPhyRegNum, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_PHY_REG, 0, 0);
+    }
+
+    /* Step 1; 先判断MDIO_COMMAND_REG的mdio_start位是否为0，因为只有为0的时候，才可以进行读写操作  */
+    if (SRE_WaitMdioReady(uwMdioID) != OS_SUCCESS)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Read timeout!"
+            "\n[ %d, %d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_MDIO_READ, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_MDIO_READ, 0, 0);
+    }
+
+    SRE_MdioPhyWrite(uwMdioID, uwPhyAddr, uwPhyRegNum, uwWriteValue);
+
+    return OS_SUCCESS;
+}
+#if 0
+/*****************************************************************************
+ 函 数 名  : SRE_GmacReadPhy
+ 功能描述  : 读phy寄存器接口
+ 输入参数  : UINT32 uwPhyAddr
+             UINT32 uwPhyRegNum
+             UINT32 uwShadow
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年1月20日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacReadPhy(UINT32 uwMdioId, UINT32 uwPhyAddr, UINT32 uwPhyRegNum,
+    UINT32 uwShadow)
+{
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GeEnableRx
+ 功能描述  : 使能gmac的接收通道
+ 输入参数  : 端口号、value设置值(取值范围0或1)
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_GeEnableRx( UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_PORT_EN_U unPortEn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    // read the RX channel configuration register to get current status
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_EN_REG, unPortEn.u32);
+    unPortEn.bits.rx_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_EN_REG, unPortEn.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GeEnableTx
+ 功能描述  : 使能gmac的发送通道
+ 输入参数  : 端口号、value设置值(取值范围0或1)
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_GeEnableTx(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_PORT_EN_U unPortEn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    // read the RX channel configuration register to get current status
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_EN_REG, unPortEn.u32);
+    unPortEn.bits.tx_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_EN_REG, unPortEn.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GetGeEnableRxTx( UINT32 uwPort, UINT32 *puwRxEn, UINT32 *puwTxEn)
+{
+    SRE_GMAC_PORT_EN_U unPortEn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwRxEn)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    if(NULL == puwRxEn)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    // read the RX channel configuration register to get current status
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_EN_REG, unPortEn.u32);
+    *puwRxEn = unPortEn.bits.rx_en;
+    *puwTxEn = unPortEn.bits.tx_en;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_PortWorkModeSet, SRE_PortWorkModeGet
+ 功能描述  : 当前GMAC接口类型的设置和查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_PortWorkModeSet(UINT32 uwPort, SRE_PORT_MODE_E enPortMode)
+{
+    SRE_GMAC_PORT_MODE_U unPortMode;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if ( enPortMode > GMAC_1000M_SGMII )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] PortMode exceeds the maximum number!"
+            "\nenPortMode = %d,[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            OS_ERRNO_GMAC_PORT_MODE, enPortMode, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_MODE, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    unPortMode.bits.port_mode = enPortMode;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PortWorkModeGet(UINT32 uwPort, SRE_PORT_MODE_E *pMode)
+{
+    SRE_GMAC_PORT_MODE_U unPortMode;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    *pMode = (SRE_PORT_MODE_E)unPortMode.bits.port_mode;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_AnModeSet, SRE_AnModeGet
+ 功能描述  : 自协商使能的设置和状态获取
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_AnModeSet(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    unTxCtrl.bits.an_enable = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_AnModeGet(UINT32 uwPort, UINT32 *pEnable)
+{
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pEnable)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    *pEnable = unTxCtrl.bits.an_enable;
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_AnTypeSet(UINT32 uwPort, MCSS_AUTONEG_MODE_E *penAutoNegMode)
+{
+    SRE_GMAC_TX_LOCAL_PAG_U unTxLocalPag;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == penAutoNegMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+    if(MCSS_GMAC_AUTONEG_1000BASEX == *penAutoNegMode)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+        unTxLocalPag.bits.cfg_15bit = 0;  /* 1000Base-X自协商模式下，bit15是保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_13_12bit = 0;    /* 1000Base-X本地状态00：No error, link OK (default)01：Offline10：Link_Failure11：Auto-Negotiation_Error */
+        unTxLocalPag.bits.cfg_11_10bit = 0;     /* 1000Base-X自协商模式下，bit11、bit10是保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_8_5bit = 0xd;     /* 1000Base-X自协商模式：bit[8:7]意义如下：2'b00：不支持流控帧 2'b01：既可以发送PAUSE也能够处理接收的PAUSE帧2'b10：可以发送PAUSE帧，但不能处理接收到的PAUSE（丢弃或作为普通多播帧处理） */
+                                           /*  2'11：具有以下三种能力：其一，同时支持发送和处理PAUSE帧；其二，支持发送PAUSE帧，但不处理PAUSE帧；其三，支持处理PAUSE帧，但不支持发送PAUSE帧 */
+                                           /* Bit6表示：1：能支持半双工；0：不能支持半双工 Bit5表示：1：能支持全双工；0：不能支持全双工 */
+        unTxLocalPag.bits.cfg_0bit = 0;         /* 1000Base-X自协商模式，bit0是保留域，必须配置为0 */
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+    }
+    else if (MCSS_GMAC_AUTONEG_SGMII_PHY == *penAutoNegMode)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+        unTxLocalPag.bits.cfg_15bit = 0;   /* 表示link状态 1：link up 0：link down */
+        unTxLocalPag.bits.cfg_13_12bit = 0;     /* SGMII自协商PHY模式下bit13是保留域，必须配置为0，bit12表示Duplex状态1：full0：half */
+        unTxLocalPag.bits.cfg_11_10bit = 0;     /* SGMII自协商PHY模式，表示本端Speed状态11：保留10：1000BASE-TX/1000BASE-X10: 100BASE-TX/100BASE-FX00: 10BASET/10BASE2/10BASE5 */
+        unTxLocalPag.bits.cfg_8_5bit = 0;       /* SGMII自协商PHY模式下bit8~bit5为保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_0bit = 1;         /* SGMII自协商PHY模式下bit0必须配置为1 */
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+    }
+    else if (MCSS_GMAC_AUTONEG_SGMII_MAC == *penAutoNegMode)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+        unTxLocalPag.bits.cfg_15bit = 0;   /* SGMII自协商MAC模式，bit15是保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_13_12bit = 0;     /* SGMII自协商MAC模式下bit13、bit12是保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_11_10bit = 0;     /* SGMII自协商MAC模式下，bit11、bit10是保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_8_5bit = 0;       /* SGMII自协商MAC模式下bit8~bit5为保留域，必须配置为0 */
+        unTxLocalPag.bits.cfg_0bit = 1;         /* SGMII自协商MAC模式下bit0必须配置为1 */
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+    }
+    else
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input para error!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PARA, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PARA, 0, 0);
+    }
+    //SRE_printf("*unTxLocalPag.u32  0x%x\n", unTxLocalPag.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_AnTypeGet(UINT32 uwPort, MCSS_AUTONEG_MODE_E *penAutoNegMode)
+{
+    SRE_GMAC_TX_LOCAL_PAG_U unTxLocalPag;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == penAutoNegMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, unTxLocalPag.u32);
+    //SRE_printf("*unTxLocalPag.bits.cfg_8_5bit  0x%x\n", unTxLocalPag.bits.cfg_8_5bit);
+    //SRE_printf("*unTxLocalPag.bits.cfg_0bit  0x%x\n", unTxLocalPag.bits.cfg_0bit);
+    if((0xd == unTxLocalPag.bits.cfg_8_5bit) && (0 == unTxLocalPag.bits.cfg_0bit))
+    {
+        *penAutoNegMode = MCSS_GMAC_AUTONEG_1000BASEX;
+        //SRE_printf("*penAutoNegMode  0x%x\n", *penAutoNegMode);
+    }
+    else if(1 == unTxLocalPag.bits.cfg_0bit)
+    {
+        *penAutoNegMode = MCSS_GMAC_AUTONEG_SGMII_PHY;
+        //SRE_printf("*penAutoNegMode  0x%x\n", *penAutoNegMode);
+    }
+    else
+    {
+        *penAutoNegMode = MCSS_GMAC_AUTONEG_RESERVE;
+        //SRE_printf("*penAutoNegMode  0x%x\n", *penAutoNegMode);
+    }
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_MaxFrmSizeSet, SRE_MaxFrmSizeGet
+ 功能描述  : 端口接收最大帧长设置和获取
+ 输入参数  : uwFramSize 单位是字节，最大可配置为0xfffb，即65531
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_MaxFrmSizeSet(UINT32 uwPort, UINT32 uwFramSize)
+{
+    SRE_GMAC_MAX_FRM_SIZE_U unMaxFrmSize;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwFramSize > SRE_GMAC_MAX_FRM_SIZE)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PKT_LEN_EXCCEED_MAX, 0, 0);
+    }
+    g_stSreNetDrvShare.auwSreGmacMaxFrmSize[uwPort] = uwFramSize;//by zqg
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAX_FRM_SIZE_REG, unMaxFrmSize.u32);
+    unMaxFrmSize.bits.max_frm_size = uwFramSize;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MAX_FRM_SIZE_REG, unMaxFrmSize.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_MaxFrmSizeGet(UINT32 uwPort, UINT32 *pFramSize)
+{
+    SRE_GMAC_MAX_FRM_SIZE_U unMaxFrmSize;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pFramSize)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAX_FRM_SIZE_REG, unMaxFrmSize.u32);
+    *pFramSize = unMaxFrmSize.bits.max_frm_size;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_ShortFrmSizeSet, SRE_ShortFrmSizeGet
+ 功能描述  : 端口接收超短帧长设置和获取
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_ShortFrmSizeSet(UINT32 uwPort, UINT32 uwFramSize)
+{
+    SRE_GMAC_SHORT_RUNTS_THR_U unShortFrmThr;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwFramSize > SRE_GMAC_SHORT_MAX_FRM_SIZE)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PKT_SHORT_LEN_EXCCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_SHORT_RUNTS_THR_REG, unShortFrmThr.u32);
+    unShortFrmThr.bits.short_runts_thr = uwFramSize;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_SHORT_RUNTS_THR_REG, unShortFrmThr.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_ShortFrmSizeGet(UINT32 uwPort, UINT32 *pFramSize)
+{
+    SRE_GMAC_SHORT_RUNTS_THR_U unShortFrmThr;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pFramSize)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_SHORT_RUNTS_THR_REG, unShortFrmThr.u32);
+    *pFramSize = unShortFrmThr.bits.short_runts_thr;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_ShortFrmPassEn, SRE_ShortFrmPassStatusGet
+ 功能描述  : 短帧 和 超短帧的透传使能和状态查询
+             (加上crc的长短小于等于8byte确定无法传入)
+ 输入参数  : 端口号，en_value取值范围(0和1)
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_ShortFrmPassEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+    unRecvCtrl.bits.runt_pkt_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_ShortFrmPassStatusGet(UINT32 uwPort, UINT32 *pEnValue)
+{
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pEnValue)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+    *pEnValue = unRecvCtrl.bits.runt_pkt_en;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_RxPadStripEn, SRE_RxPadStripStatusGet, SRE_TxPadAddEn, SRE_TxPadAddStatusGet
+ 功能描述  : 接收pad剥离使能和发送pad添加使能以及状态查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_RxPadStripEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+    unRecvCtrl.bits.strip_pad_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_RxPadStripStatusGet(UINT32 uwPort, UINT32 *pEnValue)
+{
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pEnValue)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+    *pEnValue = unRecvCtrl.bits.strip_pad_en;
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 SRE_TxPadAddEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    unTxCtrl.bits.pad_enable = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_TxPadAddStatusGet(UINT32 uwPort, UINT32 *pEnValue)
+{
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pEnValue)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    *pEnValue = unTxCtrl.bits.pad_enable ;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_RxSkipLenSet, SRE_RxSkipLenGet
+ 功能描述  : 报文头不解析字段长度设置和查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_RxSkipLenSet(UINT32 uwPort, UINT32 uwSkipLen)
+{
+    SRE_GMAC_MAC_SKIP_LEN_U unSkipLenReg;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLenReg.u32);
+    unSkipLenReg.bits.mac_skip_len = uwSkipLen;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLenReg.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_RxSkipLenGet(UINT32 uwPort, UINT32 *pSkipLen)
+{
+    SRE_GMAC_MAC_SKIP_LEN_U unSkipLenReg;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pSkipLen)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLenReg.u32);
+    *pSkipLen = unSkipLenReg.bits.mac_skip_len;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_LineLoopBackEn, SRE_InLoopBackEn
+ 功能描述  : 链路测环回使能和应用测环回使能
+ 输入参数  : 端口号，en_value(取值范围0和1)
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_LineLoopBackEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_LINE_LOOP_BACK_U unLineLoopBack;
+    SRE_GMAC_LOOP_REG_U unLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_InLoopBackDis(uwPort);
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LINE_LOOP_BACK_REG, unLineLoopBack.u32);
+    unLineLoopBack.bits.line_loop_back = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LINE_LOOP_BACK_REG, unLineLoopBack.u32 );
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32);
+    if(1 == uwEnValue)
+    {
+        unLoopBack.bits.cf_ext_drive_lp = 0;
+    }
+    else
+    {
+        unLoopBack.bits.cf_ext_drive_lp = 1;
+    }
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_LineLoopBackDis
+ 功能描述  : 链路侧环回去使能
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月14日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_LineLoopBackDis(UINT32 uwPort)
+{
+    SRE_GMAC_LINE_LOOP_BACK_U unLineLoopBack;
+    SRE_GMAC_LOOP_REG_U unLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LINE_LOOP_BACK_REG, unLineLoopBack.u32);
+    unLineLoopBack.bits.line_loop_back = 0;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LINE_LOOP_BACK_REG, unLineLoopBack.u32 );
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32);
+    unLoopBack.bits.cf_ext_drive_lp = 1;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32 );
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_InLoopBackEn
+ 功能描述  : 应用侧环回使能
+ 输入参数  : UINT32 uwPort
+             UINT32 uwEnValue
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月14日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_InLoopBackEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_LOOP_REG_U unLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+    SRE_LineLoopBackDis(uwPort);
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32);
+    unLoopBack.bits.cf2mi_lp_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_InLoopBackDis
+ 功能描述  : 应用侧环回去使能
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月14日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_InLoopBackDis(UINT32 uwPort)
+{
+    SRE_GMAC_LOOP_REG_U unLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32);
+    unLoopBack.bits.cf2mi_lp_en = 0;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SdsLoopBackEn
+ 功能描述  : Serdes环回使能
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月5日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SdsLoopBackEn(UINT32 uwPort)
+{
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SdsLoopBackDis
+ 功能描述  : Serdes环回禁止
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月5日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SdsLoopBackDis(UINT32 uwPort)
+{
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SdsOutLoopBackEn
+ 功能描述  : Serdes外环回使能
+ 输入参数  : UINT32 uwPort
+             UINT32 uwMode 0串行外环   1串行并环
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年4月8日
+    作    者   : z00176027
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SdsOutLoopBackEn(UINT32 uwPort,UINT32 mode)
+{
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SdsLoopBackDis
+ 功能描述  : Serdes外环回禁止
+ 输入参数  : UINT32 uwPort
+             UINT32 uwMode 0串行外环   1串行并环
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年4月8日
+    作    者   : z00176027
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SdsOutLoopBackDis(UINT32 uwPort,UINT32 mode)
+{
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetInLoopBackStatus
+ 功能描述  : 应用侧环回状态查询函数
+ 输入参数  : UINT32 uwPort
+             UINT32* puwLoopBackStatus
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年2月3日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetInLoopBackStatus(UINT32 uwPort, UINT32* puwLoopBackStatus)
+{
+    SRE_GMAC_LOOP_REG_U unLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwLoopBackStatus)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LOOP_REG, unLoopBack.u32);
+    *puwLoopBackStatus = unLoopBack.bits.cf2mi_lp_en;
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetLineLoopBackStatus
+ 功能描述  : 链路侧环回状态查询函数
+ 输入参数  : UINT32 uwPort
+             UINT32* puwLoopBackStatus
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年2月3日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetLineLoopBackStatus(UINT32 uwPort, UINT32* puwLoopBackStatus)
+{
+    SRE_GMAC_LINE_LOOP_BACK_U unLineLoopBack;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwLoopBackStatus)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LINE_LOOP_BACK_REG, unLineLoopBack.u32);
+    *puwLoopBackStatus = unLineLoopBack.bits.line_loop_back;
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetSdsLoopBackStatus
+ 功能描述  : Ge的pcs和serdes接口出链路侧环回状态获取
+ 输入参数  : UINT32 uwPort
+             UINT32* puwSdsBackStatus
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2013年7月23日
+    作    者   : wugao
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetSdsLoopBackStatus(UINT32 uwPort, UINT32* puwSdsBackStatus)
+{
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwSdsBackStatus)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    *puwSdsBackStatus = 0;
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GmacLoopEnableShow(UINT32 uwPort)
+{
+    UINT32 uwInLoopBackStatus;
+    UINT32 uwLineLoopBackBackStatus;
+    UINT32 uwSdsBackStatus;
+
+    SRE_GetInLoopBackStatus(uwPort, &uwInLoopBackStatus);
+    SRE_GetLineLoopBackStatus(uwPort, &uwLineLoopBackBackStatus);
+    SRE_GetSdsLoopBackStatus(uwPort, &uwSdsBackStatus);
+
+    if(1 == uwInLoopBackStatus)
+    {
+        SRE_printf("in loop back : enable\n");
+    }
+    else
+    {
+        SRE_printf("in loop back : disable\n");
+    }
+    if(1 == uwLineLoopBackBackStatus)
+    {
+        SRE_printf("line loop back : enable\n");
+    }
+    else
+    {
+        SRE_printf("line loop back : disable\n");
+    }
+    if(1 == uwSdsBackStatus)
+    {
+        SRE_printf("sds loop back : enable\n");
+    }
+    else
+    {
+        SRE_printf("sds loop back : disable\n");
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_BcPktFiltEn, SRE_McPktFiltEn, SRE_UcNoLocalPktFiltEn,SRE_VlanPktFiltEn
+ 功能描述  : 广播，组播，非本地单播，vlan报文过滤设置
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_MacAddrFilterSet(UINT32 uwPort, const SRE_MAC_FILTER_CFG_S *pMacFilter)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pMacFilter)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input mac filter parameter NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /*设置过滤规则，非本地单播帧,非本地组播帧,流控帧和CRC错误帧丢弃*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.crc_err_pass = pMacFilter->crc_err_pass;
+    unFiltCtrl.bits.pause_frm_pass = pMacFilter->pause_frm_pass;
+    unFiltCtrl.bits.bc_drop_en = pMacFilter->bc_drop_en;
+    unFiltCtrl.bits.mc_match_en = pMacFilter->mc_match_en;
+    unFiltCtrl.bits.uc_match_en = pMacFilter->uc_match_en;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeCrcErrReportEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.crc_err_pass = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GePausePassEn
+ 功能描述  : 流控帧透传使能
+ 输入参数  : UINT32 uwPort
+             UINT32 uwEnValue
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2013年4月25日
+    作    者   : wugao
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GePausePassEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.pause_frm_pass = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_BcPktFiltEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.bc_drop_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_McPktFiltEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.mc_match_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeUcPktFiltEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+    unFiltCtrl.bits.uc_match_en = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GmacFilterStatusGet(UINT32 uwPort, SRE_MAC_FILTER_CFG_S *pMacFilter)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pMacFilter)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input mac filter pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    pMacFilter->crc_err_pass = unFiltCtrl.bits.crc_err_pass;
+    pMacFilter->pause_frm_pass = unFiltCtrl.bits.pause_frm_pass;
+    pMacFilter->bc_drop_en = unFiltCtrl.bits.bc_drop_en;
+    pMacFilter->mc_match_en = unFiltCtrl.bits.mc_match_en;
+    pMacFilter->uc_match_en = unFiltCtrl.bits.uc_match_en;
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_FilterStatusShow(UINT32 uwPort)
+{
+    SRE_GMAC_REC_FILT_CONTROL_U unFiltCtrl;
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_REC_FILT_CONTROL_REG, unFiltCtrl.u32);
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(!unFiltCtrl.bits.crc_err_pass)
+    {
+        MC_PRINTK_DFX("crc error packets   :report\n");
+    }
+    else
+    {
+        MC_PRINTK_DFX("crc error packets   :not report\n");
+    }
+
+    if(!unFiltCtrl.bits.pause_frm_pass)
+    {
+        MC_PRINTK_DFX("flow control packets:drop\n");
+    }
+    else
+    {
+        MC_PRINTK_DFX("flow control packets:pass\n");
+    }
+
+    if(!unFiltCtrl.bits.bc_drop_en)
+    {
+        MC_PRINTK_DFX("broadcast packets   :pass\n");
+    }
+    else
+    {
+        MC_PRINTK_DFX("broadcast packets   :drop\n");
+    }
+
+    if(!unFiltCtrl.bits.mc_match_en)
+    {
+        MC_PRINTK_DFX("multi cast packets       :pass\n");
+    }
+    else
+    {
+        MC_PRINTK_DFX("multi cast packets       :drop\n");
+    }
+
+    if(!unFiltCtrl.bits.uc_match_en)
+    {
+        MC_PRINTK_DFX("unicast none local packets:pass\n");
+    }
+    else
+    {
+        MC_PRINTK_DFX("unicast none local packets:drop\n");
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MacAddrAdd
+ 功能描述  : MAC地址的添加函数
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_MacAddrAdd(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwMacAddrIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacAddrLowMsk;
+    UINT32 uwMacAddrHiMsk;
+    UINT32 uwMacIndex;
+
+    /* 输入参数合法性检查 */
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrMacAddr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input mac address NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /*check if MAC address exist*/
+    for(uwMacAddrIndex = 0; uwMacAddrIndex < SRE_MAC_ADDR_NUM; uwMacAddrIndex++)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), uwMacAddrLow);
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), uwMacAddrHi);
+
+        if ( uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM )
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwMacAddrIndex), uwMacAddrLowMsk);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwMacAddrIndex), uwMacAddrHiMsk);
+            uwMacAddrLow = uwMacAddrLow & uwMacAddrLowMsk;
+            uwMacAddrHi = uwMacAddrHi & uwMacAddrHiMsk;
+        }
+
+        if((uwMacAddrLow == (pstrMacAddr->mac_addr_low & pstrMacAddr->mac_addr_low_mask))
+            && ((uwMacAddrHi & 0xffff) == ((pstrMacAddr->mac_addr_hi & pstrMacAddr->mac_addr_hi_mask) & 0xffff)))
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:MAC address already exist!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_ADDR_REPEAT, 0, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_ADDR_REPEAT, uwMacAddrIndex, 0);
+        }
+    }
+
+    /* mac address without mask */
+    if((0xffff == (pstrMacAddr->mac_addr_hi_mask & 0xffff)) && (0xffffffff == pstrMacAddr->mac_addr_low_mask))
+    {
+        /* check if there is idle mac address registers,MAC Adress reg 2 is for main mac address
+        不带掩码的MAC地址从 3 开始，2为主MAC地址,即发送流控帧的源mac地址 */
+        for(uwMacAddrIndex = 0, uwMacIndex = 3; uwMacIndex < SRE_MAC_ADDR_NUM; uwMacIndex++)
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacIndex), uwMacAddrLow);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacIndex), uwMacAddrHi);
+            if(!uwMacAddrLow && !(uwMacAddrHi & 0xffff))
+            {
+                uwMacAddrIndex = uwMacIndex;
+                break;
+            }
+        }
+
+        if(0 == uwMacAddrIndex)
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:No idle address registers! Add Mac address failed!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_ADDR_REG_FULL, 0, 0, 0, 0);
+    	    RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_ADDR_REG_FULL, 0, 0);
+        }
+    }
+    else    /* mac address with mask */
+    {
+        for(uwMacAddrIndex = 0; uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM; uwMacAddrIndex++)
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), uwMacAddrLow);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), uwMacAddrHi);
+            if(!uwMacAddrLow && !(uwMacAddrHi & 0xffff))
+            {
+                break;
+            }
+        }
+
+        if(uwMacAddrIndex >= SRE_MAC_ADDR_MSK_NUM)
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:No idle address registers! Add Mac address failed!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_ADDR_REG_FULL, 0, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_ADDR_REG_FULL, 0, 0);
+        }
+    }
+
+    if(uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM)
+    {
+        /*setting address mask*/
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwMacAddrIndex), pstrMacAddr->mac_addr_low_mask);
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwMacAddrIndex), pstrMacAddr->mac_addr_hi_mask);
+    }
+
+    /*setting MAC address*/
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), pstrMacAddr->mac_addr_low);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), pstrMacAddr->mac_addr_hi);
+
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_MacAddrDel
+ 功能描述  : MAC地址的删除函数
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_MacAddrDel(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwMacAddrIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacAddrLowMsk;
+    UINT32 uwMacAddrHiMsk;
+    UINT32 uwMacIndex;
+
+    /* 输入参数合法性检查 */
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrMacAddr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:Input mac address NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /* mac address without mask */
+    if((0xffff == (pstrMacAddr->mac_addr_hi_mask & 0xffff)) && (0xffffffff == pstrMacAddr->mac_addr_low_mask))
+    {
+        /* check if match current register value,MAC Adress reg 2 is for main mac address
+        不带掩码的MAC地址从 3 开始，2为主MAC地址 */
+        for(uwMacAddrIndex = 0, uwMacIndex = 3; uwMacIndex < SRE_MAC_ADDR_NUM; uwMacIndex++)
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacIndex), uwMacAddrLow);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacIndex), uwMacAddrHi);
+
+            if((uwMacAddrLow == pstrMacAddr->mac_addr_low) && ((uwMacAddrHi & 0xffff) == (pstrMacAddr->mac_addr_hi & 0xffff)))
+            {
+                uwMacAddrIndex = uwMacIndex;
+                break;
+            }
+        }
+
+        if(0 == uwMacAddrIndex)
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:No MAC address matched! Del Mac address failed!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_DEL, 0, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_DEL, 0, 0);
+        }
+    }
+    else    /* mac address with mask */
+    {
+        for(uwMacAddrIndex = 0; uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM; uwMacAddrIndex++)
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), uwMacAddrLow);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), uwMacAddrHi);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwMacAddrIndex), uwMacAddrLowMsk);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwMacAddrIndex), uwMacAddrHiMsk);
+
+            if(((uwMacAddrLow & uwMacAddrLowMsk)
+                == (pstrMacAddr->mac_addr_low & pstrMacAddr->mac_addr_low_mask))
+                && (((uwMacAddrHi & uwMacAddrHiMsk) & 0xffff)
+                == ((pstrMacAddr->mac_addr_hi & pstrMacAddr->mac_addr_hi_mask) & 0xffff)))
+            {
+                break;
+            }
+        }
+
+        if(uwMacAddrIndex >= SRE_MAC_ADDR_MSK_NUM)
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:No MAC address matched! Del Mac address failed!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_DEL, 0, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_DEL, 0, 0);
+        }
+    }
+
+    /*clear mac address register*/
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), 0);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), 0);
+    if(uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM)
+    {
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwMacAddrIndex), 0xffffffff);
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwMacAddrIndex), 0xffff);
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_MacAddrAdd_Ex(UINT32 uwPort,
+                                        UINT32  uwAddrLow,
+                                        UINT32  uwAddrHi,
+                                        UINT32  uwAddrMaskLow,
+                                        UINT32  uwAddrMaskHi)
+{
+    UINT32 uwRtn;
+
+    SRE_MAC_MASK_ADDR_STR_S strMacAddr;
+    strMacAddr.mac_addr_low = uwAddrLow;/**< mac地址低32bits  */
+    strMacAddr.mac_addr_hi = uwAddrHi;/**< mac地址高16bits  */
+    strMacAddr.mac_addr_low_mask = uwAddrMaskLow;/**< mac地址低32bits掩码  */
+    strMacAddr.mac_addr_hi_mask = uwAddrMaskHi;/**< mac地址高16bits掩码  */
+
+    uwRtn = SRE_MacAddrAdd(uwPort, &strMacAddr);
+
+    return uwRtn;
+}
+
+UINT32 SRE_MacAddrDel_Ex(UINT32 uwPort,
+                                        UINT32  uwAddrLow,
+                                        UINT32  uwAddrHi,
+                                        UINT32  uwAddrMaskLow,
+                                        UINT32  uwAddrMaskHi)
+{
+    UINT32 uwRtn;
+
+    SRE_MAC_MASK_ADDR_STR_S strMacAddr;
+    strMacAddr.mac_addr_low = uwAddrLow;/**< mac地址低32bits  */
+    strMacAddr.mac_addr_hi = uwAddrHi;/**< mac地址高16bits  */
+    strMacAddr.mac_addr_low_mask = uwAddrMaskLow;/**< mac地址低32bits掩码  */
+    strMacAddr.mac_addr_hi_mask = uwAddrMaskHi;/**< mac地址高16bits掩码  */
+
+    uwRtn = SRE_MacAddrDel(uwPort, &strMacAddr);
+
+    return uwRtn;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MacAddrDelWithNoMskChk
+ 功能描述  : MAC地址的删除函数，不检查掩码，
+             先检查不带掩码的MAC匹配项，若找到则删除后返回成功
+             若未找到，检查带掩码的MAC匹配项，若找到则删除后返回成功
+             若未找到，则返回失败
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_MacAddrDelWithNoMskChk(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwMacAddrIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacIndex;
+
+    /* 输入参数合法性检查 */
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrMacAddr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:Input mac address NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /* mac address without mask */
+    /* check if match current register value,MAC Adress reg 2 is for main mac address
+    不带掩码的MAC地址从 3 开始，2为主MAC地址 */
+    for(uwMacAddrIndex = 0, uwMacIndex = 3; uwMacIndex < SRE_MAC_ADDR_NUM; uwMacIndex++)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacIndex), uwMacAddrLow);
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacIndex), uwMacAddrHi);
+
+        if((uwMacAddrLow == pstrMacAddr->mac_addr_low) && ((uwMacAddrHi & 0xffff) == (pstrMacAddr->mac_addr_hi & 0xffff)))
+        {
+            uwMacAddrIndex = uwMacIndex;
+            break;
+        }
+    }
+
+    if(0 == uwMacAddrIndex)
+    {
+        /* mac address with mask */
+        for(uwMacAddrIndex = 0; uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM; uwMacAddrIndex++)
+        {
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), uwMacAddrLow);
+            SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), uwMacAddrHi);
+
+            if((uwMacAddrLow == pstrMacAddr->mac_addr_low)
+                && (((uwMacAddrHi) & 0xffff) == ((pstrMacAddr->mac_addr_hi) & 0xffff)))
+            {
+                break;
+            }
+        }
+
+        if(uwMacAddrIndex >= SRE_MAC_ADDR_MSK_NUM)
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:No MAC address matched! Del Mac address failed!"
+                "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                0xffffffff, OS_ERRNO_GMAC_MAC_DEL, 0, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_MAC_DEL, 0, 0);
+        }
+    }
+
+    /*clear mac address register*/
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_LOW_REG(uwMacAddrIndex), 0);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwMacAddrIndex), 0);
+    if(uwMacAddrIndex < SRE_MAC_ADDR_MSK_NUM)
+    {
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwMacAddrIndex), 0xffffffff);
+        SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwMacAddrIndex), 0xffff);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_MacAddrShow
+ 功能描述  : MAC地址打印接口
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_MacAddrShow(UINT32 uwPort)
+{
+    UINT32 uwRegIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacAddrMskLow;
+    UINT32 uwMacAddrMskHi;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    for(uwRegIndex = 0; uwRegIndex < SRE_MAC_ADDR_NUM; uwRegIndex++)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwRegIndex), uwMacAddrLow);
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwRegIndex), uwMacAddrHi);
+
+        if( uwMacAddrLow ||(uwMacAddrHi & 0xffff))
+        {
+            SRE_printf("MAC address %d: %04x%08x\n", uwRegIndex, (uwMacAddrHi&0xffff), uwMacAddrLow);
+            if(uwRegIndex<SRE_MAC_ADDR_MSK_NUM)
+            {
+                SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwRegIndex), uwMacAddrMskLow);
+                SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwRegIndex), uwMacAddrMskHi);
+	            SRE_printf("The mask of MAC address %d is: %04x%08x\n", uwRegIndex, (uwMacAddrMskHi&0xffff) ,  uwMacAddrMskLow);
+            }
+        }
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_MacAddrStationShow(UINT32 uwPort)
+{
+    UINT32 uwRegIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacAddrMskLow;
+    UINT32 uwMacAddrMskHi;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    for(uwRegIndex = 0; uwRegIndex < SRE_MAC_ADDR_NUM; uwRegIndex++)
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwRegIndex), uwMacAddrLow);
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwRegIndex), uwMacAddrHi);
+
+        SRE_printf("MAC address %d: %04x%08x\n", uwRegIndex, (uwMacAddrHi&0xffff), uwMacAddrLow);
+        if(uwRegIndex<SRE_MAC_ADDR_MSK_NUM)
+        {
+            SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwRegIndex), uwMacAddrMskLow);
+            SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwRegIndex), uwMacAddrMskHi);
+            SRE_printf("The mask of MAC address %d is: %04x%08x\n", uwRegIndex, (uwMacAddrMskHi&0xffff) ,  uwMacAddrMskLow);
+        }
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeSetShareUcEn(UINT32 uwPort, UINT32 uwStation, UINT32 uwMacAddrEn)
+{
+    UINT32 uwShareUcEnable;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwMacAddrEn > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_DMAC_EN_REG, uwShareUcEnable);
+    uwShareUcEnable &= ~(1<<uwStation);
+    uwShareUcEnable |= (uwMacAddrEn<<uwStation);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_DMAC_EN_REG, uwShareUcEnable);
+    SRE_printf("%s,SRE_GeSetShareUcEn port %d,station %d,en %d\n",__FUNCTION__,uwPort,uwStation,uwMacAddrEn);
+    SRE_printf("%s,uwShareUcEnable 0x%08x\n",__FUNCTION__,uwShareUcEnable);
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeGetShareUcEn(UINT32 uwPort, UINT32 uwStation, UINT32 *puwMacAddrEn)
+{
+    UINT32 uwShareUcEnable;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_DMAC_EN_REG, uwShareUcEnable);
+    *puwMacAddrEn = 0x1 & (uwShareUcEnable>>uwStation);
+
+    SRE_printf("%s,uwStation = 0x%08x\n",__FUNCTION__,uwStation);
+    SRE_printf("%s,uwShareUcEnable =0x%08x\n",__FUNCTION__,uwShareUcEnable);
+    SRE_printf("%s,*puwMacAddrEn = 0x%08x\n",__FUNCTION__,*puwMacAddrEn);
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeAddShareUcMacAddr(UINT32 uwPort, SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwRtn;
+    UINT32 uwEmptyStation;
+    UINT32 uwExistStation;
+    SRE_XGE_MAC_ADDR_S stMacAddr;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    stMacAddr.uwMacAddrHi16 = pstrMacAddr->mac_addr_hi;
+    stMacAddr.uwMacAddrLo32 = pstrMacAddr->mac_addr_low;
+
+    SRE_printf("%s,add share uc start\n",__FUNCTION__);
+    SRE_printf("%s,port:%d,addr: %04x%08x \n",__FUNCTION__,uwPort,stMacAddr.uwMacAddrHi16,stMacAddr.uwMacAddrLo32);
+
+    /* 搜索mac地址 */
+    uwRtn = SRE_XgeaSerchShareUcMacAddr(&uwExistStation, &stMacAddr);
+    if(OS_SUCCESS == uwRtn)
+    {
+        SRE_printf("%s,serch addr ok,hit station %d\n",__FUNCTION__,uwExistStation);
+        /* 本gmac对该 station 感知 */
+        uwRtn = SRE_GeSetShareUcEn(uwPort, uwExistStation, 1);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+
+        /* 使能本 station */
+        uwRtn = SRE_XgeSetUcFiltEn(uwExistStation, 1);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+    }
+    else
+    {
+        SRE_printf("%s,serch addr fail\n",__FUNCTION__);
+        /* 寻找排位，并将mac地址放入 公有 uc 池  */
+        uwRtn = SRE_XgeaAddShareUcMacAddr(&uwEmptyStation, &stMacAddr);
+        if(OS_SUCCESS != uwRtn)
+        {
+            SRE_printf("%s,add addr fail\n",__FUNCTION__);
+            return uwRtn;
+        }
+        SRE_printf("%s,add to station %d ok\n",__FUNCTION__,uwEmptyStation);
+        /* 本gmac对该 station 感知 */
+        uwRtn = SRE_GeSetShareUcEn(uwPort, uwEmptyStation, 1);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+
+        /* 使能本 station */
+        uwRtn = SRE_XgeSetUcFiltEn(uwEmptyStation, 1);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+    }
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeDelShareUcMacAddr(UINT32 uwPort, SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwRtn;
+    UINT32 uwExistStation;
+    UINT32 uwGmacPortIndex;
+    UINT32 uwMacAddrEn;
+    SRE_XGE_MAC_ADDR_S stXgeMacAddr;
+
+    stXgeMacAddr.uwMacAddrHi16 = pstrMacAddr->mac_addr_hi;
+    stXgeMacAddr.uwMacAddrLo32 = pstrMacAddr->mac_addr_low;
+
+    /* 搜索mac地址 */
+    uwRtn = SRE_XgeaSerchShareUcMacAddr(&uwExistStation, &stXgeMacAddr);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 本gmac对该 station 去感知 */
+    uwRtn = SRE_GeSetShareUcEn(uwPort, uwExistStation, 0);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+    SRE_printf("%s,port %d unlock station=%d addr=%04x%08x\n",__FUNCTION__,uwPort, uwExistStation,stXgeMacAddr.uwMacAddrHi16,stXgeMacAddr.uwMacAddrLo32);
+    /* 如果所有gmac对该 station 都已去感知则删除该station，并关闭总开关 */
+    for(uwGmacPortIndex = 0;uwGmacPortIndex < SRE_GE_MAX_BUSINESS_PORT_NUM; uwGmacPortIndex++)
+    {
+        uwRtn = SRE_GeGetShareUcEn(uwGmacPortIndex, uwExistStation, &uwMacAddrEn);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+
+        if(1 == uwMacAddrEn)
+        {
+            return OS_SUCCESS;
+        }
+    }
+
+    /*关闭该station的总开关 */
+    uwRtn = SRE_XgeSetUcFiltEn(uwExistStation, 0);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 删除该地址 */
+    uwRtn = SRE_XgeaDelShareUcMacAddr(&uwExistStation, &stXgeMacAddr);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeShowShareUcMacCfg(void)
+{
+    SRE_XGE_MAC_ADDR_S stMacAddr;
+    UINT32 uwShareUcFirstEn;
+    UINT32 uwShareUcSecndEn[SRE_GE_MAX_BUSINESS_PORT_NUM];
+    UINT32 uwStation;
+    UINT32 uwPort;
+    UINT32 uwRtn;
+
+    MC_PRINTK_DFX("station      addr   1stEn  2ndEn_0 1 2 3 4 5 6 7 8\n");
+    for(uwStation = 0;uwStation< SRE_XGE_SHARE_UC_MAC_ADDR_MAX_NUM;uwStation++)
+    {
+        uwRtn = SRE_XgeGetUcMacAddr(uwStation, &stMacAddr);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+
+        uwRtn = SRE_XgeGetUcFiltEn(uwStation, &uwShareUcFirstEn);
+        if(OS_SUCCESS != uwRtn)
+        {
+            return uwRtn;
+        }
+
+        MC_PRINTK_DFX("%02d      %04x%08x   %d         ",uwStation,
+                                        stMacAddr.uwMacAddrHi16,
+                                        stMacAddr.uwMacAddrLo32,
+                                        uwShareUcFirstEn);
+
+        for(uwPort = 0;uwPort< SRE_GE_MAX_BUSINESS_PORT_NUM;uwPort++)
+        {
+            uwRtn = SRE_GeGetShareUcEn(uwPort, uwStation, &uwShareUcSecndEn[uwPort]);
+            if(OS_SUCCESS != uwRtn)
+            {
+                return uwRtn;
+            }
+            MC_PRINTK_DFX("%d ",uwShareUcSecndEn[uwPort]);
+        }
+        MC_PRINTK_DFX("\n");
+    }
+
+    return OS_SUCCESS;
+}
+/*****************************************************************************
+ 函 数 名  : SRE_GmacMacAddrQuery
+ 功能描述  : 过滤mac地址的查询接口
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacMacAddrQuery(UINT32 uwPort, UINT32 *uwMacNum, SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    UINT32 uwRegIndex;
+    UINT32 uwMacAddrLow;
+    UINT32 uwMacAddrHi;
+    UINT32 uwMacAddrMskLow;
+    UINT32 uwMacAddrMskHi;
+    UINT32 uwValidMacAddrNum = 0;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if((NULL == pstrMacAddr) || (NULL == uwMacNum))
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]:Input mac address ptr is NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    for(uwRegIndex = 0; uwRegIndex < SRE_MAC_ADDR_NUM; uwRegIndex++)
+    {
+        /*GMAC2for main mac address*/
+        if(2 == uwRegIndex)
+        {
+            continue;
+        }
+
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_LOW_REG(uwRegIndex), uwMacAddrLow);
+        SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_HIGH_REG(uwRegIndex), uwMacAddrHi);
+
+        if( uwMacAddrLow ||(uwMacAddrHi & 0xffff))
+        {
+            pstrMacAddr[uwValidMacAddrNum].mac_addr_hi = uwMacAddrHi & 0xffff;
+            pstrMacAddr[uwValidMacAddrNum].mac_addr_low = uwMacAddrLow;
+            pstrMacAddr[uwValidMacAddrNum].mac_addr_low_mask = 0xffffffff;
+            pstrMacAddr[uwValidMacAddrNum].mac_addr_hi_mask = 0xffff;
+
+            if(uwRegIndex<SRE_MAC_ADDR_MSK_NUM)
+            {
+                SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_LOW_MSK_REG(uwRegIndex), uwMacAddrMskLow);
+                SRE_GMAC_READ_REG( uwPort, SRE_MAC_ADDR_HI_MSK_REG(uwRegIndex), uwMacAddrMskHi);
+                pstrMacAddr[uwValidMacAddrNum].mac_addr_low_mask = uwMacAddrMskLow;
+                pstrMacAddr[uwValidMacAddrNum].mac_addr_hi_mask = uwMacAddrMskHi & 0xffff;
+            }
+            uwValidMacAddrNum++;
+        }
+    }
+
+    *uwMacNum = uwValidMacAddrNum;
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacMainMacAddrSet
+ 功能描述  : GMAC 主MAC地址设置函数
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月16日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacMainMacAddrSet(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrMacAddr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Input mac address NULL!!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_MSK_LOW_REG(2), pstrMacAddr->mac_addr_low);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_MSK_HIGH_REG(2), pstrMacAddr->mac_addr_hi);
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacMainMacAddrClr
+ 功能描述  : GMAC 主MAC地址清除函数
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月16日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacMainMacAddrClr(UINT32 uwPort)
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_MSK_LOW_REG(2), 0);
+    SRE_GMAC_WRITE_REG(uwPort, SRE_MAC_SA_MSK_HIGH_REG(2), 0);
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacMainMacAddrQuery
+ 功能描述  : 主MAC地址的查询接口
+ 输入参数  : UINT32 uwPort
+             const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月25日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacMainMacAddrQuery(UINT32 uwPort, SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr)
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrMacAddr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Input mac address NULL!!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_MSK_LOW_REG(2), pstrMacAddr->mac_addr_low);
+    SRE_GMAC_READ_REG(uwPort, SRE_MAC_SA_MSK_HIGH_REG(2), pstrMacAddr->mac_addr_hi);
+    pstrMacAddr->mac_addr_low_mask = 0xffffffff;
+    pstrMacAddr->mac_addr_hi_mask = 0xffff;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_PktModeSet, SRE_PktModeGet
+ 功能描述  : 报文的输入模式及解析模式设置和查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_PktModeSet(UINT32 uwPort, const SRE_RX_PKT_MODE_CFG_S *pstrRxPktMode)
+{
+    SRE_GMAC_MAC_SKIP_LEN_U unSkipLen;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrRxPktMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Packet mode parameter NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /*报文头不解析字段长度,不解析字段做CRC*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLen.u32);
+    unSkipLen.bits.mac_skip_len = pstrRxPktMode->mac_skip_len;
+    unSkipLen.bits.mac_skip_crc = pstrRxPktMode->mac_skip_crc;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLen.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PktModeGet(UINT32 uwPort, SRE_RX_PKT_MODE_CFG_S *pstrRxPktMode)
+{
+    SRE_GMAC_MAC_SKIP_LEN_U unSkipLen;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrRxPktMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Packet mode pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLen.u32);
+    pstrRxPktMode->mac_skip_len = unSkipLen.bits.mac_skip_len ;
+    pstrRxPktMode->mac_skip_len = unSkipLen.bits.mac_skip_crc ;
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_InputModeSet
+ 功能描述  : 报文的输入模式设置函数
+ 输入参数  : UINT32 uwPort
+             UINT32 uwInMode     0: 非指令头模式  1: 指令头模式
+             UINT32 uwPsMode     0: 不解析1:从2层开始解析2:从 3层开始解析
+             UINT32 uwPktSkip     报文头不解析的长度
+             UINT32 uwMacSkip   报文头到MAC的长度
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年5月19日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_InputModeSet(UINT32 uwPort, UINT32 uwMacSkip, UINT32 uwSkipCrc)
+{
+    SRE_GMAC_MAC_SKIP_LEN_U unSkipLen;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /*报文头不解析字段长度,不解析字段做CRC*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLen.u32);
+    unSkipLen.bits.mac_skip_len = uwMacSkip;
+    unSkipLen.bits.mac_skip_crc = uwSkipCrc;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MAC_SKIP_LEN_REG, unSkipLen.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SetGpio
+ 功能描述  : 设置和网口相关的两个GPIO管脚方向
+ 输入参数  : VOID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月4日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+VOID SRE_SetGpio(VOID)
+{
+    UINT32 uwReadReg;
+
+    /*set gpio output*/
+    uwReadReg = OS_READ_REG(MC_GPIO0_SWPORT_DR_REG, 0);
+    uwReadReg |= 0x00080000;
+    OS_WRITE_REG(MC_GPIO0_SWPORT_DR_REG, 0, uwReadReg);
+
+    uwReadReg = OS_READ_REG(MC_GPIO0_SWPORT_DDR_REG, 0);
+    uwReadReg |= 0x00080000;
+    OS_WRITE_REG(MC_GPIO0_SWPORT_DDR_REG, 0, uwReadReg);
+
+    //SRE_DelayUs(1000);
+    SRE_PhyDelayUs(1000);
+}
+/*****************************************************************************
+ 函 数 名  : SRE_PortModeSet, SRE_PortModeGet
+ 功能描述  : 端口模式相关参数的设置及查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+*****************************************************************************/
+UINT32 SRE_PortModeSet(UINT32 uwPort, const SRE_PORT_MODE_CFG_S *pstrPortMode)
+{
+    SRE_GMAC_MAX_FRM_SIZE_U unMaxFrmSize;
+    SRE_GMAC_SHORT_RUNTS_THR_U unShortFrmThr;
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+    SRE_GMAC_PORT_MODE_U unPortMode;
+    SRE_GMAC_MODE_CHANGE_EN_U unModeChangeEn;
+    UINT32 uwRtn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrPortMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Port mode parameter NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+
+    /*设置端口模式*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    unPortMode.bits.port_mode = pstrPortMode->port_mode;
+    if((pstrPortMode->port_mode >= GMAC_10M_RGMII) && (pstrPortMode->port_mode <= GMAC_1000M_RGMII))
+    {
+        /* BEGIN: Added by c00111586, 2010/10/22   问题单号:DTS2010101600721 */
+        unPortMode.bits.rgmii_1000m_delay = 1;
+        /* END:   Added by c00111586, 2010/10/22 */
+    }
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+    unModeChangeEn.bits.mode_change_en = 1;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+
+
+    /*设置最大帧长*/
+    unMaxFrmSize.u32 = 0;
+    unMaxFrmSize.bits.max_frm_size = pstrPortMode->max_frm_size;
+
+    /*短帧／超短帧界限*/
+    unShortFrmThr.u32 = 0;
+    unShortFrmThr.bits.short_runts_thr = pstrPortMode->short_runts_thr;
+
+    /*设置最大帧长*/
+    uwRtn = SRE_MaxFrmSizeSet(uwPort, unMaxFrmSize.u32);
+    if(uwRtn != OS_SUCCESS)
+    {
+        return uwRtn;
+    }
+
+    /*短帧／超短帧界限*/
+    uwRtn = SRE_ShortFrmSizeSet(uwPort, unShortFrmThr.u32);
+    if(uwRtn != OS_SUCCESS)
+    {
+        return uwRtn;
+    }
+
+    /* BEGIN: Modified by c00111586, 2011/7/28   问题单号:DTS2011072603695  */
+    /* 配置SGMII自协商本地配置寄存器TX_LOCAL_PAGE（基地址0x30000000+-
+       1000*ch_num，偏移地址为0x005C）为32’h1。 */
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, 0x1UL);
+
+    /* 自协商link时间，推荐值为 0x3f */
+    uwRtn = SRE_UpdateAnLinkTime(uwPort, 0x3fUL);
+    if(uwRtn != OS_SUCCESS)
+    {
+        return uwRtn;
+    }
+    /* END:   Modified by c00111586, 2011/7/28 */
+
+    /*发送添加pad/FCS/自协商使能*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    unTxCtrl.bits.pad_enable = 1;
+    unTxCtrl.bits.crc_add = 1;
+    unTxCtrl.bits.an_enable = 1;
+
+    /*发送添加pad/FCS/自协商使能*/
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+
+    /*超短帧透传／接收PAD剥离使能*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+
+    /* 短帧透传功能需要禁止 */
+    unRecvCtrl.bits.runt_pkt_en = 0;
+    unRecvCtrl.bits.strip_pad_en = 1;
+
+    /*超短帧透传／接收PAD剥离使能*/
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PortModeGet(UINT32 uwPort, SRE_PORT_MODE_CFG_S *pstrPortMode)
+{
+    SRE_GMAC_MAX_FRM_SIZE_U unMaxFrmSize;
+    SRE_GMAC_SHORT_RUNTS_THR_U unShortFrmThr;
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+    SRE_GMAC_RECV_CONTROL_U unRecvCtrl;
+    SRE_GMAC_PORT_MODE_U unPortMode;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == pstrPortMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Port mode pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    pstrPortMode->port_mode = (SRE_PORT_MODE_E)unPortMode.bits.port_mode;
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MAX_FRM_SIZE_REG, unMaxFrmSize.u32);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_SHORT_RUNTS_THR_REG, unShortFrmThr.u32);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RECV_CONTROL_REG, unRecvCtrl.u32);
+
+    pstrPortMode->max_frm_size = unMaxFrmSize.bits.max_frm_size;
+    pstrPortMode->short_runts_thr = unShortFrmThr.bits.short_runts_thr;
+
+    pstrPortMode->pad_enable = unTxCtrl.bits.pad_enable;
+    pstrPortMode->crc_add = unTxCtrl.bits.crc_add;
+    pstrPortMode->an_enable = unTxCtrl.bits.an_enable;
+
+    pstrPortMode->runt_pkt_en = unRecvCtrl.bits.runt_pkt_en;
+    pstrPortMode->strip_pad_en = unRecvCtrl.bits.strip_pad_en;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacCrcStripEn
+ 功能描述  : GMAC接收剥离CRC使能函数
+ 输入参数  : UINT32 uwPort
+             UINT32 uwEnValue
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年5月17日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacCrcStripEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_CF_CRC_STRIP_U unCrcStrip;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_CF_CRC_STRIP_REG, unCrcStrip.u32);
+    unCrcStrip.bits.cf_crc_strip = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_CF_CRC_STRIP_REG, unCrcStrip.u32);
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacCrcAddEn
+ 功能描述  : GMAC发送添加CRC使能函数
+ 输入参数  : UINT32 uwPort
+             UINT32 uwEnValue
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年5月17日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacCrcAddEn(UINT32 uwPort, UINT32 uwEnValue)
+{
+    SRE_GMAC_TRANSMIT_CONTROL_U unTxCtrl;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwEnValue > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+    unTxCtrl.bits.crc_add = uwEnValue;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, unTxCtrl.u32);
+
+    return OS_SUCCESS;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacStatisticsShow
+ 功能描述  : GMAC端口各计数器查询
+ 输入参数  : 端口号
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+*****************************************************************************/
+UINT32 SRE_GmacStatisticsShow(UINT32 uwPort)
+{
+    UINT32 uwrx_octets_total_ok_cnt;
+    UINT32 uwrx_octets_bad_cnt;
+    UINT32 uwrx_uc_pkts_cnt;
+    UINT32 uwrx_mc_pkts_cnt;
+    UINT32 uwrx_bc_pkts_cnt;
+    UINT32 uwrx_vlan_pkt_cnt;
+    UINT32 uwrx_fw_ctrl_frame_cnt;
+    UINT32 uwrx_octets_total_filt_cnt;
+    UINT32 uwrx_filt_pkt_cnt;
+
+    UINT32 uwrx_framsize_64;
+    UINT32 uwrx_framsize_65_127;
+    UINT32 uwrx_framsize_128_255;
+    UINT32 uwrx_framsize_256_511;
+    UINT32 uwrx_framsize_512_1023;
+    UINT32 uwrx_framsize_1024_1518;
+    UINT32 uwrx_framsize_bt_1518;
+
+
+    UINT32 uwrx_fcs_error_cnt;
+    UINT32 uwrx_data_error_cnt;
+    UINT32 uwrx_align_error_cnt;
+    UINT32 uwrx_frame_long_err_cnt;
+    UINT32 uwrx_frame_very_long_err_cnt;
+    UINT32 uwrx_frame_runt_err_cnt;
+    UINT32 uwrx_frame_short_err_cnt;
+    UINT32 uwrx_overrun_cnt;
+
+
+    UINT32 uwtx_octets_total_ok_cnt;
+    UINT32 uwtx_octets_bad_cnt;
+    UINT32 uwtx_uc_pkts_cnt;
+    UINT32 uwtx_mc_pkts_cnt;
+    UINT32 uwtx_bc_pkts_cnt;
+    UINT32 uwtx_vlan_pkt_cnt;
+    UINT32 uwtx_fw_ctrl_frame_cnt;
+
+    UINT32 uwtx_framsize_64;
+    UINT32 uwtx_framsize_65_127;
+    UINT32 uwtx_framsize_128_255;
+    UINT32 uwtx_framsize_256_511;
+    UINT32 uwtx_framsize_512_1023;
+    UINT32 uwtx_framsize_1024_1518;
+    UINT32 uwtx_framsize_bt_1518;
+
+    UINT32 uwtx_fcs_error_cnt;
+    UINT32 uwtx_underrun_err_cnt;
+
+
+    UINT32 uwtx_excessive_drop_cnt;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /*RX COUNT*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_UC_PKTS_REG, uwrx_uc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_MC_PKTS_REG, uwrx_mc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_BC_PKTS_REG, uwrx_bc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_TAGGED_REG, uwrx_vlan_pkt_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PAUSE_MACCONTROL_FRAMCOUNTER_REG, uwrx_fw_ctrl_frame_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_OCTETS_TOTAL_OK_REG, uwrx_octets_total_ok_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_OCTETS_BAD_REG, uwrx_octets_bad_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_OCTETS_TOTAL_FILT_REG, uwrx_octets_total_filt_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_FILT_PKT_CNT_REG, uwrx_filt_pkt_cnt);
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_64OCTETS_REG, uwrx_framsize_64);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_65TO127OCTETS_REG, uwrx_framsize_65_127);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_128TO255OCTETS_REG, uwrx_framsize_128_255);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_255TO511OCTETS_REG, uwrx_framsize_256_511);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_512TO1023OCTETS_REG, uwrx_framsize_512_1023);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_1024TO1518OCTETS_REG, uwrx_framsize_1024_1518);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_PKTS_1519TOMAXOCTETS_REG, uwrx_framsize_bt_1518);
+
+    /*RX ERROR COUNT*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_LONG_ERRORS_REG, uwrx_frame_long_err_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_VERY_LONG_ERR_CNT_REG, uwrx_frame_very_long_err_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_RUNT_ERR_CNT_REG, uwrx_frame_runt_err_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_SHORT_ERR_CNT_REG, uwrx_frame_short_err_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_OVERRUN_CNT_REG, uwrx_overrun_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_FCS_ERRORS_REG, uwrx_fcs_error_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_DATA_ERR_REG, uwrx_data_error_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_RX_ALIGN_ERRORS_REG, uwrx_align_error_cnt);
+
+    /*TX COUNT*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_UC_PKTS_REG, uwtx_uc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_MC_PKTS_REG, uwtx_mc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_BC_PKTS_REG, uwtx_bc_pkts_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_TAGGED_REG, uwtx_vlan_pkt_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PAUSE_FRAMES_REG, uwtx_fw_ctrl_frame_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_OCTETS_TRANSMITTED_OK_REG, uwtx_octets_total_ok_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_OCTETS_TRANSMITTED_BAD_REG, uwtx_octets_bad_cnt);
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_64OCTETS_REG, uwtx_framsize_64);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_65TO127OCTETS_REG, uwtx_framsize_65_127);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_128TO255OCTETS_REG, uwtx_framsize_128_255);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_255TO511OCTETS_REG, uwtx_framsize_256_511);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_512TO1023OCTETS_REG, uwtx_framsize_512_1023);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_1024TO1518OCTETS_REG, uwtx_framsize_1024_1518);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_PKTS_1519TOMAXOCTETS_REG, uwtx_framsize_bt_1518);
+
+    /*TX ERROR COUNT*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_CRC_ERROR_REG, uwtx_fcs_error_cnt);
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_UNDERRUN_REG, uwtx_underrun_err_cnt);
+
+    /*RX DROP COUNT*/
+
+    /*TX DROP COUNT*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_EXCESSIVE_LENGTH_DROP_REG, uwtx_excessive_drop_cnt);
+
+    MC_PRINTK_DFX("\n****************************RX COUNTERS****************************\n");
+
+    if(uwrx_uc_pkts_cnt)
+    {
+        MC_PRINTK_DFX("Received unicast packets counter: %u\n", uwrx_uc_pkts_cnt);
+    }
+    if(uwrx_mc_pkts_cnt)
+    {
+	MC_PRINTK_DFX("Received multicast packets counter: %u\n", uwrx_mc_pkts_cnt);
+    }
+    if(uwrx_bc_pkts_cnt)
+    {
+	MC_PRINTK_DFX("Received broadcast packets counter: %u\n", uwrx_bc_pkts_cnt);
+    }
+    if(uwrx_vlan_pkt_cnt)
+    {
+        MC_PRINTK_DFX("Received vlan packets counter: %u\n", uwrx_vlan_pkt_cnt);
+    }
+    if(uwrx_octets_total_ok_cnt)
+    {
+        MC_PRINTK_DFX("Received paket bytes: %u\n", uwrx_octets_total_ok_cnt);
+    }
+    if(uwrx_octets_total_filt_cnt)
+    {
+        MC_PRINTK_DFX("Received filt total bytes: %u\n", uwrx_octets_total_filt_cnt);
+    }
+    if(uwrx_filt_pkt_cnt)
+    {
+        MC_PRINTK_DFX("Received filt packets: %u\n", uwrx_filt_pkt_cnt);
+    }
+    if(uwrx_fw_ctrl_frame_cnt)
+    {
+        MC_PRINTK_DFX("Received flow control frames counter: %u\n", uwrx_fw_ctrl_frame_cnt);
+    }
+    if(uwrx_framsize_64)
+    {
+        MC_PRINTK_DFX("Received  frames size 64 bytes counter: %u\n", uwrx_framsize_64);
+    }
+    if(uwrx_framsize_65_127)
+    {
+        MC_PRINTK_DFX("Received  frames size 65-127 bytes counter: %u\n", uwrx_framsize_65_127);
+    }
+    if(uwrx_framsize_128_255)
+    {
+        MC_PRINTK_DFX("Received  frames size 128-255 bytes counter: %u\n", uwrx_framsize_128_255);
+    }
+    if(uwrx_framsize_256_511)
+    {
+        MC_PRINTK_DFX("Received  frames size 256-511 bytes counter: %u\n", uwrx_framsize_256_511);
+    }
+    if(uwrx_framsize_512_1023)
+    {
+        MC_PRINTK_DFX("Received  frames size 511-1023 bytes counter: %u\n", uwrx_framsize_512_1023);
+    }
+    if(uwrx_framsize_1024_1518)
+    {
+        MC_PRINTK_DFX("Received  frames size 1024-1518 bytes counter: %u\n", uwrx_framsize_1024_1518);
+    }
+    if(uwrx_framsize_bt_1518)
+    {
+        MC_PRINTK_DFX("Received  frames size bigger than 1518 bytes counter: %u\n", uwrx_framsize_bt_1518);
+    }
+
+    MC_PRINTK_DFX("\n****************************RX ERROR COUNTERS****************************\n");
+
+    if(uwrx_octets_bad_cnt)
+    {
+        MC_PRINTK_DFX("Received error pakets bytes counter: %u\n", uwrx_octets_bad_cnt);
+    }
+
+    if(uwrx_frame_long_err_cnt)
+    {
+        MC_PRINTK_DFX("Received long frames counter: %u\n", uwrx_frame_long_err_cnt);
+    }
+    if(uwrx_frame_long_err_cnt || uwrx_frame_very_long_err_cnt)
+    {
+        MC_PRINTK_DFX("Received super long frames counter: %u\n", uwrx_frame_very_long_err_cnt);
+    }
+    if(uwrx_frame_runt_err_cnt || uwrx_frame_short_err_cnt)
+    {
+        MC_PRINTK_DFX("Received super short frames counter: %u\n", uwrx_frame_short_err_cnt);
+    }
+
+    if(uwrx_frame_runt_err_cnt)
+    {
+        MC_PRINTK_DFX("Received short frames counter: %u\n", uwrx_frame_runt_err_cnt);
+    }
+
+    if(uwrx_overrun_cnt)
+    {
+        MC_PRINTK_DFX("Received fifo overrun counter: %u\n", uwrx_overrun_cnt);
+    }
+    if(uwrx_fcs_error_cnt)
+    {
+        MC_PRINTK_DFX("Received packet crc error counter: %u\n", uwrx_fcs_error_cnt);
+    }
+    if(uwrx_data_error_cnt)
+    {
+        MC_PRINTK_DFX("Received packet data error counter: %u\n", uwrx_data_error_cnt);
+    }
+    if(uwrx_align_error_cnt)
+    {
+        MC_PRINTK_DFX("Received frame align error counter: %u\n", uwrx_align_error_cnt);
+    }
+
+    MC_PRINTK_DFX("\n****************************TX COUNTERS****************************\n");
+
+    if(uwtx_uc_pkts_cnt)
+    {
+        MC_PRINTK_DFX("Transmited unicast packets counter: %u\n", uwtx_uc_pkts_cnt);
+    }
+    if(uwtx_mc_pkts_cnt)
+    {
+        MC_PRINTK_DFX("Transmited multicast packets counter: %u\n", uwtx_mc_pkts_cnt);
+    }
+    if(uwtx_bc_pkts_cnt)
+    {
+        MC_PRINTK_DFX("Transmited broadcast packets counter: %u\n", uwtx_bc_pkts_cnt);
+    }
+    if(uwtx_vlan_pkt_cnt)
+    {
+        MC_PRINTK_DFX("Transmited vlan packets counter: %u\n", uwtx_vlan_pkt_cnt);
+    }
+    if(uwtx_octets_total_ok_cnt)
+    {
+        MC_PRINTK_DFX("Transmited packet bytes counter: %u\n", uwtx_octets_total_ok_cnt);
+    }
+    if(uwtx_fw_ctrl_frame_cnt)
+    {
+        MC_PRINTK_DFX("Transmited flow control frames counter: %u\n", uwtx_fw_ctrl_frame_cnt);
+    }
+    if(uwtx_framsize_64)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 64 bytes counter: %u\n", uwtx_framsize_64);
+    }
+    if(uwtx_framsize_65_127)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 65-127 bytes counter: %u\n", uwtx_framsize_65_127);
+    }
+    if(uwtx_framsize_128_255)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 128-255 bytes counter: %u\n", uwtx_framsize_128_255);
+    }
+    if(uwtx_framsize_256_511)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 256-511 bytes counter: %u\n", uwtx_framsize_256_511);
+    }
+    if(uwtx_framsize_512_1023)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 511-1023 bytes counter: %u\n", uwtx_framsize_512_1023);
+    }
+    if(uwtx_framsize_1024_1518)
+    {
+        MC_PRINTK_DFX("Transmited  frames size 1024-1518 bytes counter: %u\n", uwtx_framsize_1024_1518);
+    }
+    if(uwtx_framsize_bt_1518)
+    {
+        MC_PRINTK_DFX("Transmited  frames size bigger than 1518 bytes counter: %u\n", uwtx_framsize_bt_1518);
+    }
+
+    MC_PRINTK_DFX("\n****************************TX ERROR COUNTERS****************************\n");
+
+    if(uwtx_octets_bad_cnt)
+    {
+        MC_PRINTK_DFX("Transmited bad packets bytes counter: %u\n", uwtx_octets_bad_cnt);
+    }
+    if(uwtx_underrun_err_cnt)
+    {
+        MC_PRINTK_DFX("Transmited failed counter: %u\n", uwtx_underrun_err_cnt);
+    }
+    if(uwtx_fcs_error_cnt)
+    {
+        MC_PRINTK_DFX("Transmited packet crc error counter: %u\n", uwtx_fcs_error_cnt);
+    }
+
+    MC_PRINTK_DFX("\n****************************RX DROP COUNTERS****************************\n");
+
+
+    MC_PRINTK_DFX("\n****************************TX DROP COUNTERS****************************\n");
+
+    if(uwtx_excessive_drop_cnt)
+    {
+        MC_PRINTK_DFX("Transmited excessive length frame failed drop counter: %u\n", uwtx_excessive_drop_cnt);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacPauseFrmCfg
+ 功能描述  : 响应流控帧配置接口
+ 输入参数  : UINT32 uwPort
+             UINT32 uwRxPauseEn
+             UINT32 uwTxPauseEn
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年3月18日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacPauseFrmCfg(UINT32 uwPort, UINT32 uwRxPauseEn, UINT32 uwTxPauseEn)
+{
+    SRE_GMAC_PAUSE_EN_U unPauseEn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwRxPauseEn > 1 || uwTxPauseEn > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PAUSE_EN_REG, unPauseEn.u32);
+    unPauseEn.bits.rx_fdfc = uwRxPauseEn;
+    unPauseEn.bits.tx_fdfc = uwTxPauseEn;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PAUSE_EN_REG, unPauseEn.u32);
+
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetGmacPauseFrmCfg
+ 功能描述  : 获取pause帧配置信息
+ 输入参数  : UINT32 uwPort
+             UINT32 *puwRxPauseEn
+             UINT32 *puwTxPauseEn
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetGmacPauseFrmCfg(UINT32 uwPort, UINT32 *puwRxPauseEn, UINT32 *puwTxPauseEn)
+{
+    SRE_GMAC_PAUSE_EN_U unPauseEn;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if((NULL == puwRxPauseEn) || (NULL == puwTxPauseEn))
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PAUSE_EN_REG, unPauseEn.u32);
+    *puwRxPauseEn = unPauseEn.bits.rx_fdfc;
+    *puwTxPauseEn = unPauseEn.bits.tx_fdfc;
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GmacPauseCfgShow(UINT32 uwPort)
+{
+    UINT32 uwRxPauseEn;
+    UINT32 uwTxPauseEn;
+
+    SRE_GetGmacPauseFrmCfg(uwPort, &uwRxPauseEn, &uwTxPauseEn);
+    if(1 == uwRxPauseEn)
+    {
+        SRE_printf("rx pause : enable\n");
+    }
+    else
+    {
+        SRE_printf("rx pause : disable\n");
+    }
+    if(1 == uwTxPauseEn)
+    {
+        SRE_printf("tx pause : enable\n");
+    }
+    else
+    {
+        SRE_printf("tx pause : disable\n");
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SerdesBist
+ 功能描述  : Serdes BIST自检函数
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年8月16日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SerdesBist(UINT32 uwPort)
+{
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacRst
+ 功能描述  : GMAC复位
+ 输入参数  : UINT32 uwGmacId
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月5日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GmacRst(UINT32 uwGmacId)
+{
+    (void)uwGmacId;
+#if 0
+    SRE_PERCTRL6_U strPerCtrl6;
+    SRE_PERCTRL7_U strPerCtrl7;
+    SRE_PERCTRL6_U strPerCtrl6_1;
+    SRE_PERCTRL7_U strPerCtrl7_1;
+    SRE_PERCTRL6_U strPerCtrl6_2;
+    SRE_PERCTRL7_U strPerCtrl7_2;
+    SRE_PERCTRL6_U strPerCtrl6Rst;
+    SRE_PERCTRL7_U strPerCtrl7Rst;
+    /*SRE_GMAC_RX_CTRL_U unRxCtrl;*/
+    /*SRE_GMAC_CF_CFF_DATA_NUM_U unCffNum;*/
+    /*SRE_GMAC_FIFO_CURR_STATUS_U unFifoStatus;*/
+   /* SRE_GMAC_DEBUG_ST_MCH_U unStMch;*/
+    SRE_PERCTRL69_U unMacRstReq;
+
+    SRE_GeEnableTx(uwGmacId, 1);
+    SRE_GeEnableRx(uwGmacId, 0);
+
+#if 0 /*后期需要对这一块进行修改20111117  wuqian */
+    /* 禁止向BMU申请buffer */
+    SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_RX_CTRL_REG, unRxCtrl.u32);
+    unRxCtrl.bits.cf_rx_cfg_req_en = 0;
+    SRE_GMAC_WRITE_REG(uwGmacId, SRE_GMAC_RX_CTRL_REG, unRxCtrl.u32);
+
+step4 :
+    do
+    {
+        SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_CF_CFF_DATA_NUM_REG, unCffNum.u32);
+        if ( 0 != unCffNum.bits.cf_tx_cfg_num )
+        {
+            if ( uwCfgNum == unCffNum.bits.cf_tx_cfg_num )
+            {
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwCfgNum = unCffNum.bits.cf_tx_cfg_num ;
+            SRE_DelayMs(10);
+        }
+
+    } while ( 0 != unCffNum.bits.cf_tx_cfg_num );
+
+
+    SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_FIFO_CURR_STATUS_REG, unFifoStatus.u32);
+    if ( 1 == unFifoStatus.bits.rff_cf_empty )
+    {
+        /* 步骤5 */
+        SRE_DelayMs(10);
+        SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_DEBUG_ST_MCH_REG, unStMch.u32);
+        if ( (0 != unStMch.bits.tx_st_mch) || (0 != unStMch.bits.rx_st_mch))
+        {
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+    else if ( ( 0 == unFifoStatus.bits.rff_cf_empty ) && ( 1 == unFifoStatus.bits.cff_cf_rx_empty ) )
+    {
+        /* 步骤6 */
+        SRE_DelayMs(10);
+        SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_DEBUG_ST_MCH_REG, unStMch.u32);
+        if ( (0 != (unStMch.u32 & 0x1ff)) && (0x20 != (unStMch.u32 & 0x1ff)))
+        {
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+    else /* ( ( 0 == unFifoStatus.bits.rff_cf_empty ) && ( 0 == unFifoStatus.bits.cff_cf_rx_empty ) )  */
+    {
+        /* 步骤7 */
+        uwCfgNum = 0;
+        do
+        {
+            SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_CF_CFF_DATA_NUM_REG, unCffNum.u32);
+            if ( 0 == unCffNum.bits.cf_rx_cfg_num )
+            {
+                goto step4;
+            }
+            else
+            {
+                SRE_DelayMs(10);
+                if ( uwCfgNum == unCffNum.bits.cf_rx_cfg_num )
+                {
+                    SRE_GMAC_READ_REG(uwGmacId, SRE_GMAC_FIFO_CURR_STATUS_REG, unFifoStatus.u32);
+                    if ( 1 == unFifoStatus.bits.rff_cf_empty)
+                    {
+                        uwCfgNum = 0;
+                        goto step4;
+                    }
+                    else
+                    {
+                        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+                    }
+                }
+                uwCfgNum = unCffNum.bits.cf_rx_cfg_num ;
+            }
+        } while ( 0 != unCffNum.bits.cf_rx_cfg_num );
+
+    }
+#endif
+
+    /* 根据复位请求设置寄存器内容 */
+    /* rx软复位请求 */
+    /* tx软复位请求 */
+    /* rx125m软复位请求 */
+    /* eth软复位请求 */
+    /* sys软复位请求 */
+
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwGmacId )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac0_sys_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac1_sys_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac2_sys_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac3_sys_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl6.bits.gmac4_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac4_sys_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl6.bits.gmac5_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac5_sys_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl6.bits.gmac6_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac6_sys_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl6.bits.gmac7_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac7_sys_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwGmacId(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwGmacId, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    strPerCtrl6_1.u32 = strPerCtrl6.u32;
+    strPerCtrl7_1.u32 = strPerCtrl7.u32;
+
+    /* 步骤 10	配置MAC_CORE的配置寄存器软复位寄存器为1 */
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 |= (1 << (19 - uwGmacId));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwGmacId )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac0_tx_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac1_tx_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac2_tx_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac3_tx_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl7.bits.gmac4_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac4_tx_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl7.bits.gmac5_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac5_tx_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl7.bits.gmac6_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac6_tx_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl7.bits.gmac7_rx_srst_req = 1;
+            strPerCtrl7.bits.gmac7_tx_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwGmacId(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwGmacId, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    strPerCtrl6_2.u32 = strPerCtrl6.u32;
+    strPerCtrl7_2.u32 = strPerCtrl7.u32;
+
+    if ( 0 == uwGmacId )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwGmacId )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_1.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_1.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 &= ~(1UL << (19 - uwGmacId));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_2.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_2.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    if ( 0 == uwGmacId )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwGmacId )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    SRE_DelayMs(10);
+#endif
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SetDuplexType
+ 功能描述  : 设置双工类型
+ 输入参数  : UINT32 uwPort
+             SRE_DUPLEX_TYPE_E uwDuplexType
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SetDuplexType(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType)
+{
+    SRE_MAC_DUPLEX_TYPE_U unDuplexType;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /*lint -e685  */
+    if ( enDuplexType > SRE_FULL_DUPLEX_MODE )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] DuplexType exceeds the maximum number!"
+            "\nenDuplexType = %d,[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            OS_ERRNO_GMAC_DUPLEX_TYPE, enDuplexType, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_DUPLEX_TYPE, 0, 0);
+    }
+    /*lint +e685  */
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_DUPLEX_TYPE_REG, unDuplexType.u32);
+    unDuplexType.bits.duplex_type = enDuplexType;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_DUPLEX_TYPE_REG, unDuplexType.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetDuplexType
+ 功能描述  : 获取双工类型
+ 输入参数  : UINT32 uwPort
+             SRE_DUPLEX_TYPE_E *puwDuplexType
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetDuplexType(UINT32 uwPort, SRE_DUPLEX_TYPE_E *penDuplexType)
+{
+    SRE_MAC_DUPLEX_TYPE_U unDuplexType;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == penDuplexType)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_DUPLEX_TYPE_REG, unDuplexType.u32);
+    *penDuplexType = (SRE_DUPLEX_TYPE_E)unDuplexType.bits.duplex_type;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SetPortMode
+ 功能描述  : 设置端口模式
+ 输入参数  : UINT32 uwPort
+             SRE_PORT_MODE_E enPortMode
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SetPortMode(UINT32 uwPort, SRE_PORT_MODE_E enPortMode)
+{
+    SRE_GMAC_PORT_MODE_U unPortMode;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if ( enPortMode > GMAC_1000M_SGMII )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] PortMode exceeds the maximum number!"
+            "\nenPortMode = %d,[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            OS_ERRNO_GMAC_PORT_MODE, enPortMode, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_MODE, 0, 0);
+    }
+
+    /*设置端口模式*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    unPortMode.bits.port_mode = enPortMode;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetPortMode
+ 功能描述  : 获取端口模式
+ 输入参数  : UINT32 uwPort
+             SRE_PORT_MODE_E *penPortMode
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetPortMode(UINT32 uwPort, SRE_PORT_MODE_E *penPortMode)
+{
+    SRE_GMAC_PORT_MODE_U unPortMode;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == penPortMode)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    /*设置端口模式*/
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    *penPortMode = (SRE_PORT_MODE_E)unPortMode.bits.port_mode;
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeSetPortCfg(MCSS_CMD_GMAC_SET_PORT_ST *pstCmdGmacSetPort)
+{
+    UINT32 uwRtn;
+
+    if(pstCmdGmacSetPort->port >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /* 双工模式 */
+
+    uwRtn = SRE_SetDuplexType(pstCmdGmacSetPort->port, (SRE_DUPLEX_TYPE_E)pstCmdGmacSetPort->duplex_type);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 速率 */
+    uwRtn = SRE_SetPortMode(pstCmdGmacSetPort->port, (SRE_PORT_MODE_E)pstCmdGmacSetPort->speed);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 自协商使能 */
+    uwRtn = SRE_AnModeSet(pstCmdGmacSetPort->port, pstCmdGmacSetPort->autoneg_en);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 自协商模式 */
+    uwRtn = SRE_AnTypeSet(pstCmdGmacSetPort->port, (MCSS_AUTONEG_MODE_E *)&pstCmdGmacSetPort->autoneg_mode);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeGetPortCfg(MCSS_CMD_GMAC_SET_PORT_ST *pstCmdGmacSetPort)
+{
+    UINT32 uwRtn;
+
+    if(pstCmdGmacSetPort->port >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /* 双工模式 */
+
+    uwRtn = SRE_GetDuplexType(pstCmdGmacSetPort->port, (SRE_DUPLEX_TYPE_E *)&pstCmdGmacSetPort->duplex_type);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 速率 */
+    uwRtn = SRE_GetPortMode(pstCmdGmacSetPort->port, (SRE_PORT_MODE_E *)&pstCmdGmacSetPort->speed);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 自协商使能 */
+    uwRtn = SRE_AnModeGet(pstCmdGmacSetPort->port, (UINT32 *)&pstCmdGmacSetPort->autoneg_en);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    /* 自协商模式 */
+    uwRtn = SRE_AnTypeGet(pstCmdGmacSetPort->port, (MCSS_AUTONEG_MODE_E *)&pstCmdGmacSetPort->autoneg_mode);
+    if(OS_SUCCESS != uwRtn)
+    {
+        return uwRtn;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeGetPortAuNegState(UINT32 uwPort, UINT32 *puwAnNegState)
+{
+    SRE_GMAC_AN_NEG_STATE_U unAnState;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwAnNegState)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_AN_NEG_STATE_REG, unAnState.u32);
+
+    *puwAnNegState = unAnState.u32;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetAnLinkState
+ 功能描述  : 获取自协商link状态
+ 输入参数  : UINT32 uwPort
+             UINT32 *puwLinkState
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetAnLinkState(UINT32 uwPort, UINT32 *puwLinkState)
+{
+    SRE_GMAC_AN_NEG_STATE_U unAnState;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwLinkState)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_AN_NEG_STATE_REG, unAnState.u32);
+
+    /* BEGIN: Added by c00111586, 2011/7/28   问题单号:DTS2011072603695  */
+    /* 查看自协商是否已完成 */
+    if ( 1 != unAnState.bits.an_done)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Auto-negotiate is not complete!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_AN_NOT_COMPLETE, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_AN_NOT_COMPLETE, 0, 0);
+    }
+    /* END:   Added by c00111586, 2011/7/28 */
+
+    *puwLinkState = unAnState.bits.np_link_ok;
+    return OS_SUCCESS;
+}
+/*****************************************************************************
+ 函 数 名  : SRE_GetAnSpeed
+ 功能描述  : 获取自协商速度
+ 输入参数  : UINT32 uwPort
+             SRE_AN_NEG_SPEED_E *penAnSpeed
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetAnSpeed(UINT32 uwPort, SRE_AN_NEG_SPEED_E *penAnSpeed)
+{
+    SRE_GMAC_AN_NEG_STATE_U unAnState;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == penAnSpeed)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_AN_NEG_STATE_REG, unAnState.u32);
+    *penAnSpeed = (SRE_AN_NEG_SPEED_E)unAnState.bits.speed;
+    return OS_SUCCESS;
+}
+/*****************************************************************************
+ 函 数 名  : SRE_SetAnNegInfo
+ 功能描述  : 设置自协商配置信息
+ 输入参数  : UINT32 uwPort
+             SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SetAnNegInfo(UINT32 uwPort, SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo)
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == punAnNegInfo)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, punAnNegInfo->u32);
+
+    return OS_SUCCESS;
+}
+
+/* BEGIN: Added by c00111586, 2011/7/28   问题单号:DTS2011072603695  */
+/*****************************************************************************
+ 函 数 名  : SRE_UpdateAnLinkTime
+ 功能描述  : 更新自协商链接时间，单位为32个125M时钟周期
+ 输入参数  : UINT32 uwPort
+             UINT32 uwAnLinkTime
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年7月28日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_UpdateAnLinkTime(UINT32 uwPort, UINT32 uwAnLinkTime)
+{
+    SRE_GMAC_SIXTEEN_BIT_CNTR_U unAnLinkTime;
+    SRE_GMAC_LD_LINK_COUNTER_U unAnLdLinkCnt;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwAnLinkTime > 0xffffUL)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: illegal uwAnNegLinkTime value(%d): use"
+            "\n1-0xffff [%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_AN_LINK_TIME_ILLEGAL, uwAnLinkTime, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_AN_LINK_TIME_ILLEGAL, 0, 0);
+    }
+
+    /* 自协商链接时间更新寄存器
+       当该寄存器配置由0变成1时，0x01CC的自协商链接时间寄存器sixteen_bit_cntr
+       才会生效 */
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_LD_LINK_COUNTER_REG, unAnLdLinkCnt.u32);
+    unAnLdLinkCnt.bits.ld_link_counter = 0UL;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LD_LINK_COUNTER_REG, unAnLdLinkCnt.u32);
+
+    /* 步骤 1	配置自协商链接时间寄存器 SIXTEEN_BIT_CNTR [sixteen_bit_cntr]（
+       基地址0x30000000+1000*ch_num，偏移地址为0x01CC，Bit[15:0]）为16’h3F
+       。 */
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_SIXTEEN_BIT_CNTR_REG, unAnLinkTime.u32);
+    unAnLinkTime.bits.sixteen_bit_cntr = uwAnLinkTime;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_SIXTEEN_BIT_CNTR_REG, unAnLinkTime.u32);
+
+    /* 步骤 2	配置自协商链接时间更新寄存器LD_LINK_COUNTER [ld_link_counter]
+       （基地址0x30000000+1000*ch_num，偏移地址为0x01D0，Bit[1]）为1。 */
+    unAnLdLinkCnt.bits.ld_link_counter = 0x1UL;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_LD_LINK_COUNTER_REG, unAnLdLinkCnt.u32);
+
+    return OS_SUCCESS;
+}
+/* END:   Added by c00111586, 2011/7/28 */
+/*****************************************************************************
+ 函 数 名  : SRE_GetAnNegInfo
+ 功能描述  : 获取自协商配置信息
+ 输入参数  : UINT32 uwPort
+             SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年11月17日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetAnNegInfo(UINT32 uwPort, SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo)
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == punAnNegInfo)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOCAL_PAGE_REG, punAnNegInfo->u32);
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_ReadGmacStatRegs
+ 功能描述  : 读网口统计寄存器信息
+ 输入参数  : SRE_GMAC_STAT_S *pstrGmacStatInfo
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年12月9日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_ReadGmacStatRegs(SRE_GMAC_STAT_S *pstrGmacStatInfo)
+{
+    UINT32 uwIdx;
+
+    if ( NULL == pstrGmacStatInfo )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    for ( uwIdx = 0 ; uwIdx < SRE_GE_MAX_BUSINESS_PORT_NUM ; uwIdx++, pstrGmacStatInfo++ )
+    {
+        /*RX COUNT*/
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_UC_PKTS_REG, pstrGmacStatInfo->uwrx_uc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_MC_PKTS_REG, pstrGmacStatInfo->uwrx_mc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_BC_PKTS_REG, pstrGmacStatInfo->uwrx_bc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_TAGGED_REG, pstrGmacStatInfo->uwrx_vlan_pkt_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PAUSE_MACCONTROL_FRAMCOUNTER_REG, pstrGmacStatInfo->uwrx_fw_ctrl_frame_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_OCTETS_TOTAL_OK_REG, pstrGmacStatInfo->uwrx_octets_total_ok_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_OCTETS_BAD_REG, pstrGmacStatInfo->uwrx_octets_bad_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_OCTETS_TOTAL_FILT_REG, pstrGmacStatInfo->uwrx_octets_total_filt_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_FILT_PKT_CNT_REG, pstrGmacStatInfo->uwrx_filt_pkt_cnt);
+
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_64OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_64);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_65TO127OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_65_127);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_128TO255OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_128_255);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_255TO511OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_256_511);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_512TO1023OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_512_1023);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_1024TO1518OCTETS_REG, pstrGmacStatInfo->uwrx_framsize_1024_1518);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_PKTS_1519TOMAXOCTETS_REG, pstrGmacStatInfo->uwrx_framsize_bt_1518);
+
+        /*RX ERROR COUNT*/
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_LONG_ERRORS_REG, pstrGmacStatInfo->uwrx_frame_long_err_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_VERY_LONG_ERR_CNT_REG, pstrGmacStatInfo->uwrx_frame_very_long_err_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_RUNT_ERR_CNT_REG, pstrGmacStatInfo->uwrx_frame_runt_err_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_SHORT_ERR_CNT_REG, pstrGmacStatInfo->uwrx_frame_short_err_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_OVERRUN_CNT_REG, pstrGmacStatInfo->uwrx_overrun_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_FCS_ERRORS_REG, pstrGmacStatInfo->uwrx_fcs_error_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_DATA_ERR_REG, pstrGmacStatInfo->uwrx_data_error_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_RX_ALIGN_ERRORS_REG, pstrGmacStatInfo->uwrx_align_error_cnt);
+
+        /*TX COUNT*/
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_UC_PKTS_REG, pstrGmacStatInfo->uwtx_uc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_MC_PKTS_REG, pstrGmacStatInfo->uwtx_mc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_BC_PKTS_REG, pstrGmacStatInfo->uwtx_bc_pkts_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_TAGGED_REG, pstrGmacStatInfo->uwtx_vlan_pkt_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PAUSE_FRAMES_REG, pstrGmacStatInfo->uwtx_fw_ctrl_frame_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_OCTETS_TRANSMITTED_OK_REG, pstrGmacStatInfo->uwtx_octets_total_ok_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_OCTETS_TRANSMITTED_BAD_REG, pstrGmacStatInfo->uwtx_octets_bad_cnt);
+
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_64OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_64);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_65TO127OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_65_127);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_128TO255OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_128_255);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_255TO511OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_256_511);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_512TO1023OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_512_1023);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_1024TO1518OCTETS_REG, pstrGmacStatInfo->uwtx_framsize_1024_1518);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_PKTS_1519TOMAXOCTETS_REG, pstrGmacStatInfo->uwtx_framsize_bt_1518);
+
+        /*TX ERROR COUNT*/
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_CRC_ERROR_REG, pstrGmacStatInfo->uwtx_fcs_error_cnt);
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_UNDERRUN_REG, pstrGmacStatInfo->uwtx_underrun_err_cnt);
+
+        /*RX DROP COUNT*/
+
+        /*TX DROP COUNT*/
+        SRE_GMAC_READ_REG(uwIdx, SRE_GMAC_TX_EXCESSIVE_LENGTH_DROP_REG, pstrGmacStatInfo->uwtx_excessive_drop_cnt);
+    }
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_ChangePortMode
+ 功能描述  : 改变端口模式接口，网口初始化完成后，如果要改变双工模式，端口模
+             式，必须使用该接口
+ 输入参数  : UINT32 uwPort
+             SRE_DUPLEX_TYPE_E enDuplexType
+             SRE_PORT_MODE_E enPortMode
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年12月24日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_ChangePortMode(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType, SRE_PORT_MODE_E enPortMode)
+{
+    UINT32 uwRtn;
+    SRE_GMAC_MODE_CHANGE_EN_U unModeChangeEn;
+    SRE_PERCTRL69_U unMacRstReq;
+    SRE_GMAC_PORT_MODE_U unPortMode;
+    SRE_PERCTRL6_U strPerCtrl6;
+    SRE_PERCTRL7_U strPerCtrl7;
+    SRE_PERCTRL6_U strPerCtrl6_1;
+    SRE_PERCTRL7_U strPerCtrl7_1;
+    SRE_PERCTRL6_U strPerCtrl6_2;
+    SRE_PERCTRL7_U strPerCtrl7_2;
+    SRE_PERCTRL6_U strPerCtrl6Rst;
+    SRE_PERCTRL7_U strPerCtrl7Rst;
+
+    /* 步骤 1	配置端口通道使能寄存器 先关闭发送再关闭接收*/
+    uwRtn = SRE_GeEnableTx(uwPort, 0);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableTx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    uwRtn = SRE_GeEnableRx(uwPort, 0);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableRx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 2	配置全双工半双工模式寄存器为对接PHY的双工模式 */
+    uwRtn = SRE_SetDuplexType(uwPort, enDuplexType);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_SetDuplexType failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 3	配置端口模式寄存器为对接PHY的工作模式 */
+    uwRtn = SRE_SetPortMode(uwPort, enPortMode);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_SetPortMode failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 4	配置端口模式寄存器 RGMII模式是否delay取决于PHY是否配置了delay模式*/
+    if ((enPortMode >= GMAC_10M_RGMII) && (enPortMode <= GMAC_1000M_RGMII))
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+        unPortMode.bits.rgmii_1000m_delay = 1;
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    }
+
+    /* 步骤 5	配置端口模式改变使能寄存器 */
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+    unModeChangeEn.bits.mode_change_en = 1;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+
+    /* 步骤 6	配置MAC_CORE的应用侧时钟软复位寄存器为1 */
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 |= (1 << (9 - uwPort));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+    /* 步骤 7	配置MAC的工作时钟软复位寄存器为1。 */
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwPort )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac0_tx_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac1_tx_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac2_tx_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac3_tx_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl6.bits.gmac4_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac4_tx_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl6.bits.gmac5_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac5_tx_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl6.bits.gmac6_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac6_tx_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl6.bits.gmac7_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac7_tx_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwPort(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwPort, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    /* 步骤 8	配置MAC的发送方向SERDES的时钟软复位寄存器为1。 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    strPerCtrl6_1.u32 = strPerCtrl6.u32;
+    strPerCtrl7_1.u32 = strPerCtrl7.u32;
+
+    /* 步骤 9	配置MAC的接收方向SERDES时钟软复位寄存器为1。 */
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwPort )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_rx_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_rx_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_rx_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_rx_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl7.bits.gmac4_rx_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl7.bits.gmac5_rx_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl7.bits.gmac6_rx_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl7.bits.gmac7_rx_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwPort(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwPort, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    strPerCtrl6_2.u32 = strPerCtrl6.u32;
+    strPerCtrl7_2.u32 = strPerCtrl7.u32;
+
+    /* 步骤 10	配置MAC的RGMII接收方向时钟软复位寄存器为1。 */
+    if ( 0 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+
+    /* 步骤 11	配置MAC_CORE的应用侧时钟软复位寄存器为0。 */
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 &= ~(1UL << (9 - uwPort));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+    /* 步骤 12	配置MAC的工作时钟软复位寄存器为0。 */
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_1.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_1.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    /* 步骤 13	配置MAC的发送方向SERDES的时钟软复位寄存器为0。 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    /* 步骤 14	配置MAC的接收方向SERDES时钟软复位寄存器为0。 */
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_2.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_2.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    /* 步骤 15	配置MAC的RGMII接收方向时钟软复位寄存器为0。 */
+    if ( 0 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+
+    /* 步骤 16	配置端口通道使能寄存器 打开发送，打开接收 */
+    uwRtn = SRE_GeEnableTx(uwPort, 1);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableTx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+    uwRtn = SRE_GeEnableRx(uwPort, 1);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableRx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    return OS_SUCCESS;
+
+}
+/*****************************************************************************
+ 函 数 名  : SRE_InitGeReg
+ 功能描述  : 初始化GE模式设置
+ 输入参数  : UINT32 uwPort
+             SRE_DUPLEX_TYPE_E enDuplexType
+             SRE_PORT_MODE_E enPortMode
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+ 修改历史      :
+
+  1.日    期   : 2012年03月21日
+    作    者   : w00200395
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_InitGeReg(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType, SRE_PORT_MODE_E enPortMode)
+{
+    UINT32 uwRtn;
+    SRE_GMAC_MODE_CHANGE_EN_U unModeChangeEn;
+    //SRE_PERCTRL69_U unMacRstReq;
+    SRE_GMAC_PORT_MODE_U unPortMode;
+    //SRE_PERCTRL6_U strPerCtrl6;
+    //SRE_PERCTRL7_U strPerCtrl7;
+    //SRE_PERCTRL6_U strPerCtrl6_1;
+    //SRE_PERCTRL7_U strPerCtrl7_1;
+    //SRE_PERCTRL6_U strPerCtrl6_2;
+    //SRE_PERCTRL7_U strPerCtrl7_2;
+    //SRE_PERCTRL6_U strPerCtrl6Rst;
+    //SRE_PERCTRL7_U strPerCtrl7Rst;
+
+    /* 步骤 1	配置端口通道使能寄存器 先关闭发送再关闭接收*/
+    uwRtn = SRE_GeEnableTx(uwPort, 0);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableTx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    uwRtn = SRE_GeEnableRx(uwPort, 0);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_GeEnableRx failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 2	配置全双工半双工模式寄存器为对接PHY的双工模式 */
+    uwRtn = SRE_SetDuplexType(uwPort, enDuplexType);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_SetDuplexType failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 3	配置端口模式寄存器 */
+    uwRtn = SRE_SetPortMode(uwPort, enPortMode);
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: SRE_SetPortMode failed!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, uwRtn, 0, 0, 0, 0);
+        return uwRtn;
+    }
+
+    /* 步骤 4	配置端口模式寄存器 RGMII模式是否delay */
+    if ((enPortMode >= GMAC_10M_RGMII) && (enPortMode <= GMAC_1000M_RGMII))
+    {
+        SRE_GMAC_READ_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+        unPortMode.bits.rgmii_1000m_delay = 1;
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_PORT_MODE_REG, unPortMode.u32);
+    }
+
+    /* 步骤 5	配置端口模式改变使能寄存器 */
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+    unModeChangeEn.bits.mode_change_en = 1;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_MODE_CHANGE_EN_REG, unModeChangeEn.u32);
+#if 0
+    /* 步骤 6	配置MAC_CORE的应用侧时钟软复位寄存器为1 */
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 |= (1 << (9 - uwPort));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+    /* 步骤 7	配置MAC的工作时钟软复位寄存器为1。 */
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwPort )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac0_tx_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac1_tx_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac2_tx_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac3_tx_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl6.bits.gmac4_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac4_tx_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl6.bits.gmac5_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac5_tx_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl6.bits.gmac6_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac6_tx_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl6.bits.gmac7_eth_srst_req = 1;
+            strPerCtrl7.bits.gmac7_tx_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwPort(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwPort, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    /* 步骤 8	配置MAC的发送方向SERDES的时钟软复位寄存器为1。 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    strPerCtrl6_1.u32 = strPerCtrl6.u32;
+    strPerCtrl7_1.u32 = strPerCtrl7.u32;
+
+    /* 步骤 9	配置MAC的接收方向SERDES时钟软复位寄存器为1。 */
+    strPerCtrl6.u32 = 0;
+    strPerCtrl7.u32 = 0;
+    switch ( uwPort )
+    {
+        case 0 :
+            strPerCtrl6.bits.gmac0_rx_srst_req = 1;
+            break;
+        case 1 :
+            strPerCtrl6.bits.gmac1_rx_srst_req = 1;
+            break;
+        case 2 :
+            strPerCtrl6.bits.gmac2_rx_srst_req = 1;
+            break;
+        case 3 :
+            strPerCtrl6.bits.gmac3_rx_srst_req = 1;
+            break;
+        case 4 :
+            strPerCtrl7.bits.gmac4_rx_srst_req = 1;
+            break;
+        case 5 :
+            strPerCtrl7.bits.gmac5_rx_srst_req = 1;
+            break;
+        case 6 :
+            strPerCtrl7.bits.gmac6_rx_srst_req = 1;
+            break;
+        case 7 :
+            strPerCtrl7.bits.gmac7_rx_srst_req = 1;
+            break;
+        default:
+            SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]uwPort(%d) Error!"
+            "\n[%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, uwPort, 0, 0, 0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 读出相关控制寄存器的内容 */
+    strPerCtrl6Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL6_REG, 0);
+    strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+    strPerCtrl6Rst.u32 |= strPerCtrl6.u32;
+    strPerCtrl7Rst.u32 |= strPerCtrl7.u32;
+
+    /* 把更新后的内容写入相关的控制寄存器 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    strPerCtrl6_2.u32 = strPerCtrl6.u32;
+    strPerCtrl7_2.u32 = strPerCtrl7.u32;
+
+    /* 步骤 10	配置MAC的RGMII接收方向时钟软复位寄存器为1。 */
+    if ( 0 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 1;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+
+    /* 步骤 11	配置MAC_CORE的应用侧时钟软复位寄存器为0。 */
+    unMacRstReq.u32 = OS_READ_REG(SRE_SYS_PERCTRL69_REG, 0);
+    unMacRstReq.u32 &= ~(1UL << (9 - uwPort));
+    OS_WRITE_REG(SRE_SYS_PERCTRL69_REG, 0, unMacRstReq.u32);
+
+    /* 步骤 12	配置MAC的工作时钟软复位寄存器为0。 */
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_1.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_1.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+
+    /* 步骤 13	配置MAC的发送方向SERDES的时钟软复位寄存器为0。 */
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    /* 步骤 14	配置MAC的接收方向SERDES时钟软复位寄存器为0。 */
+    /* 解复位 */
+    strPerCtrl6Rst.u32 &= (~strPerCtrl6_2.u32);
+    strPerCtrl7Rst.u32 &= (~strPerCtrl7_2.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL6_REG, 0, strPerCtrl6Rst.u32);
+    OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+
+    /* 步骤 15	配置MAC的RGMII接收方向时钟软复位寄存器为0。 */
+    if ( 0 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac0_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+    else if ( 1 == uwPort )
+    {
+        strPerCtrl7Rst.u32 = OS_READ_REG(SRE_SYS_PERCTRL7_REG, 0);
+        strPerCtrl7Rst.bits.gmac1_rx125m_srst_req = 0;
+        OS_WRITE_REG(SRE_SYS_PERCTRL7_REG, 0, strPerCtrl7Rst.u32);
+    }
+#endif
+	/* 步骤 16	配置端口通道使能寄存器 打开发送，打开接收 */
+	/* 暂不执行，留给调用它的函数执行 */
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_CheckGmacPortCfg
+ 功能描述  : 检查gmac端口配置
+ 输入参数  : UINT32 uwPort
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年3月4日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_CheckGmacPortCfg(UINT32 uwPort)
+{
+#if 0
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /* 判断配置的POOL ID 是否合法,检查小 pool 的配置 */
+    if (OS_UNLIKELY((SRE_MEM_POOL_MAX_NUM <= g_astSreGmacCfg[uwPort].uwGmacSmallPool)
+        || (0 == SRE_GetPoolBlockSize(g_astSreGmacCfg[uwPort].uwGmacSmallPool))))
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: the uwPoolID is invalid!"
+            "\n P0=%d,P1=%d,P2=%d,P3=%d.(%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            OS_ERRNO_GMAC_POOL_CFG, 0, 0, 0, 0);
+        return  OS_ERRNO_GMAC_POOL_CFG;
+    }
+
+    /* 检查大 pool 的配置 */
+    if (SRE_GMAC_INVALID_POOL_ID != g_astSreGmacCfg[uwPort].uwGmacBigPool)
+    {
+        if (OS_UNLIKELY((SRE_MEM_POOL_MAX_NUM <= g_astSreGmacCfg[uwPort].uwGmacBigPool)
+            || (0 == SRE_GetPoolBlockSize(g_astSreGmacCfg[uwPort].uwGmacBigPool))))
+        {
+            SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: the uwPoolID is invalid!"
+                "\n P0=%d,P1=%d,P2=%d,P3=%d.(%s,L%d,B0x%x,E0x%x@VCPU%d)",
+                OS_ERRNO_GMAC_POOL_CFG, 0, 0, 0, 0);
+            return  OS_ERRNO_GMAC_POOL_CFG;
+        }
+    }
+#endif
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_SetFcTxTmr
+ 功能描述  : 设置流控帧发送时间参数
+ 输入参数  : UINT32 uwPort
+             UINT32 uwFcTxTmr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年3月12日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_SetFcTxTmr(UINT32 uwPort, UINT32 uwFcTxTmr)
+{
+    SRE_GMAC_FC_TX_TIMER_U unTxTimer;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if ( uwFcTxTmr > 0xffff )
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC] uwFcTxTmr exceeds the maximum: 0xffff!"
+            "\nuwFcTxTmr = %d [%d,%d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            OS_ERRNO_GMAC_FC_TX_TMR, uwFcTxTmr, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_FC_TX_TMR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_FC_TX_TIMER_REG, unTxTimer.u32);
+    unTxTimer.bits.fc_tx_timer = uwFcTxTmr;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_FC_TX_TIMER_REG, unTxTimer.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GetFcTxTmr
+ 功能描述  : 获取流控帧发送时间参数
+ 输入参数  : UINT32 uwPort
+             UINT32 *puwFcTxTmr
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年3月12日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GetFcTxTmr(UINT32 uwPort, UINT32 *puwFcTxTmr)
+{
+    SRE_GMAC_FC_TX_TIMER_U unTxTimer;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HIGMAC]: Port exceeds the maximum number!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PORT_ID, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(NULL == puwFcTxTmr)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC]: Input pointer NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_NULL_PTR, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_NULL_PTR, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_FC_TX_TIMER_REG, unTxTimer.u32);
+    *puwFcTxTmr = unTxTimer.bits.fc_tx_timer;
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************************
+ 函 数 名  : SRE_CheckPerfMonitorCfg
+ 功能描述  : 检查性能监测配置是否非法
+ 输入参数  : VOID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年4月14日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_CheckPerfMonitorCfg(VOID)
+{
+	/* BEGIN: Modified by f63884, 2012/8/14 */
+	#if 0
+    if ( gstrMcPerfCfg.uwHitRate > 100)
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if ( gstrMcPerfCfg.uwPoeOverLoadThr > 20000)
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if ( gstrMcPerfCfg.uwPoeRecoverThr < 1)
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if ( 0 == (gstrMcPerfCfg.uwPortMsk & 0xff))
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+	#endif
+	/* END:   Modified by f63884, 2012/8/14 */
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_PerfMonitorInit
+ 功能描述  : 性能监测初始化
+ 输入参数  : VOID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年4月15日
+    作    者   : chenxin
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+VOID SRE_PerfMonitorInit(VOID)
+{
+#if 0
+    UINT32 uwIdx;
+    UINT32 uwRtn;
+    UINT32 uwPortMsk;          /* 过载时反压端口号掩码 */
+
+    uwRtn = SRE_CheckPerfMonitorCfg();
+    if ( OS_SUCCESS != uwRtn )
+    {
+        SRE_printf("\nSRE_CheckPerfMonitorCfg failed!");
+        return;
+    }
+
+    SRE_MemSet((VOID*)&gstrMcPerf, 0, sizeof(SRE_GMAC_PERF_S));
+
+    uwPortMsk = gstrMcPerfCfg.uwPortMsk;
+
+    /* 计算配置的端口号 */
+    for ( uwIdx = 0 ; uwIdx < SRE_GE_MAX_BUSINESS_PORT_NUM; uwIdx++ )
+    {
+        if ( uwPortMsk & (1UL << uwIdx) )
+        {
+            gstrMcPerf.auwPort[gstrMcPerf.uwPortSum] = uwIdx;
+            gstrMcPerf.uwPortSum++;
+        }
+    }
+
+    /* 获取端口对应的pool */
+    gstrMcPerf.uwPool = g_astSreGmacCfg[gstrMcPerf.auwPort[0]].uwGmacSmallPool;
+
+    /* 获取使用的pool配置的buffer总数 */
+    gstrMcPerf.uwPoolTotalNum = gastrMcMemPoolCfg[gstrMcPerf.uwPool].uwBlockNums;
+
+    /* 获取timebase频率 */
+    gstrMcPerf.uwTimeBaseRate = SRE_GetLocalTimeBaseRate();
+
+    /* 计算查询周期的tick数 */
+    gstrMcPerf.uwlIntervalTick = ((UINT64)gstrMcPerfCfg.uwPeriod * (UINT32)(gstrMcPerf.uwTimeBaseRate / 1000));
+#endif
+    return;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_PerMonitor
+ 功能描述  : 性能监测
+ 输入参数  : VOID
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年4月14日
+    作    者   : c00111586
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+VOID SRE_PerfMonitor(VOID)
+{
+#if 0
+    /* BEGIN: Modified by c00111586, 2011/4/27   问题单号:DTS2011042603592 */
+    UINT64 uwlCurTick;
+    /* END:   Modified by c00111586, 2011/4/27 */
+
+    UINT32 uwHitRate;          /* cache命中率 这里的值不包含 "%" */
+    UINT32 uwPoeOverLoadThr;   /* POE中缓存的报文个数检测过载门限 */
+    UINT32 uwPoeRecoverThr;    /* POE中缓存的报文个数检测恢复门限 */
+    UINT32 uwPoePktNum;
+    UINT32 uwCurHitRate;
+    UINT32 uwPoolCnt;
+    UINT32 uwIdx;
+    UINT32 uwBmuIntEn;
+    UINT32 uwDataHit;
+    UINT32 uwDataAcc;
+    UINT32 uwOddHit;
+    UINT32 uwOddAcc;
+
+    /* 获取当前tick值 */
+    uwlCurTick = SRE_GetLocalTimeBase();
+
+    /* 计算是否到达监测时间 */
+    if((uwlCurTick - gstrMcPerf.uwlTick) >= gstrMcPerf.uwlIntervalTick)
+    {
+        /* 读出配置接口的变量，优点: 降低性能损耗，缺点: 不能动态设置 */
+        uwHitRate = gstrMcPerfCfg.uwHitRate;
+        uwPoeOverLoadThr = gstrMcPerfCfg.uwPoeOverLoadThr;
+        uwPoeRecoverThr = gstrMcPerfCfg.uwPoeRecoverThr;
+
+        /* 更新监测时基 */
+        gstrMcPerf.uwlTick = uwlCurTick;
+
+        /* 计算Cache命中率 */
+        uwDataHit = OS_READ_REG(SRE_L2_DATA_RD_HIT_REG, 0);
+        uwDataAcc = OS_READ_REG(SRE_L2_DATA_RD_CNT_REG, 0);
+        uwDataHit = 0xffffffffUL - uwDataHit;
+        uwDataAcc  = 0xffffffffUL - uwDataAcc;
+
+        /*更新统计*/
+        gstrMcPerf.uwL2Cnt[0] = uwDataHit;
+        gstrMcPerf.uwL2Cnt[1] = uwDataAcc;
+
+        /* 检测端口是否处于流控状态 */
+        if ( 1 == gstrMcPerf.uwFlowCtrlFlg )
+        {
+            /*检测POE中报文个数*/
+            uwPoePktNum = SRE_GetPoePktNum();
+
+            /* 如果POE中报文个数低于恢复门限，清除端口强制流控 */
+            if ( uwPoePktNum > uwPoeRecoverThr )
+            {
+                /* BEGIN: Modified by chenxin, 2011/4/22   问题单号:DTS2011042102894  */
+                /* 清除BMU空中断标志，指示空中断已被处理 */
+                gpstrMcBlkmemShare->uwMcBmuEmptyFlg = 0;
+
+                /* 使能BMU空中断使能 */
+                uwBmuIntEn = OS_READ_REG(SRE_BMU_INT_EN,0);
+                uwBmuIntEn |= (1UL << 10);
+                OS_WRITE_REG((UINT32*)SRE_BMU_INT_EN, 0, uwBmuIntEn);
+                /* END:   Modified by chenxin, 2011/4/22 */
+                return;
+            }
+
+            /*如果采用gmac反压，停止pause帧  */
+            for ( uwIdx = 0 ; uwIdx < gstrMcPerf.uwPortSum ; uwIdx++ )
+            {
+                SRE_GMAC_WRITE_REG(gstrMcPerf.auwPort[uwIdx], SRE_GMAC_PAUSE_EN_REG,
+                    gstrMcPerf.auwPauseEn[uwIdx]);
+                SRE_SetCfTxPause(gstrMcPerf.auwPort[uwIdx],0);
+            }
+
+            /* 退出流控状态 */
+            gstrMcPerf.uwFlowCtrlFlg = 0;
+        }
+        else    /* 如果不在流控状态 */
+        {
+            /* 检查是否有BMU的空中断 */
+            if ( 1 != gpstrMcBlkmemShare->uwMcBmuEmptyFlg )
+            {
+                if (uwDataHit > gstrMcPerf.uwL2Cnt[0])
+                {
+                    uwOddHit  = uwDataHit - gstrMcPerf.uwL2Cnt[0];
+                }
+                else
+                {
+                    uwOddHit  =  uwDataHit + (0xffffffff - gstrMcPerf.uwL2Cnt[0]);
+                }
+
+                if (uwDataAcc > gstrMcPerf.uwL2Cnt[1])
+                {
+                    uwOddAcc  = uwDataAcc - gstrMcPerf.uwL2Cnt[1];
+                }
+                else
+                {
+                    uwOddAcc  = uwDataAcc + (0xffffffff - gstrMcPerf.uwL2Cnt[1]);
+                }
+
+                uwCurHitRate = (uwOddHit * 100)/uwOddAcc;
+
+                if ( uwCurHitRate > uwHitRate )
+                {
+                    return;
+                }
+
+                /* 获取pool的buffer个数 */
+                uwPoolCnt = (UINT32)SRE_GetPoolCnt(gstrMcPerf.uwPool);
+                if ((uwPoolCnt << 1) > gstrMcPerf.uwPoolTotalNum )
+                {
+                    return;
+                }
+            }
+
+            /*检测POE中报文个数*/
+            uwPoePktNum = SRE_GetPoePktNum();
+
+            /* 如果POE中报文个数低于恢复门限，清除端口强制流控 */
+            if ( uwPoePktNum < uwPoeOverLoadThr)
+            {
+                /* BEGIN: Modified by chenxin, 2011/4/22   问题单号:DTS2011042102894  */
+                /* 清除BMU空中断标志，指示空中断已被处理 */
+                gpstrMcBlkmemShare->uwMcBmuEmptyFlg = 0;
+
+                /* 使能BMU空中断使能 */
+                uwBmuIntEn = OS_READ_REG(SRE_BMU_INT_EN,0);
+                uwBmuIntEn |= (1UL << 10);
+                OS_WRITE_REG((UINT32*)SRE_BMU_INT_EN, 0, uwBmuIntEn);
+                /* END:   Modified by chenxin, 2011/4/22 */
+                return;
+            }
+
+            /* 强制发送流控帧 */
+            for ( uwIdx = 0 ; uwIdx < gstrMcPerf.uwPortSum ; uwIdx++ )
+            {
+                SRE_GMAC_READ_REG(gstrMcPerf.auwPort[uwIdx], SRE_GMAC_PAUSE_EN_REG,
+                    gstrMcPerf.auwPauseEn[uwIdx]);
+                SRE_GmacPauseFrmCfg(gstrMcPerf.auwPort[uwIdx],1,1);
+                SRE_SetCfTxPause(gstrMcPerf.auwPort[uwIdx],1);
+            }
+
+            /* 进入流控状态 */
+            gstrMcPerf.uwFlowCtrlFlg = 1;
+        }
+
+        /* 清除BMU空中断标志，指示空中断已被处理 */
+        gpstrMcBlkmemShare->uwMcBmuEmptyFlg = 0;
+
+        /* 使能BMU空中断使能 */
+        uwBmuIntEn = OS_READ_REG(SRE_BMU_INT_EN,0);
+        uwBmuIntEn |= (1UL << 10);
+        OS_WRITE_REG((UINT32*)SRE_BMU_INT_EN, 0, uwBmuIntEn);
+    }
+#endif
+    return;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_LocalMacAddrEn
+ 功能描述  : 与XGE共用的本地不带掩码的mac地址使能31-0bit对应
+                            31-0个本地mac地址
+ 输入参数  : uwMacAddrEn
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年11月11日
+    作    者   : wuqian 00163512
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GeEnLocalMacAddr( UINT32 uwPort, UINT32 uwMacAddrEn )
+{
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_DMAC_EN_REG, uwMacAddrEn);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_LocalMacAddrEn
+ 功能描述  : 与XGE共用的本地带掩码的mac地址使能5-0bit对应
+                            5-0个本地带掩码的mac地址
+ 输入参数  : uwMacAddrEn
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年11月11日
+    作    者   : wuqian 00163512
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GeEnLocalMacAddrMask( UINT32 uwPort, UINT32 uwMacAddrEn )
+{
+    SRE_GMAC_DMAC_WITH_MSK_EN_U unEnMacAddrWithMsk;
+    unEnMacAddrWithMsk.u32 = 0;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwMacAddrEn > SRE_GE_MAC_ADDR_MSK_MAX)
+    {
+        SRE_HIGMAC_ERROR("\n[SRE_HISGMAC] Port mode parameter NULL!"
+            "\n[%d,%d, %d, %d] (%s,L%d,B0x%x,E0x%x@VCPU%d)",
+            0xffffffff, OS_ERRNO_GMAC_PARA, 0, 0, 0, 0);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PARA, 0, 0);
+    }
+
+   unEnMacAddrWithMsk.bits.dmac_with_msk_en = uwMacAddrEn & 0x3f;
+   SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_DMAC_EN_REG, unEnMacAddrWithMsk.u32);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : SRE_GmacCrcAddEn
+ 功能描述  : GE无损环回使能配置
+ 输入参数  : UINT32 uwPort
+             UINT32 uwEnValue
+ 输出参数  : 无
+ 返 回 值  :
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2010年5月17日
+    作    者   : wuzhenhua
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 SRE_GeSetNlstEn(UINT32 uwPort, UINT32 uwNlstEn)
+{
+    SRE_GMAC_TX_LOOP_PKT_PRI_U unGeTxLoopPktPri;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwNlstEn > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOOP_PKT_PRI_REG, unGeTxLoopPktPri.u32);
+    unGeTxLoopPktPri.bits.loop_pkt_en = uwNlstEn;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOOP_PKT_PRI_REG, unGeTxLoopPktPri.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeSetNlstPri(UINT32 uwPort, UINT32 uwNlstPri)
+{
+    SRE_GMAC_TX_LOOP_PKT_PRI_U unGeTxLoopPktPri;
+
+    if(uwPort >= SRE_GE_MAX_BUSINESS_PORT_NUM)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if(uwNlstPri > 1)
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_VALUE_EXCEED_MAX, 0, 0);
+    }
+    SRE_GMAC_READ_REG(uwPort, SRE_GMAC_TX_LOOP_PKT_PRI_REG, unGeTxLoopPktPri.u32);
+    unGeTxLoopPktPri.bits.loop_pkt_hig_pri = uwNlstPri;
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TX_LOOP_PKT_PRI_REG, unGeTxLoopPktPri.u32);
+
+    return OS_SUCCESS;
+}
+
+UINT32 guwMdioTimeOut = 1000;
+UINT32 SRE_GeSetMidoTimeOut(UINT32 uwTimeOut)
+{
+    guwMdioTimeOut = uwTimeOut;
+    return OS_SUCCESS;
+}
+
+UINT32 guwCnt;
+
+
+/*****************************************************************************
+ 函 数 名  : MDIO_Hi1381_Read
+ 功能描述  : MDIO读函数，读PHY寄存器的值
+ 输入参数  : UINT32 uwMdioPort
+             UINT32 uwPhyAddr
+             UINT32 uwRegAddr
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年6月5日
+    作    者   : g00198889
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 MDIO_Hi1381_Read(UINT32 uwMdioPort, UINT32 uwPhyAddr, UINT32 uwRegAddr,UINT32 *puwRegVal)
+{
+    MDIO_COMMAND_REG_U      unMdioCmdReg;
+    MDIO_RDATA_REG_U        unMdioRDataReg;
+    MDIO_STA_REG_U          unMdioStaReg;
+
+    UINT32                  uwTimeCnt = guwMdioTimeOut;
+    //UINT32                   lRegVal   = -1;
+    //SRE_printf("Read time %d\n",guwCnt);
+    guwCnt ++;
+
+    if (uwMdioPort > 2)
+    {
+        SRE_printf("Wrong mdio port: uwMdioPort(%x)\n", uwMdioPort);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if (uwPhyAddr > MDIO_MAX_PHY_ADDR)
+    {
+        SRE_printf("Wrong phy address: uwPhyAddr(%x)\n", uwPhyAddr);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if (uwRegAddr > MDIO_MAX_PHY_REG_ADDR)
+    {
+        SRE_printf("Wrong uwRegAddr address: uwRegAddr(%x)\n", uwRegAddr);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if (NULL == puwRegVal)
+    {
+        SRE_printf("puwRegVal is NULL\n");
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /* Step 1; 先判断MDIO_COMMAND_REG的mdio_start位是否为0，因为只有为0的时候，才可以进行读写操作  */
+    MDIO_REG_READ(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+    while (unMdioCmdReg.bits.Mdio_Start)     /* 表示此时正在进行MDIO访问，需要等待50us  */
+    {
+        SRE_PhyDelayUs(10000);     /* 延时50us,  650 FPGA下该时间不够，所以这里提高了二十倍的延时  */
+        uwTimeCnt--;
+        MDIO_REG_READ(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+        if (0 == uwTimeCnt)         /* 表示已经超时，此时应该报错  */
+        {
+            SRE_printf(" Timeout! MDIO is always busy! MDIO_COMMAND_REG(0x%x) \n", unMdioCmdReg.u32);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+        }
+    }
+
+    /* Step 2; 配置命令寄存器，发出读命令  */
+    unMdioCmdReg.bits.Mdio_St    = MDIO_ST_CLAUSE_22;       /* 配置当前的mdio为clause22  */
+    unMdioCmdReg.bits.Mdio_Op    = MDIO_CLAUSE_22_READ;     /* 配置当前的操作为读操作  */
+    unMdioCmdReg.bits.Mdio_Prtad = (UINT16)uwPhyAddr;        /* 当mdio_st为2’b01时，表示要访问的外部的PHY地址  */
+    unMdioCmdReg.bits.Mdio_Devad = uwRegAddr;                /* 当mdio_st为2’b01时，表示要访问的外部PHY的寄存器地址  */
+    unMdioCmdReg.bits.Mdio_Start = 1;                       /* 启动操作  */
+    MDIO_REG_WRITE(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+
+    /* Step 3; 查询MDIO_COMMAND_REG的mdio_start位是否为0， 检查此时读命令是否完成  */
+    uwTimeCnt = guwMdioTimeOut;
+    while (unMdioCmdReg.bits.Mdio_Start)     /* 表示此时正在进行MDIO访问，需要等待50us  */
+    {
+        SRE_PhyDelayUs(10000);     /* 延时50us,  650 FPGA下该时间不够，所以这里提高了二十倍的延时  */
+        uwTimeCnt--;
+        MDIO_REG_READ(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+        if (0 == uwTimeCnt)         /* 表示已经超时，此时应该报错  */
+        {
+            SRE_printf(" Timeout! MDIO is always busy! MDIO_COMMAND_REG(0x%x) \n", unMdioCmdReg.u32);
+            RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+        }
+    }
+
+    MDIO_REG_READ(uwMdioPort, MDIO_STA_REG, unMdioStaReg.u32);
+    if (unMdioStaReg.bits.Mdio_Sta) /* 表示读操作异常  */
+    {
+        SRE_printf(" ERROR! MDIO Read failed!\n");
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    /* Step 4; 读出数据  */
+    MDIO_REG_READ(uwMdioPort, MDIO_RDATA_REG, unMdioRDataReg.u32);
+    *puwRegVal = unMdioRDataReg.bits.Mdio_Rdata;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ 函 数 名  : MDIO_Hi1381_Write
+ 功能描述  : MDIO写函数，往PHY寄存器写值
+ 输入参数  : UINT32 uwMdioPort
+             UINT32 uwPhyAddr
+             UINT32 uwRegAddr
+             UINT32 uwValue
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年6月5日
+    作    者   : g00198889
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 MDIO_Hi1381_Write(UINT32 uwMdioPort, UINT32 uwPhyAddr, UINT32 uwRegAddr, UINT32 uwValue)
+{
+    MDIO_COMMAND_REG_U      unMdioCmdReg;
+    MDIO_WDATA_REG_U        unMdioWDataReg;
+
+    UINT32                  uwTimeCnt     = guwMdioTimeOut;
+    UINT32                   uwRet          = MDIO_ERROR;
+    //SRE_printf("Write time %d\n",guwCnt);
+    guwCnt ++;
+
+    if (uwMdioPort > 2)
+    {
+        SRE_printf("Wrong mdio port: uwMdioPort(%x)\n", uwMdioPort);
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    if (uwPhyAddr > MDIO_MAX_PHY_ADDR)
+    {
+        SRE_printf("Wrong phy address\n");
+        return uwRet;
+    }
+
+    if (uwRegAddr > MDIO_MAX_PHY_REG_ADDR)
+    {
+        SRE_printf("Wrong reg address\n");
+        return uwRet;
+    }
+/*SRE_printf("%s %d; "" LeoGao mdio0 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    /* Step 1; 先判断MDIO_COMMAND_REG的mdio_start位是否为0，因为只有为0的时候，才可以进行读写操作  */
+    MDIO_REG_READ(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+
+    while (unMdioCmdReg.bits.Mdio_Start)     /* 表示此时正在进行MDIO访问，需要等待50us  */
+    {
+        SRE_PhyDelayUs(10000);        /* 延时50us,  650 FPGA下该时间不够，所以这里提高了二十倍的延时      */
+        uwTimeCnt--;
+        MDIO_REG_READ(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+        if (0 == uwTimeCnt)         /* 表示已经超时，此时应该报错  */
+        {
+            SRE_printf(" Timeout! MDIO is always busy! MDIO_COMMAND_REG(0x%x) \n", unMdioCmdReg.u32);
+            return uwRet;
+        }
+    }
+/*SRE_printf("%s %d; "" LeoGao mdio1 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    /* Step 2; 将需要写入的值先写入写访问数据寄存器  */
+    MDIO_REG_READ(uwMdioPort, MDIO_WDATA_REG, unMdioWDataReg.u32);
+    unMdioWDataReg.bits.Mdio_Wdata = uwValue;
+    //SRE_printf("%s %d; "" LeoGao mdio2 Here; uwValue = 0x%x ! \n", __FUNCTION__, __LINE__, uwValue);
+    MDIO_REG_WRITE(uwMdioPort, MDIO_WDATA_REG, unMdioWDataReg.u32);
+    //SRE_printf("%s %d; "" LeoGao mdio3 Here ! \n", __FUNCTION__, __LINE__);
+
+    /* Step 3; 配置写操作命令  */
+    unMdioCmdReg.bits.Mdio_St    = MDIO_ST_CLAUSE_22;       /* 配置当前的mdio为clause22  */
+    unMdioCmdReg.bits.Mdio_Op    = MDIO_CLAUSE_22_WRITE;    /* 配置当前的操作为写操作  */
+    unMdioCmdReg.bits.Mdio_Prtad = (UINT16)uwPhyAddr;        /* 当mdio_st为2’b01时，表示要访问的外部的PHY地址  */
+    unMdioCmdReg.bits.Mdio_Devad = uwRegAddr;                /* 当mdio_st为2’b01时，表示要访问的外部PHY的寄存器地址  */
+    unMdioCmdReg.bits.Mdio_Start = 1;                       /* 启动操作  */
+/*SRE_printf("%s %d; "" LeoGao mdio4 Here ! \n", __FUNCTION__, __LINE__);  */
+    MDIO_REG_WRITE(uwMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+/*SRE_printf("%s %d; "" LeoGao mdio5 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PhyReadReg(UINT32 uwMdioPort, UINT32 uwPhyAddr,UINT32 uwRegPage, UINT32 uwRegAddr, UINT32 *puwValue)
+{
+    if((uwRegPage > 28) || (uwRegPage == 22))
+    {
+        ;
+    }
+
+    MDIO_Hi1381_Write(uwMdioPort, uwPhyAddr, 22, uwRegPage);
+    MDIO_Hi1381_Read(uwMdioPort, uwPhyAddr, uwRegAddr, puwValue);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PhyWriteReg(UINT32 uwMdioPort, UINT32 uwPhyAddr, UINT32 uwRegPage, UINT32 uwRegAddr, UINT32 uwValue)
+{
+    if((uwRegPage > 28) || (uwRegPage == 22))
+    {
+        RETURN_ERROR(__LINE__, OS_ERRNO_GMAC_PORT_ID, 0, 0);
+    }
+
+    MDIO_Hi1381_Write(uwMdioPort, uwPhyAddr, 22, uwRegPage);
+    MDIO_Hi1381_Write(uwMdioPort, uwPhyAddr, uwRegAddr, uwValue);
+
+    return OS_SUCCESS;
+}
+UINT32 SRE_PhyTestRead(UINT32 uwRegPage, UINT32 uwRegAddr)
+{
+    UINT32 uwMdioPort = 0;
+    UINT32 uwPhyAddr = 0;
+    UINT32 uwValue;
+    SRE_PhyReadReg(uwMdioPort, uwPhyAddr, uwRegPage, uwRegAddr, &uwValue);
+    SRE_printf("\nuwValue = 0x%08x\n",uwValue);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PhyTestWrite(UINT32 uwRegPage, UINT32 uwRegAddr, UINT32 uwValue)
+{
+    UINT32 uwMdioPort = 0;
+    UINT32 uwPhyAddr = 0;
+
+    SRE_PhyWriteReg(uwMdioPort, uwPhyAddr, uwRegPage, uwRegAddr, uwValue);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SetLineLoop(void)
+{
+    //UINT32 uwReadReg;
+    UINT32 uwValue;
+    UINT32 uwMdioPort = 0;
+    UINT32 uwPhy = 0;
+    //UINT32 uwTmpMaxSpeed;
+    //UINT32 uwTmpAutoNegEnable;
+
+    /*cancel force link*/
+    SRE_PhyReadReg(uwMdioPort, uwPhy, 0, 16, &uwValue);
+    uwValue &= ~(1<<10);
+    SRE_PhyWriteReg(uwMdioPort, uwPhy, 0, 16, uwValue);
+
+    /*restore auto-negotiate mode */
+    #if 0
+    uwRet = MARVL88E1512_PHY_QryAutoNeg (uwPhy,&uwTmpMaxSpeed, &uwTmpAutoNegEnable);
+
+
+    if(g_auwMvl1512PhyAutoNegStateBeforeLoop[uwPhy] != uwTmpAutoNegEnable)
+    {
+        uwRet = MARVL88E1512_PHY_SetAutoNeg (uwPhy, g_auwMvl1512PhyAutoNegSpeedBeforeLoop[uwPhy], g_auwMvl1512PhyAutoNegStateBeforeLoop[uwPhy]);
+    }
+    #endif
+
+    /*enable the line side loop,控制line loop的寄存器是 register 21_2 */
+    SRE_PhyReadReg(uwMdioPort, uwPhy, 2, 21, &uwValue);
+    uwValue |= (1<<14);
+    SRE_PhyWriteReg(uwMdioPort, uwPhy, 2, 21, uwValue);
+
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_GeFpgaAdapt(UINT32 uwPort)
+{
+    SRE_SetPortMode(uwPort, GMAC_100M_SGMII);
+
+    SRE_PhyTestWrite(18, 20, 1);
+    SRE_PhyTestWrite(18, 20, 0x8001);
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, 0x60);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SamplePhySet(UINT32 uwPort)
+{
+    SRE_SetPortMode(uwPort, GMAC_1000M_SGMII);
+
+    MAR1512_Write(20, 18, 1);
+    MAR1512_Write(20, 18, 0x8001);
+
+    SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, 0x60);
+return OS_SUCCESS;
+}
+#endif
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
diff --git a/drivers/misc/serdes/SRE_ge.h b/drivers/misc/serdes/SRE_ge.h
new file mode 100644
index 0000000..1033ca3
--- /dev/null
+++ b/drivers/misc/serdes/SRE_ge.h
@@ -0,0 +1,1087 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : SRE_ge.inc
+  版 本 号   : 初稿
+  作    者   : Xu-Qiming
+  生成日期   : 2010年4月7日
+  最近修改   :
+  功能描述   :
+  函数列表   :
+  修改历史   :
+  1.日    期   : 2010年4月7日
+    作    者   : Xu-Qiming
+    修改内容   : 创建文件
+
+******************************************************************************/
+
+#ifndef _SRE_GE_INC
+#define _SRE_GE_INC
+
+#include "SRE_drv.h"
+#include "SRE_memmap.h"
+//#include "SRE_ge1.h"
+//#include "SRE_xge.h"
+
+/*----------------------------------------------*
+ * 外部变量说明                                 *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 外部函数原型说明                             *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 内部函数原型说明                             *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 全局变量                                     *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 模块级变量                                   *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 常量定义                                     *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 宏定义                                       *
+ *----------------------------------------------*/
+
+
+#define SRE_MDIO_0   0
+#define SRE_MDIO_1   1
+#define SRE_MDIO_MAX        2
+#define SRE_PHY_ADDR_MAX    31
+#define SRE_PHY_REG_MAX     31
+
+/* 最大帧长 */
+#define SRE_GMAC_MAX_FRM_SIZE 65531   /* 单位是字节 */
+
+/* 超短帧的最大长度 */
+#define SRE_GMAC_SHORT_MAX_FRM_SIZE 31
+
+
+/***********************************************************
+****************************************************************
+              MAC寄存器的联合体定义START
+***************************************************************
+***************************************************************/
+
+/*结构体定义*/
+/* Define the union SRE_MAC_DUPLEX_TYPE_U  addr :0x8*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0    : 31  ; /* [31..1]  */
+        UINT32    duplex_type   : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+}SRE_MAC_DUPLEX_TYPE_U;
+
+/* Define the union SRE_GMAC_FD_FC_TYPE_U  addr :0xc*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..16]  */
+        UINT32    fc_tx_timer           : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_FD_FC_TYPE_U;
+
+
+/* Define the union SRE_GMAC_FC_TX_TIMER_U  addr :0x1c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..16]  */
+        UINT32    fc_tx_timer           : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_FC_TX_TIMER_U;
+
+/* Define the union SRE_GMAC_FD_FC_ADDR_HIGH_U  addr :0x24*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..16]  */
+        UINT32    fd_fc_addr_high       : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_FD_FC_ADDR_HIGH_U;
+
+/* Define the union SRE_GMAC_IPG_TX_TIMER_U  addr :0x30*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 24  ; /* [31..8]  */
+        UINT32    ipg_tx_timer          : 8   ; /* [7..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_IPG_TX_TIMER_U;
+
+/* Define the union SRE_GMAC_PAUSE_THR_U  addr :0x38*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..16]  */
+        UINT32    pause_thr             : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_PAUSE_THR_U;
+
+/* Define the union SRE_GMAC_MAX_FRM_SIZE_U  addr :0x3c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..15]  */
+        UINT32    max_frm_size          : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_MAX_FRM_SIZE_U;
+
+/* Define the union SRE_GMAC_PORT_MODE_U  addr :0x40*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 24  ; /* [31..8]  */
+        UINT32    dbg_clk_los_msk       : 1 ;  /*[7]  */
+        UINT32    fifo_err_auto_rst     : 1 ;  /*[6]  */
+        UINT32    mii_tx_edge_sel       : 1 ;  /*[5]  */
+        UINT32    rgmii_1000m_delay     : 1 ;  /*[4]  */
+        UINT32    port_mode             : 4   ; /* [3..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_PORT_MODE_U;
+
+/* Define the union SRE_GMAC_PORT_EN_U  addr :0x44*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 29  ; /* [31..3]  */
+        UINT32    tx_en                 : 1   ; /* [2]  */
+        UINT32    rx_en                 : 1   ; /* [1]  */
+        UINT32    Reserved_1            : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_PORT_EN_U;
+
+/* Define the union SRE_GMAC_PAUSE_EN_U  addr :0x48*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 29  ; /* [31..3]  */
+        UINT32    tx_hdfc               : 1   ; /* [2]  */
+        UINT32    tx_fdfc               : 1   ; /* [1]  */
+        UINT32    rx_fdfc               : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_PAUSE_EN_U;
+
+/* Define the union SRE_GMAC_SHORT_RUNTS_THR_U  addr :0x50*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 27  ; /* [31..5]  */
+        UINT32    short_runts_thr       : 5   ; /* [4..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_SHORT_RUNTS_THR_U;
+
+/* Define the union SRE_GMAC_AN_NEG_STATE_U  addr :0x58*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0    : 10  ; /* [31..22]  */
+        UINT32    an_done          :1  ;/*[21]*/
+        UINT32    rx_sync_ok     :1  ;/*[20]*/
+        UINT32    Reserved_1    : 4  ; /* [19..16]  */
+        UINT32    np_link_ok       : 1   ; /* [15]  */
+        UINT32    Reserved_2    : 1; /* [14]  */
+        UINT32    rf2               : 1   ; /* [13]  */
+        UINT32    rf1_duplex        : 1   ; /* [12]  */
+        UINT32    speed         : 2   ; /* [11..10]  */
+        UINT32    Reserved_3    : 1; /* [9]  */
+         UINT32    ps         : 2   ; /* [7..8]  */
+        UINT32    hd         : 1   ; /* [6]  */
+        UINT32    fd         : 1   ; /* [5]  */
+        UINT32     Reserved_4    : 5  ; /* [4..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_AN_NEG_STATE_U;
+
+/* Define the union SRE_GMAC_TX_LOCAL_PAG_U  addr :0x5c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved_0      : 16  ; /* [31..16]  */
+        UINT32    cfg_15bit       : 1   ; /* [15]*/
+        UINT32    reserved_1      : 1   ; /* [14]*/
+        UINT32    cfg_13_12bit    : 2   ; /* [13..12]  */
+        UINT32    cfg_11_10bit    : 2   ; /* [11..10]  */
+        UINT32    reserved_2      : 1   ; /* [9]  */
+        UINT32    cfg_8_5bit      : 4   ; /* [8..5]  */
+        UINT32    reserved_3      : 4   ; /* [4..1]  */
+        UINT32    cfg_0bit        : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_TX_LOCAL_PAG_U;
+
+/* Define the union SRE_GMAC_TRANSMIT_CONTROL_U  addr :0x60*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 24  ; /* [31..8]  */
+        UINT32    pad_enable            : 1   ; /* [7]  */
+        UINT32    crc_add               : 1   ; /* [6]  */
+        UINT32    an_enable           :1;    /*[5]*/
+        UINT32    Reserved_1            : 5   ; /* [4..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_TRANSMIT_CONTROL_U;
+
+/* Define the union SRE_GMAC_REC_FILT_CONTROL_U  addr :0x64*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 26  ; /* [31..6]  */
+        UINT32    crc_err_pass          : 1   ; /* [5]  */
+        UINT32    pause_frm_pass        : 1   ; /* [4]  */
+        UINT32    reserved_1          : 1   ; /* [3]  */
+        UINT32    bc_drop_en            : 1   ; /* [2]  */
+        UINT32    mc_match_en           : 1   ; /* [1]  */
+        UINT32    uc_match_en           : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_REC_FILT_CONTROL_U;
+
+
+/* Define the union SRE_GMAC_PTP_CONFIG_U  addr :0x74*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 30  ; /* [31..2]  */
+        UINT32    chksum_calc_en               : 1   ; /* [1]  */
+        UINT32    corfield_msb_en               : 1   ; /* [0]  */
+   } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_PTP_CONFIG_U;
+
+/* Define the union SRE_GMAC_LED_MOD_U  addr :0x16c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 31  ; /* [31..1]  */
+        UINT32    led_mod               : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_LED_MOD_U;
+
+/* Define the union SRE_GMAC_LINE_LOOP_BACK_U  addr :0x1A8*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 31  ; /* [31..1]  */
+        UINT32    line_loop_back        : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_LINE_LOOP_BACK_U;
+
+/* Define the union SRE_GMAC_CF_CRC_STRIP_U  addr :0x1B0*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 31  ; /* [31..1]  */
+        UINT32    cf_crc_strip          : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_CF_CRC_STRIP_U;
+
+/* Define the union SRE_GMAC_MODE_CHANGE_EN_U  addr :0x1B4*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 31  ; /* [31..1]  */
+        UINT32    mode_change_en        : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_MODE_CHANGE_EN_U;
+
+/* Define the union SRE_GMAC_SIXTEEN_BIT_CNTR_U  addr :0x1CC*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 31  ; /* [31..1]  */
+        UINT32    sixteen_bit_cntr        : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_SIXTEEN_BIT_CNTR_U;
+
+/* Define the union SRE_GMAC_LD_LINK_COUNTER_U  addr :0x1D0*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 30  ; /* [31..2]  */
+        UINT32    ld_link_counter        : 1   ; /* [1]  */
+        UINT32    Reserved_1            : 1  ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_LD_LINK_COUNTER_U;
+
+/* Define the union SRE_GMAC_LOOP_REG_U  addr :0x1DC*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 29  ; /* [31..3]  */
+        UINT32    cf2mi_lp_en           : 1   ; /* [2]  */
+        UINT32    cf_ext_drive_lp       : 1   ; /* [1]  */
+        UINT32    Reserved_1            : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_LOOP_REG_U;
+
+/* Define the union SRE_GMAC_RECV_CONTROL_U  addr :0x1e0*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 27  ; /* [31..5]  */
+        UINT32    runt_pkt_en           : 1   ; /* [4]  */
+        UINT32    strip_pad_en          : 1   ; /* [3]  */
+        UINT32    Reserved_1            : 3   ; /* [2..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_RECV_CONTROL_U;
+
+/* Define the union SRE_GMAC_VLAN_CODE_U  addr :0x1e8*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 16  ; /* [31..16]  */
+        UINT32    cf_vlan_code          : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_VLAN_CODE_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_U  addr :0x204*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_0_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_0   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_1_U  addr :0x20c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_1_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_1   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_1_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_2_U  addr :0x214*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_2_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_2   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_2_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_3_U  addr :0x21c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_3_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_3   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_3_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_4_U  addr :0x224*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_4_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_4   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_4_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_5_U  addr :0x22c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 15  ; /* [31..17]  */
+        UINT32    station_addr_5_en  :1   ;/*[16]*/
+        UINT32    station_addr_high_5   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_5_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_MSK_0_U  addr :0x234*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0                : 16  ; /* [31..16]  */
+        UINT32    station_addr_high_msk_0   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_MSK_0_U;
+
+/* Define the union SRE_GMAC_STATION_ADDR_HIGH_MSK_1_U  addr :0x23c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0                : 16  ; /* [31..16]  */
+        UINT32    station_addr_high_msk_1   : 16  ; /* [15..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_STATION_ADDR_HIGH_MSK_1_U;
+
+/* Define the union SRE_GMAC_MAC_SKIP_LEN_U  addr :0x240*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved_0            : 25  ; /* [31..7]  */
+        UINT32    mac_skip_crc          : 1   ; /* [6]  */
+        UINT32    mac_skip_len          : 6   ; /* [5..0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_MAC_SKIP_LEN_U;
+
+/* Define the union SRE_GMAC_DEBUG_PKT_PTR_U  addr :0x0344*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved               : 29  ; /* [31..3]  */
+        UINT32    debug_pkt_ptr         : 3   ; /* [2:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_DEBUG_PKT_PTR_U;
+
+/* Define the union SRE_GMAC_DEBUG_EN_U  addr :0x0348*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved               : 31  ; /* [31..1]  */
+        UINT32    debug_en         : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_DEBUG_EN_U;
+
+/* Define the union SRE_GMAC_INTR_STATE_U  addr :0x034c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved                : 25  ; /* [31..7]  */
+        UINT32    back_1588_flag         : 1   ; /* [6]  */
+        UINT32    dbg_grp0_flag           : 1  ; /* [5]  */
+        UINT32    dbg_grp1_flag          : 1   ; /* [4]  */
+        UINT32    dbg_grp0_num           : 2   ; /* [3:2]  */
+        UINT32    dbg_grp1_num           : 2   ; /* [1:0]  */
+
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_INTR_STATE_U;
+
+/* Define the union SRE_GMAC_INTR_CLR_U  addr :0x0350*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved0               : 25  ; /* [31..7]  */
+        UINT32    back_1588_clr         : 1   ; /* [6]  */
+        UINT32    dbg_grp0_clr           : 1  ; /* [5]  */
+        UINT32    dbg_grp1_clr          : 1   ; /* [4]  */
+        UINT32    reserved1              : 4   ; /* [3:0]  */
+
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_INTR_CLR_U;
+
+/* Define the union SRE_GMAC_INTR_MSK_U  addr :0x0354*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved0               : 25  ; /* [31..7]  */
+        UINT32    back_1588_msk         : 1   ; /* [6]  */
+        UINT32    dbg_grp0_msk           : 1  ; /* [5]  */
+        UINT32    dbg_grp1_msk          : 1   ; /* [4]  */
+        UINT32    reserved1              : 4   ; /* [3:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_INTR_MSK_U;
+
+/* Define the union SRE_GMAC_SEQ_ID_U  addr :0x0358*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    seq_id                : 16  ; /* [31..16]  */
+        UINT32    stp_79_to_64         : 16   ; /* [15:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_SEQ_ID_U;
+
+/* Define the union SRE_GMAC_DBG_GRP0_VLD_WORDS_U  addr :0x0364*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    ram0_drop_crc_bytes          : 2  ; /* [31..30]  */
+        UINT32    ram1_drop_crc_bytes         : 2   ; /* [29:28]  */
+        UINT32    ram2_drop_crc_bytes          : 2  ; /* [27..26]  */
+        UINT32    ram3_drop_crc_bytes         : 2   ; /* [25:24]  */
+        UINT32    ram0_vld_word                : 6  ; /* [23..18]  */
+        UINT32    ram1_vld_word               : 6   ; /* [17:12]  */
+        UINT32    ram2_vld_word                : 6  ; /* [11..6]  */
+        UINT32    ram3_vld_word               : 6   ; /* [5:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_DBG_GRP0_VLD_WORDS_U;
+
+/* Define the union SRE_GMAC_DBG_GRP1_VLD_WORDS_U  addr :0x0368*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    ram4_drop_crc_bytes          : 2  ; /* [31..30]  */
+        UINT32    ram5_drop_crc_bytes         : 2   ; /* [29:28]  */
+        UINT32    ram6_drop_crc_bytes          : 2  ; /* [27..26]  */
+        UINT32    ram7_drop_crc_bytes         : 2   ; /* [25:24]  */
+        UINT32    ram4_vld_word                : 6  ; /* [23..18]  */
+        UINT32    ram5_vld_word               : 6   ; /* [17:12]  */
+        UINT32    ram6_vld_word                : 6  ; /* [11..6]  */
+        UINT32    ram7_vld_word               : 6   ; /* [5:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_DBG_GRP1_VLD_WORDS_U;
+
+/* Define the union SRE_GMAC_DMAC_WITH_MSK_EN_U  addr :0x0374*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved                  : 26  ; /* [31..6]  */
+        UINT32    dmac_with_msk_en         : 6   ; /* [5:0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_DMAC_WITH_MSK_EN_U;
+
+/* Define the union SRE_GMAC_TX_LOOP_PKT_PRI_U  addr :0x0378*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved                 : 30 ; /* [31..2]  */
+        UINT32    loop_pkt_en              : 1  ; /* [1]  */
+        UINT32    loop_pkt_hig_pri         : 1  ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_TX_LOOP_PKT_PRI_U;
+
+/***********************************************************
+****************************************************************
+              MAC寄存器的联合体定义END
+***************************************************************
+***************************************************************/
+
+
+/***********************************************************
+****************************************************************
+              系统寄存器的联合体定义
+***************************************************************
+***************************************************************/
+#if 0
+#if (SRE_CPU == SRE_CPU_P600)
+
+typedef union
+{
+    struct
+    {
+        UINT32    temp_trim               :3  ; /* [31..29]  */
+        UINT32    temp_en                 :1  ; /* [28]  */
+        UINT32    trace_out_en            :1  ; /* [27]  */
+        UINT32    mdio_out_en             :1  ; /* [26]  */
+        UINT32    smc_dout_vld_bypass     :1  ; /* [25]  */
+        UINT32    sram_exmon_bypass       :1  ; /* [24]  */
+        UINT32    i2c1_delay_bypass       :1  ; /* [23]  */
+        UINT32    i2c0_delay_bypass       :1  ; /* [22]  */
+        UINT32    normal_mode             :1  ; /* [21]  */
+        UINT32    ss_in_n                 :1  ; /* [20]  */
+        UINT32    ebitimeoutvalue2        :10  ; /* [19..10]  */
+        UINT32    ebitimeoutvalue1        :10  ; /* [9..0]
+  */
+    }bits;
+
+    UINT32    u32;
+
+}SRE_PERCTRL10_U;
+
+#elif(SRE_CPU == SRE_CPU_HI1380)
+
+typedef union
+{
+    struct
+    {
+        UINT32    mem_scan_mode           :1  ; /* [31]  */
+        UINT32    em_w_slice_en           :1  ; /* [30]  */
+        UINT32    sm_cs_7_n_cfg           :1  ; /* [29]  */
+        UINT32    sram_err_clr            :1  ; /* [28]  */
+        UINT32    sram_ecc_err_trans      :1  ; /* [27]  */
+        UINT32    sram_ecc_err_en         :1  ; /* [26]  */
+        UINT32    smc_dout_vld_bypass     :1  ; /* [25]  */
+        UINT32    sram_exmon_bypass       :1  ; /* [24]  */
+        UINT32    i2c1_delay_bypass       :1  ; /* [23]  */
+        UINT32    i2c0_delay_bypass       :1  ; /* [22]  */
+        UINT32    normal_mode             :1  ; /* [21]  */
+        UINT32    ss_in_n                 :1  ; /* [20]  */
+        UINT32    ebitimeoutvalue2        :10  ; /* [19..10]  */
+        UINT32    ebitimeoutvalue1        :10  ; /* [9..0]
+  */
+    }bits;
+
+    UINT32    u32;
+
+}SRE_PERCTRL10_U;
+
+#endif
+#endif
+
+typedef union
+{
+    struct
+    {
+        UINT32    gmac3_rx_srst_req       :1  ; /* [31] gmac3 rx软复位请求  */
+        UINT32    gmac2_rx_srst_req       :1  ; /* [30] gmac2 rx软复位请求  */
+        UINT32    gmac1_rx_srst_req       :1  ; /* [29] gmac1 rx软复位请求  */
+        UINT32    gmac0_rx_srst_req       :1  ; /* [28] gmac0 rx软复位请求  */
+        UINT32    gmac9_eth_srst_req      :1  ; /* [27] gamc 9 eth软复位请求  */
+        UINT32    gmac8_eth_srst_req      :1  ; /* [26] gamc 8 eth软复位请求  */
+        UINT32    gmac7_eth_srst_req      :1  ; /* [25] gamc 7 eth软复位请求  */
+        UINT32    gmac6_eth_srst_req      :1  ; /* [24] gamc 6 eth软复位请求  */
+        UINT32    gmac5_eth_srst_req      :1  ; /* [23] gamc 5 eth软复位请求  */
+        UINT32    gmac4_eth_srst_req      :1  ; /* [22] gamc 4 eth软复位请求  */
+        UINT32    gmac3_eth_srst_req      :1  ; /* [21] gamc 3 eth软复位请求  */
+        UINT32    gmac2_eth_srst_req      :1  ; /* [20] gamc 2 eth软复位请求  */
+        UINT32    gmac1_eth_srst_req      :1  ; /* [19] gamc 1 eth软复位请求  */
+        UINT32    gmac0_eth_srst_req      :1  ; /* [18] gamc 0 eth软复位请求  */
+        UINT32    crc_srst_req            :1  ; /* [17] crc 的软复位请求  */
+        UINT32    uart2_srst_req          :1  ; /* [16] uart2 的软复位请求  */
+        UINT32    uart1_srst_req          :1  ; /* [15] uart1 的软复位请求  */
+        UINT32    uart0_srst_req          :1  ; /* [14] uart0 的软复位请求  */
+        UINT32    gpio1_srst_req          :1  ; /* [13] gpio1 的软复位请求  */
+        UINT32    gpio0_srst_req          :1  ; /* [12] gpio0 的软复位请求  */
+        UINT32    i2c_delay_srst_req      :1  ; /* [11] i2c_delay模块的软复位请求  */
+        UINT32    i2c1_srst_req           :1  ; /* [10] i2c1模块的软复位请求  */
+        UINT32    i2c0_srst_req           :1  ; /* [9] i2c0模块的软复位请求  */
+        UINT32    reserved_0              :1  ; /* [8] 保留  */
+        UINT32    ssp_srst_req            :1  ; /* [7] ssp模块的软复位请求  */
+        UINT32    tdm_srst_req            :1  ; /* [6] TDM软复位请求  */
+        UINT32    pcie0_aux_srst_req      :1  ; /* [5] pcie0 aux软复位请求  */
+        UINT32    reserved_1              :1  ; /* [4] 保留  */
+        UINT32    pcie0_rsyn_srst_req     :1  ; /* [3] pcie0 接收软复位请求  */
+        UINT32    ddrphy_por_srst_req     :1  ; /* [2] ddrphy 上电软复位请求  */
+        UINT32    mddrc_srst_req          :1  ; /* [1] mddrc软复位请求  */
+        UINT32    reserved_2              :1  ; /* [0] 保留  */
+    }bits;
+    UINT32    u32;
+}SRE_PERCTRL6_U;
+
+typedef union
+{
+    struct
+    {
+        UINT32    gmac9_rx125m_srst_req   :1  ; /* [31] gmac9 rx125m软复位请求  */
+        UINT32    gmac8_rx125m_srst_req   :1  ; /* [30] gmac8 rx125m软复位请求  */
+        UINT32    gmac1_rx_srst_req       :2  ; /* [29:28] 保留  */
+        UINT32    clust0_ptm_srst_req     :1  ; /* [27] cluster0 ptm软复位请求  */
+        UINT32    clust1_ptm_srst_req     :1  ; /* [26] cluster1 ptm软复位请求  */
+        UINT32    ssmc_srst_req           :1  ; /* [25] ssmc软复位请求  */
+        UINT32    core_sight_srst_req     :1  ; /* [24] core sight软复位请求  */
+        UINT32    gmac1_rx125m_srst_req   :1  ; /* [23] gmac1 rx125m软复位请求  */
+        UINT32    gmac0_rx125m_srst_req   :1  ; /* [22] gmac0 rx125m软复位请求  */
+        UINT32    gmac9_sys_srst_req      :1  ; /* [21] gamc9 sys软复位请求  */
+        UINT32    gmac8_sys_srst_req      :1  ; /* [20] gamc8 sys软复位请求  */
+        UINT32    gmac7_sys_srst_req      :1  ; /* [19] gamc7 sys软复位请求  */
+        UINT32    gmac6_sys_srst_req      :1  ; /* [18] gamc6 sys软复位请求  */
+        UINT32    gmac5_sys_srst_req      :1  ; /* [17] gamc5 sys软复位请求  */
+        UINT32    gmac4_sys_srst_req      :1  ; /* [16] gamc4 sys软复位请求  */
+        UINT32    gmac3_sys_srst_req      :1  ; /* [15] gamc3 sys软复位请求  */
+        UINT32    gmac2_sys_srst_req      :1  ; /* [14] gamc2 sys软复位请求  */
+        UINT32    gmac1_sys_srst_req      :1  ; /* [13] gamc1 sys软复位请求  */
+        UINT32    gmac0_sys_srst_req      :1  ; /* [12] gamc0 sys软复位请求  */
+        UINT32    gmac7_tx_srst_req       :1  ; /* [11] gmac 7 tx软复位请求  */
+        UINT32    gmac6_tx_srst_req       :1  ; /* [10] gmac 6 tx软复位请求  */
+        UINT32    gmac5_tx_srst_req       :1  ; /* [9] gmac 5 tx软复位请求  */
+        UINT32    gmac4_tx_srst_req       :1  ; /* [8] gmac 4 tx软复位请求  */
+        UINT32    gmac3_tx_srst_req       :1  ; /* [7] gmac 3 tx软复位请求  */
+        UINT32    gmac2_tx_srst_req       :1  ; /* [6] gmac 2 tx软复位请求  */
+        UINT32    gmac1_tx_srst_req       :1  ; /* [5] gmac 1 tx软复位请求  */
+        UINT32    gmac0_tx_srst_req       :1  ; /* [4] gmac 0 tx软复位请求  */
+        UINT32    gmac7_rx_srst_req       :1  ; /* [3] gmac 7 rx软复位请求  */
+        UINT32    gmac6_rx_srst_req       :1  ; /* [2] gmac 6 rx软复位请求  */
+        UINT32    gmac5_rx_srst_req       :1  ; /* [1] gmac 5 rx软复位请求  */
+        UINT32    gmac4_rx_srst_req       :1  ; /* [0] gmac 4 rx软复位请求  */
+    }bits;
+    UINT32    u32;
+}SRE_PERCTRL7_U;
+
+
+/* Define the union SRE_PERCTRL69_U  */
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    Reserved        	    : 12  ; /* [31..20] 保留  */
+        UINT32    gmac_cfg_srst_req    	: 10   ; /*  */
+        UINT32    gmac_macsys_srst_req  : 10   ; /*  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_PERCTRL69_U;
+
+/* BEGIN: Added by h00175571, 2011/11/26   问题单号:P650临时修改 */
+
+/******************************************************************************/
+/*                      MDIO 寄存器结构定义                              */
+/******************************************************************************/
+
+/* Define the union MDIO_COMMAND_REG_U  */
+/* MDIO控制寄存器  */
+/* 0x4  */
+typedef union tagMdioCommandReg
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    Mdio_Devad            : 5   ; /* [4..0] MDIO访问的外部的设备地址。  */
+        unsigned int    Mdio_Prtad            : 5   ; /* [9..5] MDIO访问的外部的端口地址。  */
+        unsigned int    Mdio_Op               : 2   ; /* [11..10] MDIO操作寄存器。          */
+        unsigned int    Mdio_St               : 2   ; /* [13..12] MDIO访问类型寄存器。      */
+        unsigned int    Mdio_Start            : 1   ; /* [14] MDIO启动命令控制字。          */
+        unsigned int    Rsv                   : 17  ; /* [31..15] 保留。                    */
+    } bits;
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} MDIO_COMMAND_REG_U;
+
+/* Define the union MDIO_ADDR_REG_U  */
+/* MDIO间接地址寄存器  */
+/* 0x8  */
+typedef union tagMdioAddrReg
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    Mdio_Address          : 16  ; /* [15..0] 当mdio_st为2’b00时有效，代表要访问的外部某端口某设备的内部寄存器的地址，当mdio_st为其它值时无效。  */
+        unsigned int    Rsv                   : 16  ; /* [31..16] 保留。  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} MDIO_ADDR_REG_U;
+
+/* Define the union MDIO_WDATA_REG_U  */
+/* MDIO写数据寄存器  */
+/* 0xC  */
+typedef union tagMdioWdataReg
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    Mdio_Wdata            : 16  ; /* [15..0] MDIO写访问的写数据。  */
+        unsigned int    Rsv                   : 16  ; /* [31..16] 保留。  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} MDIO_WDATA_REG_U;
+
+/* Define the union MDIO_RDATA_REG_U  */
+/* MDIO读数据寄存器  */
+/* 0x10  */
+typedef union tagMdioRdataReg
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    Mdio_Rdata            : 16  ; /* [15..0] MDIO读访问的读数据。  */
+        unsigned int    Rsv                   : 16  ; /* [31..16] 保留。  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} MDIO_RDATA_REG_U;
+
+/* Define the union MDIO_STA_REG_U  */
+/* MDIO访问状态寄存器  */
+/* 0x14  */
+typedef union tagMdioStaReg
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    Mdio_Sta              : 1   ;   /* [0] MDIO读访问的状态。   */
+        unsigned int    Rsv                   : 31  ;   /* [31..1] 保留。           */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} MDIO_STA_REG_U;
+
+
+/* END:   Added by h00175571, 2011/11/26 */
+/***********************************************************
+****************************************************************
+              系统寄存器的联合体定义END
+***************************************************************
+***************************************************************/
+
+/*
+ * 各个模块错误处理宏定义
+ */
+#define SRE_HIGMAC_ERROR(fmt, arg0, arg1, arg2, arg3, arg...)   \
+    SRE_printf(fmt, arg0, arg1, arg2, arg3, __FUNCTION__, __LINE__, 0, 0, SRE_GetCoreID())
+
+
+
+#endif /* _SRE_GE_INC */
+
diff --git a/drivers/misc/serdes/SRE_ge1.h b/drivers/misc/serdes/SRE_ge1.h
new file mode 100644
index 0000000..c62e3e5
--- /dev/null
+++ b/drivers/misc/serdes/SRE_ge1.h
@@ -0,0 +1,853 @@
+/**
+@file SRE_ge.h
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : SRE_ge.h                               \n
+  版 本 号   : 初稿                                   \n
+  作    者   : w63320                                 \n
+  生成日期   : 2009年8月13日                          \n
+  最近修改   :                                        \n
+  功能描述   : SRE_ge.h 的头文件                       \n
+  函数列表   :                                        \n
+                SRE_SerdesBist                         \n
+                SRE_MdioRead                           \n
+                SRE_MdioReadReg                        \n
+                SRE_MdioWrite                          \n
+                SRE_EnableRx                           \n
+                SRE_EnableTx                           \n
+                SRE_SetPOEEntry                        \n
+                SRE_GmacSetTimeOut                     \n
+                SRE_GmacReqRBuffTimeSet                \n
+                SRE_SetRbuffReqAddr                    \n
+                SRE_PortWorkModeSet                    \n
+                SRE_PortWorkModeGet                    \n
+                SRE_AnModeSet                          \n
+                SRE_AnModeGet                          \n
+                SRE_MaxFrmSizeSet                      \n
+                SRE_MaxFrmSizeGet                      \n
+                SRE_ShortFrmSizeSet                    \n
+                SRE_ShortFrmSizeGet                    \n
+                SRE_ShortFrmPassEn                     \n
+                SRE_ShortFrmPassStatusGet              \n
+                SRE_RxPadStripEn                       \n
+                SRE_RxPadStripStatusGet                \n
+                SRE_TxPadAddEn                         \n
+                SRE_TxPadAddStatusGet                  \n
+                SRE_RxSkipLenSet                       \n
+                SRE_RxSkipLenGet                       \n
+                SRE_LineLoopBackEn                     \n
+                SRE_LineLoopBackDis                    \n
+                SRE_InLoopBackEn                       \n
+                SRE_InLoopBackDis                      \n
+                SRE_SdsLoopBackEn                      \n
+                SRE_SdsLoopBackDis                     \n
+                SRE_GetInLoopBackStatus                \n
+                SRE_GetLineLoopBackStatus              \n
+                SRE_MacAddrFilterSet                   \n
+                SRE_BcPktFiltEn                        \n
+                SRE_McPktFiltEn                        \n
+                SRE_UcNoLocalPktFiltEn                 \n
+                SRE_VlanPktFiltEn                      \n
+                SRE_GmacFilterStatusGet                \n
+                SRE_FilterStatusShow                   \n
+                SRE_MacAddrAdd                         \n
+                SRE_MacAddrDel                         \n
+                SRE_MacAddrShow                        \n
+                SRE_GmacMacAddrQuery                   \n
+                SRE_GmacMainMacAddrSet                 \n
+                SRE_GmacMainMacAddrClr                 \n
+                SRE_GmacMainMacAddrQuery               \n
+                SRE_RxBuffParaSet                      \n
+                SRE_RxBuffParaGet                      \n
+                SRE_PktInBuffFormatSet                 \n
+                SRE_PktInBuffFormatGet                 \n
+                SRE_PktModeSet                         \n
+                SRE_PktModeGet                         \n
+                SRE_PortModeSet                        \n
+                SRE_PortModeGet                        \n
+                SRE_GmacCrcStripEn                     \n
+                SRE_GmacCrcAddEn                       \n
+                SRE_GmacQOSSet                         \n
+                SRE_GmacQOSGet                         \n
+                SRE_GmacGrpSet                         \n
+                SRE_GmacGrpGet                         \n
+                SRE_GmacTagModeSet                     \n
+                SRE_GmacTagModeGet                     \n
+                SRE_GmacTagTypeSet                     \n
+                SRE_GmacTagTypeGet                     \n
+                SRE_TxFifoSet                          \n
+                SRE_RxFifoSet                          \n
+                SRE_RxTxFifoGet                        \n
+                SRE_TxCfgFifoSet                       \n
+                SRE_RxCfgFifoSet                       \n
+                SRE_RxTxCfgFifoGet                     \n
+                SRE_GmacPktMatchSet                    \n
+                SRE_GmacPktMatchGet                    \n
+                SRE_GmacStatisticsShow                 \n
+                SRE_GmacSetAddrMod                     \n
+                SRE_GmacGetAddrMod                     \n
+                SRE_GmacPauseFrmCfg                    \n
+                SRE_GetGmacPauseFrmCfg                 \n
+                SRE_GmacIntStatusShow                  \n
+                SRE_GmacRst                            \n
+                SRE_MdioInit                           \n
+                SRE_SetDuplexType                      \n
+                SRE_GetDuplexType                      \n
+                SRE_SetPortMode                        \n
+                SRE_GetPortMode                        \n
+                SRE_GetAnLinkState                     \n
+                SRE_GetAnSpeed                         \n
+                SRE_SetAnNegInfo                       \n
+                SRE_GetAnNegInfo                       \n
+                SRE_CreateGmacShareVar                 \n
+                SRE_ChangePortMode                     \n
+                SRE_InitGeReg                          \n
+                SRE_ReadGmacStatRegs                   \n
+  修改历史   :                                        \n
+  1.日    期   : 2009年8月13日                        \n
+    作    者   : w63320                               \n
+    修改内容   : 创建文件                             \n
+                                                      \n
+******************************************************************************/
+//#include "SRE_ppe.h"
+
+#ifndef _SRE_GMACAPI_H_
+#define _SRE_GMACAPI_H_
+
+
+#define OS_MID_GMAC 0x42 
+
+/** 本模块错误码定义基址 */
+#define OS_ERRNO_MDIO_ID                        SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x01) /**< MDIO ID错误 */
+#define OS_ERRNO_MDIO_BUSY                      SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x02) /**< MDIO 处于BUSY状态 */
+#define OS_ERRNO_MDIO_READ                      SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x03) /**< MDIO 读错误 */
+#define OS_ERRNO_MDIO_WRITE                     SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x04) /**< MDIO 写错误 */
+#define OS_ERRNO_MDIO_SCAN                      SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x05) /**< MDIO自动检测错误 */
+#define OS_ERRNO_MDIO_PHY_ADDR                  SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x06) /**< PHY地址错误 */
+#define OS_ERRNO_MDIO_SCAN_REG_NUM              SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x07) /**< MDIO模式寄存器地址超出范围 */
+#define OS_ERRNO_MDIO_PHY_ID                    SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x08) /**< PHY ID检测错误 */
+#define OS_ERRNO_MDIO_PHY_REG                   SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x09) /**< PHY REG检测错误 */
+#define OS_ERRNO_MDIO_INPUT_PTR_NULL            SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x0a) /**< 输入指针为NULL检测错误 */
+
+#define OS_ERRNO_GMAC_PORT_ID                   SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x39) /**< GMAC端口号错误 */
+#define OS_ERRNO_GMAC_PKT_LEN_EXCCEED_MAX       SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3A) /**< GMAC报文长度超大 */
+#define OS_ERRNO_GMAC_BUFFER_ALLOC              SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3B) /**< 申请buffer失败 */
+#define OS_ERRNO_GMAC_MSG_PTR                   SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3C) /**< 报文指针为空 */
+#define OS_ERRNO_GMAC_PKT_LEN_ZERO              SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3D) /**< 报文长度为0 */
+#define OS_ERRNO_GMAC_PKT_QOS                   SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3E) /**< 报文QOS错误 */
+#define OS_ERRNO_GMAC_PARA                      SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x3F) /**< 参数非法错误 */
+#define OS_ERRNO_GMAC_MAC_DEL                   SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x40) /**< MAC地址删除失败 */
+#define OS_ERRNO_GMAC_MAC_ADDR_REPEAT           SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x41) /**< MAC 地址重复 */
+#define OS_ERRNO_GMAC_MAC_ADDR_REG_FULL         SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x42) /**< 没有空余的mac地址寄存器 */
+#define OS_ERRNO_GMAC_VALUE_EXCEED_MAX          SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x43) /**< 使能参数非法 */
+#define OS_ERRNO_GMAC_POOL_CFG                  SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x44) /**< GMAC 使用的pool配置错误 */
+#define OS_ERRNO_GMAC_PORT_MODE                 SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x45) /**< GMAC port类型错误错误 */
+#define OS_ERRNO_GMAC_DUPLEX_TYPE               SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x46) /**< GMAC 全双工/半双工模式错误 */
+#define OS_ERRNO_GMAC_LAST_FRAG_NOT_ALIGN       SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x47) /**<  */
+#define OS_ERRNO_GMAC_PLL_LOCK_FAILED           SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x48) /**< Serdes0/1 PLL lock失败 */
+#define OS_ERRNO_GMAC_FRAG_SIZE_TOO_SMALL       SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x49) /**<  */
+#define OS_ERRNO_GMAC_PKT_SHORT_LEN_EXCCEED_MAX SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4A) /**< GMAC超短帧设置错误 */
+#define OS_ERRNO_GMAC_GRP_ID                    SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4B) /**< GMAC组ID设置错误 */
+#define OS_ERRNO_GMAC_CF_RX_BUF_SIZE            SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4C) /**< GMAC接收 buffer size 错误 */
+#define OS_ERRNO_GMAC_FC_TX_TMR                 SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4D) /**< GMAC发送流控时间参数错误 */
+#define OS_ERRNO_GMAC_FC_TX_AUTO                SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4E) /**< GMAC发送流控控制参数错误 */
+#define OS_ERRNO_GMAC_AN_LINK_TIME_ILLEGAL      SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x4F) /**< GMAC自协商链接时间非法 */
+#define OS_ERRNO_GMAC_AN_NOT_COMPLETE           SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x50) /**< GMAC自协商链接未完成 */
+#define OS_ERRNO_GMAC_NULL_PTR                  SRE_ERRNO_OS_ERROR(OS_MID_GMAC, 0x51) /**< 空指针 */
+
+
+
+#define SRE_GMAC_TT_NULL        0
+#define SRE_GMAC_TT_ORDER       1
+#define SRE_GMAC_TT_ATOMIC      2
+
+/** 输入报文格式参数*/
+typedef struct {
+    UINT32 mac_skip_len;        /**< 报文头不进行解析字段长度  */
+    UINT32 mac_skip_crc;       /*'CRC计算是否包含skip区域。0：不包含；1：包含*/
+}SRE_RX_PKT_MODE_CFG_S;
+
+
+
+
+/** 接口类型 */
+typedef enum {
+    GMAC_10M_MII = 0,
+    GMAC_100M_MII,
+    GMAC_1000M_GMII,
+    GMAC_10M_RGMII,
+    GMAC_100M_RGMII,
+    GMAC_1000M_RGMII,
+    GMAC_10M_SGMII,
+    GMAC_100M_SGMII,
+    GMAC_1000M_SGMII,
+    GMAC_10000M_SGMII,          /* 10GE */
+}SRE_PORT_MODE_E;
+
+/** GMAC 端口模式配置 */
+typedef struct {
+    SRE_PORT_MODE_E port_mode;   /**< 端口模式  */
+    UINT32 max_frm_size;        /**< 接收报文的最大帧长  */
+    UINT32 short_runts_thr;     /**< 接收报文的最小帧长  */
+    UINT32 pad_enable;          /**< 发送报文小于最小帧长时自动添加pad使能  */
+    UINT32 crc_add;             /**< 自动添加CRC使能  */
+    UINT32 an_enable;           /**< 自协商使能  */
+    UINT32 runt_pkt_en;         /**< 接收超短帧透传使能  */
+    UINT32 strip_pad_en;        /**< 接收帧自动剥离pad使能  */
+}SRE_PORT_MODE_CFG_S;
+
+
+/** MAC address structure*/
+typedef struct {
+    UINT32 mac_addr_low;        /**< mac地址低32bits  */
+    UINT32 mac_addr_hi;         /**< mac地址高16bits  */
+}SRE_MAC_ADDR_STR_S;
+
+/** MAC address structure 带掩码与不带掩码的地址共用该结构，所以不带掩码的地址的掩码应该配成全1!!! **/
+typedef struct {
+    UINT32 mac_addr_low;        /**< mac地址低32bits  */
+    UINT32 mac_addr_hi;         /**< mac地址高16bits  */
+    UINT32 mac_addr_low_mask;   /**< mac地址低32bits掩码  */
+    UINT32 mac_addr_hi_mask;    /**< mac地址高16bits掩码  */
+}SRE_MAC_MASK_ADDR_STR_S;
+
+
+/** MAC过滤设置结构体*/
+typedef struct {
+    UINT32 crc_err_pass : 1;    /**< CRC 错误报文报告使能  */
+    UINT32 pause_frm_pass : 1;  /**< 流控帧接收使能  */
+    UINT32 bc_drop_en : 1;      /**< 广播帧丢弃使能  */
+    UINT32 mc_match_en : 1;     /**< 非本地组播帧丢弃使能  */
+    UINT32 uc_match_en : 1;     /**< 非本地单播帧丢弃使能  */
+}SRE_MAC_FILTER_CFG_S;
+
+/** 报文头匹配字节掩码表和报文头匹配字节表配置结构体 */
+#define GMAC_PKT_MATCH_TBL_LEN 8
+
+typedef struct {
+    UINT32 cf_match_offset;                     /**< 字符串匹配在报文中的起始偏移  */
+    UINT32 match_msk;                           /**< 报文头匹配字节掩码表  */
+    UINT32 match_tbl[GMAC_PKT_MATCH_TBL_LEN];   /**< 报文头匹配字节表  */
+}SRE_PKT_PATTERN_MATCH_CFG_S;
+
+
+/** Define the union SRE_MIDO_CTROL_U  */
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    mdc_speed             : 2   ; /**<  [1..0]  */
+        unsigned int    autoscan_en           : 1   ; /**<  [2]  */
+        unsigned int    mdio_in_pro_en        : 1   ; /**<  [3]  */
+        unsigned int    mdio_in_pro           : 1   ; /**<  [4]  */
+        unsigned int    Reserved_0            : 27  ; /**<  [31..5]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} SRE_MIDO_CTROL_U;
+
+/** Define the union SRE_MIDO_PHY_TYPE_U  */
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    phy0_is_ge            : 1   ; /**<  [0]  */
+        unsigned int    phy1_is_ge            : 1   ; /**<  [1]  */
+        unsigned int    phy2_is_ge            : 1   ; /**<  [2]  */
+        unsigned int    phy3_is_ge            : 1   ; /**<  [3]  */
+        unsigned int    phy4_is_ge            : 1   ; /**<  [4]  */
+        unsigned int    Reserved_0            : 27  ; /**<  [31..5]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} SRE_MIDO_PHY_TYPE_U;
+
+/** Define the union SRE_MDIO_AUTOSCAN_PHY_ADDR_U  */
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        unsigned int    autoscan_phy_addr     : 5   ; /**<  [4..0]  */
+        unsigned int    Reserved_0            : 27  ; /**<  [31..5]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    unsigned int    u32;
+
+} SRE_MDIO_AUTOSCAN_PHY_ADDR_U;
+
+/** 全双工，半双工枚举定义 */
+typedef enum tagDuplexType
+{
+    SRE_HALF_DUPLEX_MODE = 0,    /**< 0: 半双工 */
+    SRE_FULL_DUPLEX_MODE         /**< 1：全双工  */
+}SRE_DUPLEX_TYPE_E;
+
+/** 自协商速度枚举定义 */
+typedef enum tagAnNegSpeed
+{
+    SRE_AN_NEG_10M = 0,
+    SRE_AN_NEG_100M,
+    SRE_AN_NEG_1000M
+}SRE_AN_NEG_SPEED_E;
+
+#define MAX_VLAN_QOS_LEVEL 8
+#define MAX_DSCP_QOS_LEVEL 64
+
+
+/*qos生成模式设置*/
+typedef struct {
+    UINT32    arp_qos ;         /*arp报文的qos  */
+    UINT32    rarp_qos;         /*rarp报文的qos  */
+    UINT32    mul_qos;          /*组播报文的qos  */
+    UINT32    brc_qos ;         /*广播报文的qos  */
+    UINT32    icmp_qos;         /*icmp报文的qos  */
+    UINT32    tcp_qos ;         /*tcp报文的qos  */
+    UINT32    udp_qos;          /*udp报文的qos  */
+    UINT32    ip_qos ;          /*ip报文的qos  */
+    UINT32    oth_qos ;         /*其他报文的qos  */
+}SRE_QOS_PKTTYPE_MODE_CFG;
+
+#if 0
+typedef struct tagMcQosModeCfg
+{
+    SRE_PPE_QOS_MODE_E    qos_mode;    /*qos的生成模式：  */
+    UINT32    port_qos;               /*寄存器指定模式下该端口的qos  */
+}SRE_QOS_MODE_CFG_S;
+
+typedef struct tagMcGrpIndexModeCfg
+{
+    UINT32 group_offset;        /*报文的指定偏移  */
+    UINT32 group_mask;          /*Key值掩码  */
+}SRE_GRP_INDEX_MODE_CFG_S;
+
+/*group的生成模式设置*/
+typedef struct tagMcGrpMatchModeCfg
+{
+    UINT32 grp_offset;          /*grp_mode为11b从报文取数据的偏移量  */
+    UINT32 rx_grp_msk;          /*group匹配字节掩码表  */
+    UINT64 rx_grp_tbl[32];      /*group匹配表项  */
+    UINT32 rx_grp_result[32];    /*匹配结果寄存器，匹配表项0-7的group值  */
+    UINT32 def_grp_res;         /*grp_mode为11b时无匹配结果的默认值  */
+}SRE_GRP_MATCH_MODE_CFG_S;
+
+typedef struct tagMcGrpPkttypeModeCfg
+{
+    UINT32    arp_grp ;         /*arp报文的grp  */
+    UINT32    rarp_grp;         /*rarp报文的grp  */
+    UINT32    mul_grp;          /*组播报文的grp  */
+    UINT32    brc_grp ;         /*广播报文的grp  */
+    UINT32    icmp_grp;         /*icmp报文的grp  */
+    UINT32    tcp_grp ;         /*tcp报文的grp  */
+    UINT32    udp_grp;          /*udp报文的grp  */
+    UINT32    ip_grp ;          /*ip报文的grp  */
+    UINT32    oth_grp ;         /*其他报文的grp  */
+}SRE_GRP_PKTTYPE_MODE_CFG_S;
+
+typedef struct tagMcGrpModeCfg
+{
+    SRE_PPE_GRP_MODE_E grp_mode; /**< group生成模式：  */
+    UINT32 port_grp;            /**< group生成模式为端口指定时的端口group号  */
+    UINT32 port_vmid;           /**< group生成模式为端口指定时的端口vmid号  */
+}SRE_GRP_MODE_CFG_S;
+
+typedef struct tagMcTagPktParseModeCfg
+{
+    UINT32 tag_msk_port_src;    /**< 源tcp/udp报文的端口号是否参加解析掩码  */
+    UINT32 tag_msk_port_dst;    /**< 目的 tcp/udp报文的端口号是否参加解析掩码  */
+    UINT32 tag_msk_ip_src;      /**< ip源地址是否参加解析掩码  */
+    UINT32 tag_msk_ip_dst;      /**< ip目的地址是否参加解析掩码  */
+    UINT32 tag_msk_ip_prot;     /**< 协议类型是否参加解析掩码  */
+    UINT32 default_tag;
+}SRE_TAG_PKT_PARSE_MODE_CFG_S;
+
+typedef struct tagMcTagPatternModeCfg
+{
+    UINT32 tag_offset;          /**< 提取方式下，提取的首字节在报文中的偏移  */
+    UINT32 tag_mask_0;          /**< tag_mode为从报文中计算时，需要计算的字节掩码  */
+    UINT32 tag_mask_1;          /**< tag_mode为从报文中计算时，需要计算的字节掩码  */
+}SRE_TAG_PATTERN_MODE_CFG_S;
+
+typedef struct tagMcTagModeCfg
+{
+    SRE_PPE_TAG_LO_MODE_E tag_lo_mode;                   /* tag的低16位生成模式：  */
+    SRE_PPE_TAG_HI_MODE_E tag_hi_mode;                   /* tag的低8位生成模式：  */
+    union
+    {
+        UINT32 def_tag;
+        SRE_PPE_TAG_MSK_INFO_S tag_msk_info;
+    };
+}SRE_TAG_MODE_CFG_S;
+
+typedef enum {
+    SRE_PKT_PARSE_TT = 0,        /*0为由报文解析生成;  */
+    SRE_PORT_TT                  /*1为由寄存器配置  */
+}SRE_TT_MODE;
+
+/*配置tag type生成模式结构体*/
+typedef struct {
+    SRE_PPE_TT_MODE_E tt_mode;         /*tag type的生成模式:  */
+    UINT32 def_tt;              /*寄存器配置模式下的tt类型  */
+}SRE_TAGTYPE_MODE_CFG_S;
+
+
+/** GMAC配置结构体 */
+typedef struct tagGmacCfg
+{
+    UINT32 uwGmacBigPool;       /**< gmac使用的大pool*/
+    SRE_PORT_MODE_E enPortMode;
+    UINT32 uwMaxFrmSize;        /* 单位是字节 */
+    UINT32 uwRuntsThr;          /**<  接收报文的最小帧长 */
+    SRE_QOS_MODE_CFG_S stQosMode;
+    SRE_GRP_MODE_CFG_S stGrpMode;
+    SRE_TAG_MODE_CFG_S stTagModeCfg;
+    SRE_TAGTYPE_MODE_CFG_S stTtModeCfg;
+}SRE_GMAC_CFG_S;
+
+/** PPE FIFO配置结构体 */
+typedef struct tagPpeFifoCfg
+{
+    UINT32 uwGroupIdMask;
+}SRE_PPE_FIFO_CFG_S;
+#endif
+
+typedef struct tagMcGmacStat
+{
+    UINT32 uwrx_octets_total_ok_cnt;
+    UINT32 uwrx_octets_bad_cnt;
+    UINT32 uwrx_uc_pkts_cnt;
+    UINT32 uwrx_mc_pkts_cnt;
+    UINT32 uwrx_bc_pkts_cnt;
+    UINT32 uwrx_vlan_pkt_cnt;
+    UINT32 uwrx_fw_ctrl_frame_cnt;
+    UINT32 uwrx_octets_total_filt_cnt;
+    UINT32 uwrx_filt_pkt_cnt;
+    UINT32 uwrx_framsize_64;
+    UINT32 uwrx_framsize_65_127;
+    UINT32 uwrx_framsize_128_255;
+    UINT32 uwrx_framsize_256_511;
+    UINT32 uwrx_framsize_512_1023;
+    UINT32 uwrx_framsize_1024_1518;
+    UINT32 uwrx_framsize_bt_1518;
+    UINT32 uwrx_fcs_error_cnt;
+    UINT32 uwrx_data_error_cnt;
+    UINT32 uwrx_align_error_cnt;
+    UINT32 uwrx_frame_long_err_cnt;
+    UINT32 uwrx_frame_very_long_err_cnt;
+    UINT32 uwrx_frame_runt_err_cnt;
+    UINT32 uwrx_frame_short_err_cnt;
+    UINT32 uwrx_overrun_cnt;
+    UINT32 uwtx_octets_total_ok_cnt;
+    UINT32 uwtx_octets_bad_cnt;
+    UINT32 uwtx_uc_pkts_cnt;
+    UINT32 uwtx_mc_pkts_cnt;
+    UINT32 uwtx_bc_pkts_cnt;
+    UINT32 uwtx_vlan_pkt_cnt;
+    UINT32 uwtx_fw_ctrl_frame_cnt;
+    UINT32 uwtx_framsize_64;
+    UINT32 uwtx_framsize_65_127;
+    UINT32 uwtx_framsize_128_255;
+    UINT32 uwtx_framsize_256_511;
+    UINT32 uwtx_framsize_512_1023;
+    UINT32 uwtx_framsize_1024_1518;
+    UINT32 uwtx_framsize_bt_1518;
+    UINT32 uwtx_fcs_error_cnt;
+    UINT32 uwtx_underrun_err_cnt;
+    UINT32 uwtx_excessive_drop_cnt;
+}SRE_GMAC_STAT_S;
+
+ /* Define the union SRE_GMAC_TX_LOCAL_PAGE_U  addr :0x5c*/
+typedef union
+{
+    /* Define the struct bits  */
+    struct
+    {
+        UINT32    reserved0                : 16  ; /* [31..16]  */
+        UINT32    cfg_15bit               : 1   ; /* [15]  */
+        UINT32    reserved1                : 1   ; /* [14]  */
+        UINT32    cfg_13_12bit            : 2   ; /* [13..12]  */
+        UINT32    reserved2                : 3  ; /* [11..9]  */
+        UINT32    cfg_8_5bit              : 4   ; /* [8:5]  */
+        UINT32    reserved3                : 4   ; /* [4:1]  */
+        UINT32    cfg_0bit                : 1   ; /* [0]  */
+    } bits;
+
+    /* Define an unsigned member  */
+    UINT32    u32;
+
+} SRE_GMAC_TX_LOCAL_PAGE_U;
+
+typedef struct SRE_FRAG_PTR_STRU
+{
+    UINT32 back:7;      /**< 数据包下一块缓存中，数据指针所在cache line距缓存头部的cache line个数*/
+    UINT32 pool:4;      /**< 数据包下一块缓存从BMU分配时的pool号*/
+    UINT32 reserve:5;
+    UINT32 size:16;     /**< 数据包下一块缓存中有效数据的长度，单位为字节*/
+    UINT32 bufferAddr;  /**< 下一缓存物理地址*/
+}SRE_FRAG_PTR;
+
+#if 0
+/** GMAC配置结构体 */
+typedef struct tagGmacCfg
+{
+    UINT32 uwGmacSmallPool;     /**< gmac使用的小pool*/
+    UINT32 uwGmacBigPool;       /**< gmac使用的大pool*/
+    SRE_PORT_MODE_E enPortMode;
+    UINT32 uwMaxFrmSize;
+    UINT32 uwRuntsThr;          /**<  接收报文的最小帧长 */
+    SRE_QOS_MODE_CFG_S stQosMode;
+    SRE_GRP_MODE_CFG_S stGrpMode;
+    SRE_TAG_MODE_CFG_S stTagModeCfg;
+    SRE_TAGTYPE_MODE_CFG_S stTtModeCfg;
+    SRE_ADDR_MODE enAddrMode;    /**< 地址生成模式，如果选择为地址过滤模式，硬件则默认过滤的报文GMAC走ClusterB */
+    SRE_GMAC_FILTER_ADDR_U unGmacFilterAddr;
+}SRE_GMAC_CFG_S;
+#endif
+
+/* GMAC收上来的包分发到哪个Cluster  */
+#define  SRE_GMAC_USA_CLUSTERA      (0) /**< GMAC收上来的包分发到Cluster A */
+#define  SRE_GMAC_USA_CLUSTERB      (1) /**< GMAC收上来的包分发到Cluster B */
+
+#define SRE_POE_PHY_REG_BASE_ADDR    0x33050000      /**< POE寄存器地址基址 */
+#define SRE_BMU_PHY_REG_BASE_ADDR    0x33040000      /**< BMU寄存器地址基址 */
+#define SRE_GMAC_PHY_REG_BASE_ADDR  0x08400000UL      /**< GMAC寄存器地址基址 */
+#define SRE_POU_PHY_REG_BASE_ADDR    0x100d0000      /**< POU寄存器地址基址 */
+
+#define SRE_GMAC_REG_ADDR_LEN    0x10000UL
+#define SRE_MDIO_REG_ADDR_LEN    0x10000
+
+#define SRE_MDIO_PHY_GRP_LEN       0x100
+#define SRE_MDIO_REG_LEN       0x10
+
+#define SRE_POE_ADD_PACKET_0_OFST       0x080
+#define SRE_POE_ADD_PACKET_1_OFST       0x084
+#define SRE_POE_ADD_PACKET_2_OFST       0x088
+#define SRE_POE_ADD_PACKET_3_OFST       0x08c
+
+#define SRE_MAC_ADDR_NUM                     6UL    /* GE 本地的mac地址个数，包括2个mc，4个uc */
+#define SRE_MAC_ADDR_MSK_NUM                 2UL    /* GE 本地的2个mc对应的掩码 */
+#define SRE_MDIO_PHY_ADDR_NUM        5
+#define SRE_GMAC_IP_QOS_REG_NUM      8
+#define SRE_MDIO_AUTOSCAN_REG_NUM    8
+#define SRE_GMAC_MAX_PORT_NUM        8UL
+
+#define SRE_GE_MAX_BUSINESS_PORT_NUM      9UL
+//wugao_test 方便操作业务网口对应的 ppe通道 和 ge
+//#define SRE_GE_MAX_BUSINESS_PORT_NUM      12UL
+
+
+#define SRE_GE8_PORT_NUM                       8UL
+#define SRE_GE9_PORT_NUM                       9UL
+#define SRE_GE10_PORT_NUM                     10UL
+#define SRE_GE_MAC_ADDR_MSK_MAX            0x3fUL
+
+#define SRE_ADDR_FIL_MSK              0xfff00000
+
+#define GMAC_REG(port, offset)            ( SRE_GMAC_BASE_ADDR + ( port) * SRE_GMAC_REG_ADDR_LEN + ( offset ) )
+#define MDIO_REG(mdio_id, offset)            ( SRE_MDIO_BASE_ADDR + ( mdio_id) * SRE_MDIO_REG_ADDR_LEN + ( offset ) )
+
+
+/* define for PHY 88E1145 begin */
+#define SRE_GMAC_PHY_ID_88E1145         0x01410cd0
+#define SRE_GMAC_PHY_ID_88E1145_MSK     0xffffff00
+
+/* define for PHY 88E1145 begin */
+#define SRE_GMAC_PHY_ID_5482             0x0143bcb2
+#define SRE_GMAC_PHY_ID_5482_MSK         0xffffff00
+
+/* Phy registers */
+#define SRE_GMAC_PHY_CTRL_REG                0x00    /**< MII Control Register : r/w */
+#define SRE_GMAC_PHY_STAT_REG                0x01    /**< MII Status Register: ro */
+#define SRE_GMAC_PHY_PHY_ID0_REG             0x02    /**< MII PHY ID register: ro */
+#define SRE_GMAC_PHY_PHY_ID1_REG             0x03    /**< MII PHY ID register: ro */
+#define SRE_GMAC_PHY_ANA_REG                 0x04    /**< MII Auto-Neg Advertisement: r/w */
+#define SRE_GMAC_PHY_ANP_REG                 0x05    /**< MII Auto-Neg Link Partner: ro */
+#define SRE_GMAC_PHY_AN_EXP_REG              0x06    /**< MII Auto-Neg Expansion: ro */
+#define SRE_GMAC_PHY_NTPG_TRANS_REG          0X07    /**< NEXT PAGE Transmit Reg: r/w */
+#define SRE_GMAC_PHY_PART_NTPG_TRANS_REG     0X08    /**< NEXT PAGE Transmit Reg: r/w */
+#define SRE_GMAC_PHY_GB_CTRL_REG             0x09    /**< MII 1000Base-T control register */
+#define SRE_GMAC_PHY_GB_STAT_REG             0x0a    /**< MII 1000Base-T Status register ro*/
+#define SRE_GMAC_PHY_ESR_REG                 0x0f    /**< MII Extended Status register ro*/
+/* Non-standard MII Registers */
+#define SRE_GMAC_PHY_SCR_REG                 0x10    /**< MII Specific Control Register */
+#define SRE_GMAC_PHY_SPEC_STATUS_REG         0x11    /**< MII Specific status register*/
+#define SRE_GMAC_PHY_INT_ENABLE_REG          0x12    /**< MII Interrupt Enable register*/
+#define SRE_GMAC_PHY_INT_STATUS_REG          0x13    /**< MII Interrupt status register*/
+#define SRE_GMAC_PHY_EXT_SCR_REG             0x14    /**< MII Extended PHY Specific Control register*/
+#define SRE_GMAC_PHY_EXT_ADDR_REG            0x16    /**< MII Extended Address Register*/
+#define SRE_GMAC_PHY_EXT_SCR2_REG            0x1a    /**< MII Extended PHY Specific Control 2 register*/
+#define SRE_GMAC_PHY_EXT_SSTATUS_REG         0x1b    /**< MII Extended PHY Specific Status register*/
+#define SRE_GMAC_PHY_MULTIPAGE_28_REG        0x1c    /**< MII Multipage Register 28*/
+#define SRE_GMAC_PHY_EXT_ADDR2_REG           0x1d    /**< MII Extended Address Register 2*/
+#define SRE_GMAC_PHY_MULTIPAGE_30_REG        0x1e    /**< MII Multipage Register 30*/
+
+/** register value define*/
+#define SRE_RGMII_TO_COPPER_88E1145     0x0b
+
+#define MDIO_TIMEOUT  1000 /* 读操作的超时周期，单位50us  */
+
+#define GMAC_MDIOBUS_PORT    0
+#define GMAC_MDIOBUS_NAME   "pv650_mdio"
+#define MDIO_OK              0
+#define MDIO_ERROR           0xffffffff
+
+/* 表示的是clause 22  */
+#define MDIO_ST_CLAUSE_22           (0x01)
+
+/* 定义MDIO clause 22的操作  */
+#define MDIO_CLAUSE_22_READ         (0x02)
+#define MDIO_CLAUSE_22_WRITE        (0x01)
+
+#define MDIO_REG_ADDR_LEN            0x1000
+#define MDIO_PHY_GRP_LEN             0x100
+#define MDIO_REG_LEN                 0x10
+#define MDIO_PHY_ADDR_NUM            5
+#define MDIO_MAX_PHY_ADDR            0x1F   /* 每个clause 22 MDIO下面最多只有32个PHY  */
+#define MDIO_MAX_PHY_REG_ADDR        0x1F   /* Clause45 MDIO支持的PHY寄存器偏移地址最多只到0x1F  */
+
+#define MDIO_REG_ADDR(port, offset)      (MDIO_BASE_ADDR + (port) * MDIO_REG_ADDR_LEN + (offset))
+
+#define MDIO_REG_READ(port,offset,data)  \
+        ( (data) = OS_READ_REG(MDIO_REG_ADDR(port, offset), 0))
+
+#define MDIO_REG_WRITE(port,offset,data)  \
+        (OS_WRITE_REG(MDIO_REG_ADDR(port, offset), 0, data))
+
+
+/* define for PHY 88E1145 end */
+
+/* macros for accessing GMAC's register */
+#define SRE_GMAC_WRITE_REG(port,offset,data)     (OS_WRITE_REG( GMAC_REG(port, offset), 0, data ))
+#define SRE_GMAC_READ_REG(port,offset,data)      ( (data) = OS_READ_REG(GMAC_REG(port, offset), 0))
+
+#define SRE_MDIO_REG_WRITE(mdio_id,offset,data)  (OS_WRITE_REG( MDIO_REG(mdio_id, offset ), 0, data ))
+#define SRE_MDIO_REG_READ(mdio_id,offset,data)   ( (data) = OS_READ_REG( MDIO_REG(mdio_id, offset ), 0 ))
+
+/* 不带掩码的本地station address */
+#define SRE_MAC_SA_LOW_REG(addr_id)              ( SRE_GMAC_STATION_ADDR_LOW_0_REG + (( addr_id )* 0x8 ))
+#define SRE_MAC_SA_HIGH_REG(addr_id)             ( SRE_GMAC_STATION_ADDR_HIGH_0_REG + (( addr_id ) * 0x8 ))
+
+/* 带掩码的本地station address,定义同不带掩码的一样 */
+#define SRE_MAC_SA_MSK_LOW_REG(addr_id)          ( SRE_GMAC_STATION_ADDR_LOW_0_REG + (( addr_id )* 0x8 ))
+#define SRE_MAC_SA_MSK_HIGH_REG(addr_id)         ( SRE_GMAC_STATION_ADDR_HIGH_0_REG + (( addr_id ) * 0x8 ))
+
+#define SRE_MAC_ADDR_LOW_MSK_REG(addr_id)        ( SRE_GMAC_STATION_ADDR_LOW_MSK_0_REG + (( addr_id )* 0x8 ))
+#define SRE_MAC_ADDR_HI_MSK_REG(addr_id)         ( SRE_GMAC_STATION_ADDR_HIGH_MSK_0_REG + (( addr_id ) * 0x8 ))
+
+#define SRE_MDIO_PHY_ADDR_REG(phy_id)            (SRE_MDIO_PHY0_ADDR_REG +(phy_id)* 4)
+
+extern UINT32 SRE_AnModeGet(UINT32 uwPort, UINT32 *pEnable);
+extern UINT32 SRE_AnModeSet(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_BcPktFiltEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_ChangePortMode(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType, SRE_PORT_MODE_E enPortMode);
+extern UINT32 SRE_InitGeReg(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType, SRE_PORT_MODE_E enPortMode);
+extern UINT32 SRE_CheckGmacPortCfg(UINT32 uwPort);
+extern UINT32 SRE_CheckPerfMonitorCfg(void);
+extern UINT32 SRE_GeEnableRx( UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_GeEnableTx(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_FilterStatusShow(UINT32 uwPort);
+extern UINT32 SRE_GeEnLocalMacAddr( UINT32 uwPort, UINT32 uwMacAddrEn );
+extern UINT32 SRE_GeEnLocalMacAddrMask( UINT32 uwPort, UINT32 uwMacAddrEn );
+extern UINT32 SRE_GetAnLinkState(UINT32 uwPort, UINT32 *puwLinkState);
+extern UINT32 SRE_GetAnNegInfo(UINT32 uwPort, SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo);
+extern UINT32 SRE_GetAnSpeed(UINT32 uwPort, SRE_AN_NEG_SPEED_E *penAnSpeed);
+extern UINT32 SRE_GetDuplexType(UINT32 uwPort, SRE_DUPLEX_TYPE_E *penDuplexType);
+extern UINT32 SRE_GetFcTxTmr(UINT32 uwPort, UINT32 *puwFcTxTmr);
+extern UINT32 SRE_GetGmacPauseFrmCfg(UINT32 uwPort, UINT32 *puwRxPauseEn, UINT32 *puwTxPauseEn);
+extern UINT32 SRE_GetInLoopBackStatus(UINT32 uwPort, UINT32* puwLoopBackStatus);
+extern UINT32 SRE_GetLineLoopBackStatus(UINT32 uwPort, UINT32* puwLoopBackStatus);
+extern UINT32 SRE_GetPortMode(UINT32 uwPort, SRE_PORT_MODE_E *penPortMode);
+extern UINT32 SRE_GmacCrcAddEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_GmacCrcStripEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_GmacFilterStatusGet(UINT32 uwPort, SRE_MAC_FILTER_CFG_S *pMacFilter);
+extern UINT32 SRE_GmacMacAddrQuery(UINT32 uwPort, UINT32 *uwMacNum, SRE_MAC_MASK_ADDR_STR_S *pstMacAddr);
+extern UINT32 SRE_GmacMainMacAddrClr(UINT32 uwPort);
+extern UINT32 SRE_GmacMainMacAddrQuery(UINT32 uwPort, SRE_MAC_MASK_ADDR_STR_S *pstMacAddr);
+extern UINT32 SRE_GmacMainMacAddrSet(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstMacAddr);
+extern UINT32 SRE_GmacPauseFrmCfg(UINT32 uwPort, UINT32 uwRxPauseEn, UINT32 uwTxPauseEn);
+extern UINT32 SRE_GmacReadPhy(UINT32 uwMdioId, UINT32 uwPhyAddr, UINT32 uwPhyRegNum,
+             UINT32 uwShadow);
+extern UINT32 SRE_GmacRst(UINT32 uwGmacId);
+extern UINT32 SRE_GmacStatisticsShow(UINT32 uwPort);
+extern UINT32 SRE_GeShowShareUcMacCfg(void);
+extern UINT32 SRE_InLoopBackDis(UINT32 uwPort);
+extern UINT32 SRE_InLoopBackEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_InputModeSet(UINT32 uwPort, UINT32 uwMacSkip, UINT32 uwSkipCrc);
+extern UINT32 SRE_LineLoopBackDis(UINT32 uwPort);
+extern UINT32 SRE_LineLoopBackEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_MacAddrAdd(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstMacAddr);
+extern UINT32 SRE_MacAddrDel(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstMacAddr);
+extern UINT32 SRE_MacAddrFilterSet(UINT32 uwPort, const SRE_MAC_FILTER_CFG_S *pMacFilter);
+extern UINT32 SRE_MacAddrShow(UINT32 uwPort);
+extern UINT32 SRE_MaxFrmSizeGet(UINT32 uwPort, UINT32 *pFramSize);
+extern UINT32 SRE_MaxFrmSizeSet(UINT32 uwPort, UINT32 uwFramSize);
+extern UINT32 SRE_McPktFiltEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_MdioGetPhyReadVal( UINT32 uwMdioID);
+extern void SRE_MdioPhyWrite(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 uwWriteValue);
+extern UINT32 SRE_MdioRead(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 *puwRegValue);
+extern UINT32 SRE_MdioReadReg(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum,
+             UINT32 *pRegValue);
+extern void SRE_MdioStartPhyRead(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum);
+extern UINT32 SRE_MdioWrite(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 uwWriteValue);
+extern void SRE_PerfMonitor(void);
+extern void SRE_PerfMonitorInit(void);
+extern UINT32 SRE_PktModeGet(UINT32 uwPort, SRE_RX_PKT_MODE_CFG_S *pstRxPktMode);
+extern UINT32 SRE_PktModeSet(UINT32 uwPort, const SRE_RX_PKT_MODE_CFG_S *pstRxPktMode);
+extern UINT32 SRE_PortModeGet(UINT32 uwPort, SRE_PORT_MODE_CFG_S *pstPortMode);
+extern UINT32 SRE_PortModeSet(UINT32 uwPort, const SRE_PORT_MODE_CFG_S *pstPortMode);
+extern UINT32 SRE_PortWorkModeGet(UINT32 uwPort, SRE_PORT_MODE_E *pMode);
+extern UINT32 SRE_PortWorkModeSet(UINT32 uwPort, SRE_PORT_MODE_E enPortMode);
+extern UINT32 SRE_ReadGmacStatRegs(SRE_GMAC_STAT_S *pstGmacStatInfo);
+extern UINT32 SRE_RxPadStripEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_RxPadStripStatusGet(UINT32 uwPort, UINT32 *pEnValue);
+extern UINT32 SRE_RxSkipLenGet(UINT32 uwPort, UINT32 *pSkipLen);
+extern UINT32 SRE_RxSkipLenSet(UINT32 uwPort, UINT32 uwSkipLen);
+extern UINT32 SRE_SdsLoopBackDis(UINT32 uwPort);
+extern UINT32 SRE_SdsLoopBackEn(UINT32 uwPort);
+extern UINT32 SRE_SdsOutLoopBackDis(UINT32 uwPort,UINT32 mode);
+extern UINT32 SRE_SdsOutLoopBackEn(UINT32 uwPort,UINT32 mode);
+extern UINT32 SRE_SerdesBist(UINT32 uwPort);
+extern UINT32 SRE_SetAnNegInfo(UINT32 uwPort, SRE_GMAC_TX_LOCAL_PAGE_U *punAnNegInfo);
+extern UINT32 SRE_SetDuplexType(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType);
+extern UINT32 SRE_SetFcTxTmr(UINT32 uwPort, UINT32 uwFcTxTmr);
+extern void SRE_SetGpio(void);
+extern UINT32 SRE_SetPortMode(UINT32 uwPort, SRE_PORT_MODE_E enPortMode);
+extern UINT32 SRE_ShortFrmPassEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_ShortFrmPassStatusGet(UINT32 uwPort, UINT32 *pEnValue);
+extern UINT32 SRE_ShortFrmSizeGet(UINT32 uwPort, UINT32 *pFramSize);
+extern UINT32 SRE_ShortFrmSizeSet(UINT32 uwPort, UINT32 uwFramSize);
+extern UINT32 SRE_TxPadAddEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_TxPadAddStatusGet(UINT32 uwPort, UINT32 *pEnValue);
+extern UINT32 SRE_UcNoLocalPktFiltEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_UpdateAnLinkTime(UINT32 uwPort, UINT32 uwAnLinkTime);
+
+extern UINT32 SRE_GeFpgaAdapt(UINT32 uwPort);
+extern UINT32 SRE_GeEnableTx(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_GeFpgaAdapt(UINT32 uwPort);
+extern UINT32 SRE_GeRstDreq(VOID);
+extern UINT32 SRE_InLoopBackEn(UINT32 uwPort, UINT32 uwEnValue);
+extern UINT32 SRE_InitGeReg(UINT32 uwPort, SRE_DUPLEX_TYPE_E enDuplexType, SRE_PORT_MODE_E enPortMode);
+extern UINT32 SRE_MacAddrAdd(UINT32 uwPort, const SRE_MAC_MASK_ADDR_STR_S *pstrMacAddr);
+extern UINT32 SRE_MacAddrFilterSet(UINT32 uwPort, const SRE_MAC_FILTER_CFG_S *pMacFilter);
+
+/*****************************************************************************
+ 函 数 名  : SRE_GeResetDreq
+ 功能描述  : GE软复位去请求接口
+ 输入参数  : void
+*****************************************************************************/
+extern UINT32 SRE_GeRstDreq(void);
+
+/* add by z00200342 2012/12/21: 将SRE_NET_DRV_SHARE_S定义移至此处，去除ge对SRE_netdrv.h的依赖 */
+
+/** 记录端口的配置信息*/
+typedef struct {
+    UINT32 bytealign;
+    UINT32 skip1;
+    UINT32 skip2;
+    UINT32 buffsize;
+}SRE_PORT_CFG_INFO_S;
+
+
+/** NetDrv 模块共享数据结构体 */
+typedef struct tagSreNetDrvShare
+{
+    volatile SRE_PORT_CFG_INFO_S astSreGmacPortCfgInfo[SRE_GMAC_MAX_PORT_NUM];/**< 记录端口的配置信息 */
+    volatile UINT32 auwSreGmacMaxFrmSize[SRE_GMAC_MAX_PORT_NUM];/**< 包大小 */
+}SRE_NET_DRV_SHARE_S;
+/* end add */
+
+
+
+// ============================================ phy ====================================//
+#if 0
+#define SRE_PHY_ERROR(fmt, arg...)      OS_DBG_PRINT(fmt, ##arg)
+
+#define MARVELL1512_ID  0x01410dd0
+
+#define MAR_PHY_MAX_ADDR 0x1F
+
+#define PHY_SPEED_10M        0
+#define PHY_SPEED_100M       1
+#define PHY_SPEED_1000M      2
+
+#define PHY_LINK_UNKNOW      2
+#define PHY_LINK             1
+#define PHY_UNLINK           0
+#define PHY_LOOP             1
+#define PHY_UNLOOP           0
+
+#define PHY_AUTONEG_ENABLE   1
+#define PHY_AUTONEG_DISABLE  0
+
+
+/* Standard MII Registers */
+#define MII_CTRL_REG            0x00    /* MII Control Register : r/w */
+#define MII_STAT_REG            0x01    /* MII Status Register: ro */
+#define MII_PHY_ID0_REG         0x02    /* MII PHY ID register: r/w */
+#define MII_PHY_ID1_REG         0x03    /* MII PHY ID register: r/w */
+#define MII_ANA_REG             0x04    /* MII Auto-Neg Advertisement: r/w */
+#define MII_ANP_REG             0x05    /* MII Auto-Neg Link Partner: ro */
+#define MII_AN_EXP_REG          0x06    /* MII Auto-Neg Expansion: ro */
+#define MII_GB_CTRL_REG         0x09    /* MII 1000Base-T control register */
+#define MII_GB_STAT_REG         0x0a    /* MII 1000Base-T Status register */
+#define MII_SGB_CTRL_REG        0x0b    /* SGMII/1000-X Control Register */
+#define MII_ESR_REG             0x0f    /* MII Extended Status register */
+
+/* Non-standard MII Registers */
+
+/*page any*/
+#define MII_PAGE_ADDR_REG          0x16
+
+/*page 0*/
+#define MII_COPPER_SPEC_CTRL_1     0x10
+#define MII_COPPER_SPEC_STATUS_1   0x11
+
+/*page 2*/
+#define MII_MAC_SPEC_CTRL_2        0x15
+
+/* MII Control Register: bit definitions */
+
+#define MII_CTRL_SS_MSB         (1 << 6)  /* Speed select, MSb */
+#define MII_CTRL_CST            (1 << 7)  /* Collision Signal test */
+#define MII_CTRL_FD             (1 << 8)  /* Full Duplex */
+#define MII_CTRL_RAN            (1 << 9)  /* Restart Autonegotiation */
+#define MII_CTRL_IP             (1 << 10) /* Isolate Phy */
+#define MII_CTRL_PD             (1 << 11) /* Power Down */
+#define MII_CTRL_AE             (1 << 12) /* Autonegotiation enable */
+#define MII_CTRL_SS_LSB         (1 << 13) /* Speed select, LSb */
+#define MII_CTRL_LE             (1 << 14) /* Loopback enable */
+#define MII_CTRL_RESET          (1 << 15) /* PHY reset */
+
+/*
+ * MII Link Advertisment
+ */
+#define MII_ANA_ASF             (1 << 0)  /* Advertise Selector Field */
+#define MII_ANA_HD_10           (1 << 5)  /* Half duplex 10Mb/s supported */
+#define MII_ANA_FD_10           (1 << 6)  /* Full duplex 10Mb/s supported */
+#define MII_ANA_HD_100          (1 << 7)  /* Half duplex 100Mb/s supported */
+#define MII_ANA_FD_100          (1 << 8)  /* Full duplex 100Mb/s supported */
+#define MII_ANA_T4              (1 << 9)  /* T4 */
+#define MII_ANA_PAUSE           (1 << 10) /* Pause supported */
+#define MII_ANA_ASYM_PAUSE      (1 << 11) /* Asymmetric pause supported */
+#define MII_ANA_RF              (1 << 13) /* Remote fault */
+#define MII_ANA_NP              (1 << 15) /* Next Page */
+
+/*
+ * 1000Base-T Control Register
+ */
+#define MII_GB_CTRL_ADV_1000FD  (1 << 9)  /* Advertise 1000Base-T FD */
+#define MII_GB_CTRL_ADV_1000HD  (1 << 8)  /* Advertise 1000Base-T HD */
+#endif
+
+
+#endif/* _SRE_GMACAPI_H_ */
+
diff --git a/drivers/misc/serdes/SRE_memmap.h b/drivers/misc/serdes/SRE_memmap.h
new file mode 100644
index 0000000..3ec828a
--- /dev/null
+++ b/drivers/misc/serdes/SRE_memmap.h
@@ -0,0 +1,6122 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : mc_iomap_hisilicon.h
+  版 本 号   : 初稿
+  作    者   : c00111586
+  生成日期   : 2009年4月21日
+  最近修改   :
+  功能描述   : 头文件
+  函数列表   :
+  修改历史   :
+  1.日    期   : 2009年4月21日
+    作    者   : c00111586
+    修改内容   : 创建文件
+
+******************************************************************************/
+
+#ifndef _SRE_MEMMAP_H
+#define _SRE_MEMMAP_H
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/* 头文件包含 ----------------------------------*/
+
+/* 宏定义 --------------------------------------*/
+/*获取主频的寄存器地址  */
+#if 0  /*h64632*/
+#define MC_CLK_REG_ADDR         0xA0000018UL
+#else
+#define MC_CLK_REG_ADDR         0x13e00100
+#endif /*h64632*/
+
+/*SYSTEM CONTROL REGISTER  1380地址，650禁用*/
+#define SRE_SYSCTL_REG_BASE_ADDR    (0x20000000 + 0x80000000)
+
+/*poe gmac and so on buffer & cacheable control*/
+#define SRE_SC_PERCTRL49_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x0F0)
+
+/*ar_shaping*/
+#define SRE_SC_PERCTRL74_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x154)
+
+/*SYSTEM CPU VERSION REGISTER*/
+#define SRE_SYSCTL_REG_CPU_VER0          (SRE_SYSCTL_REG_BASE_ADDR + 0xEE0)
+#define SRE_SYSCTL_REG_CPU_VER1          (SRE_SYSCTL_REG_BASE_ADDR + 0xEE4)
+#define SRE_SYSCTL_REG_CPU_VER2          (SRE_SYSCTL_REG_BASE_ADDR + 0xEE8)
+#define SRE_SYSCTL_REG_CPU_VER3         (SRE_SYSCTL_REG_BASE_ADDR + 0xEEC)
+
+/*SEC Request*/
+#define MC_SEC1_REQ_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x048)
+#define MC_SEC0_REQ_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x04C)
+
+/* 各个加速模块复位寄存器 */
+#define SRE_SC_PERCTRL6_REG           (SRE_SYSCTL_REG_BASE_ADDR + 0x044)
+#define SRE_SC_PERCTRL7_REG           (SRE_SYSCTL_REG_BASE_ADDR + 0x048)
+#define SRE_SC_PERCTRL8_REG           (SRE_SYSCTL_REG_BASE_ADDR + 0x04C)
+
+/*HDCP Request*/
+#define SRE_HDCP_REQ_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x04C)
+
+/*HDCP Clock*/
+#define SRE_HDCP_CLK_ENABLE_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x400)
+#define SRE_HDCP_CLK_DISABLE_REG             (SRE_SYSCTL_REG_BASE_ADDR + 0x404)
+#define SRE_HDCP_CLK_STATUS_REG              (SRE_SYSCTL_REG_BASE_ADDR + 0x408)
+/*7x3 Master port base*/
+/*hi1380 asic*/
+#define MC_7x3MASTER_REG_BASE_ADDR     (0x18040000 + 0x80000000)
+
+//******************************************************************************
+
+/* BMU_REG 模块寄存器基地址 */
+#if 0     /* z00202052 */
+#define SRE_BMU_REG_BASE_ADDR            (0x11400000UL)            /*BMU寄存器基地址*/
+#else
+#define SRE_BMU_REG_BASE_ADDR            (0xe1400000UL)            /*BMU寄存器基地址*/
+#endif    /* z00202052 */
+
+
+/******************************************************************************/
+/*                      BMU BMU_REG 寄存器定义                                */
+/******************************************************************************/
+#define SRE_BMU_ADDR_P_0_REG                       (SRE_BMU_REG_BASE_ADDR + 0x0)                 /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_1_REG                       (SRE_BMU_REG_BASE_ADDR + 0x4)                 /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_2_REG                       (SRE_BMU_REG_BASE_ADDR + 0x8)                 /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_3_REG                       (SRE_BMU_REG_BASE_ADDR + 0xC)                 /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_4_REG                       (SRE_BMU_REG_BASE_ADDR + 0x10)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_5_REG                       (SRE_BMU_REG_BASE_ADDR + 0x14)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_6_REG                       (SRE_BMU_REG_BASE_ADDR + 0x18)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_7_REG                       (SRE_BMU_REG_BASE_ADDR + 0x1C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_8_REG                       (SRE_BMU_REG_BASE_ADDR + 0x20)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_9_REG                       (SRE_BMU_REG_BASE_ADDR + 0x24)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_10_REG                      (SRE_BMU_REG_BASE_ADDR + 0x28)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_11_REG                      (SRE_BMU_REG_BASE_ADDR + 0x2C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_12_REG                      (SRE_BMU_REG_BASE_ADDR + 0x30)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_13_REG                      (SRE_BMU_REG_BASE_ADDR + 0x34)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_14_REG                      (SRE_BMU_REG_BASE_ADDR + 0x38)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_15_REG                      (SRE_BMU_REG_BASE_ADDR + 0x3C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_16_REG                      (SRE_BMU_REG_BASE_ADDR + 0x40)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_17_REG                      (SRE_BMU_REG_BASE_ADDR + 0x44)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_18_REG                      (SRE_BMU_REG_BASE_ADDR + 0x48)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_19_REG                      (SRE_BMU_REG_BASE_ADDR + 0x4C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_20_REG                      (SRE_BMU_REG_BASE_ADDR + 0x50)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_21_REG                      (SRE_BMU_REG_BASE_ADDR + 0x54)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_22_REG                      (SRE_BMU_REG_BASE_ADDR + 0x58)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_23_REG                      (SRE_BMU_REG_BASE_ADDR + 0x5C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_24_REG                      (SRE_BMU_REG_BASE_ADDR + 0x60)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_25_REG                      (SRE_BMU_REG_BASE_ADDR + 0x64)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_26_REG                      (SRE_BMU_REG_BASE_ADDR + 0x68)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_27_REG                      (SRE_BMU_REG_BASE_ADDR + 0x6C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_28_REG                      (SRE_BMU_REG_BASE_ADDR + 0x70)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_29_REG                      (SRE_BMU_REG_BASE_ADDR + 0x74)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_30_REG                      (SRE_BMU_REG_BASE_ADDR + 0x78)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_ADDR_P_31_REG                      (SRE_BMU_REG_BASE_ADDR + 0x7C)                /* BMU模块各pool的读写接口地址。 */
+#define SRE_BMU_SIZE_P_0_REG                       (SRE_BMU_REG_BASE_ADDR + 0x80)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_1_REG                       (SRE_BMU_REG_BASE_ADDR + 0x84)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_2_REG                       (SRE_BMU_REG_BASE_ADDR + 0x88)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_3_REG                       (SRE_BMU_REG_BASE_ADDR + 0x8C)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_4_REG                       (SRE_BMU_REG_BASE_ADDR + 0x90)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_5_REG                       (SRE_BMU_REG_BASE_ADDR + 0x94)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_6_REG                       (SRE_BMU_REG_BASE_ADDR + 0x98)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_7_REG                       (SRE_BMU_REG_BASE_ADDR + 0x9C)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_8_REG                       (SRE_BMU_REG_BASE_ADDR + 0xA0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_9_REG                       (SRE_BMU_REG_BASE_ADDR + 0xA4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_10_REG                      (SRE_BMU_REG_BASE_ADDR + 0xA8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_11_REG                      (SRE_BMU_REG_BASE_ADDR + 0xAC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_12_REG                      (SRE_BMU_REG_BASE_ADDR + 0xB0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_13_REG                      (SRE_BMU_REG_BASE_ADDR + 0xB4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_14_REG                      (SRE_BMU_REG_BASE_ADDR + 0xB8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_15_REG                      (SRE_BMU_REG_BASE_ADDR + 0xBC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_16_REG                      (SRE_BMU_REG_BASE_ADDR + 0xC0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_17_REG                      (SRE_BMU_REG_BASE_ADDR + 0xC4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_18_REG                      (SRE_BMU_REG_BASE_ADDR + 0xC8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_19_REG                      (SRE_BMU_REG_BASE_ADDR + 0xCC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_20_REG                      (SRE_BMU_REG_BASE_ADDR + 0xD0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_21_REG                      (SRE_BMU_REG_BASE_ADDR + 0xD4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_22_REG                      (SRE_BMU_REG_BASE_ADDR + 0xD8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_23_REG                      (SRE_BMU_REG_BASE_ADDR + 0xDC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_24_REG                      (SRE_BMU_REG_BASE_ADDR + 0xE0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_25_REG                      (SRE_BMU_REG_BASE_ADDR + 0xE4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_26_REG                      (SRE_BMU_REG_BASE_ADDR + 0xE8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_27_REG                      (SRE_BMU_REG_BASE_ADDR + 0xEC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_28_REG                      (SRE_BMU_REG_BASE_ADDR + 0xF0)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_29_REG                      (SRE_BMU_REG_BASE_ADDR + 0xF4)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_30_REG                      (SRE_BMU_REG_BASE_ADDR + 0xF8)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_SIZE_P_31_REG                      (SRE_BMU_REG_BASE_ADDR + 0xFC)                /* BMU pool的内部SRAM 大小。 */
+#define SRE_BMU_WL_P_0_REG                         (SRE_BMU_REG_BASE_ADDR + 0x100)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_1_REG                         (SRE_BMU_REG_BASE_ADDR + 0x104)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_2_REG                         (SRE_BMU_REG_BASE_ADDR + 0x108)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_3_REG                         (SRE_BMU_REG_BASE_ADDR + 0x10C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_4_REG                         (SRE_BMU_REG_BASE_ADDR + 0x110)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_5_REG                         (SRE_BMU_REG_BASE_ADDR + 0x114)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_6_REG                         (SRE_BMU_REG_BASE_ADDR + 0x118)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_7_REG                         (SRE_BMU_REG_BASE_ADDR + 0x11C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_8_REG                         (SRE_BMU_REG_BASE_ADDR + 0x120)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_9_REG                         (SRE_BMU_REG_BASE_ADDR + 0x124)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_10_REG                        (SRE_BMU_REG_BASE_ADDR + 0x128)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_11_REG                        (SRE_BMU_REG_BASE_ADDR + 0x12C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_12_REG                        (SRE_BMU_REG_BASE_ADDR + 0x130)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_13_REG                        (SRE_BMU_REG_BASE_ADDR + 0x134)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_14_REG                        (SRE_BMU_REG_BASE_ADDR + 0x138)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_15_REG                        (SRE_BMU_REG_BASE_ADDR + 0x13C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_16_REG                        (SRE_BMU_REG_BASE_ADDR + 0x140)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_17_REG                        (SRE_BMU_REG_BASE_ADDR + 0x144)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_18_REG                        (SRE_BMU_REG_BASE_ADDR + 0x148)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_19_REG                        (SRE_BMU_REG_BASE_ADDR + 0x14C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_20_REG                        (SRE_BMU_REG_BASE_ADDR + 0x150)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_21_REG                        (SRE_BMU_REG_BASE_ADDR + 0x154)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_22_REG                        (SRE_BMU_REG_BASE_ADDR + 0x158)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_23_REG                        (SRE_BMU_REG_BASE_ADDR + 0x15C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_24_REG                        (SRE_BMU_REG_BASE_ADDR + 0x160)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_25_REG                        (SRE_BMU_REG_BASE_ADDR + 0x164)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_26_REG                        (SRE_BMU_REG_BASE_ADDR + 0x168)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_27_REG                        (SRE_BMU_REG_BASE_ADDR + 0x16C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_28_REG                        (SRE_BMU_REG_BASE_ADDR + 0x170)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_29_REG                        (SRE_BMU_REG_BASE_ADDR + 0x174)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_30_REG                        (SRE_BMU_REG_BASE_ADDR + 0x178)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_WL_P_31_REG                        (SRE_BMU_REG_BASE_ADDR + 0x17C)               /* BMU pool的内部SRAM 向外部L2/DRAM 的溢出/回读水线。 */
+#define SRE_BMU_CTRL_REG                           (SRE_BMU_REG_BASE_ADDR + 0x180)               /* BMU 全局控制寄存器。 */
+#define SRE_BMU_POOL_RDEN_REG                      (SRE_BMU_REG_BASE_ADDR + 0x184)               /* BMU模块pool 读写使能保护位。 */
+#define SRE_BMU_INT_STS_REG                        (SRE_BMU_REG_BASE_ADDR + 0x188)               /* BMU 中断状态寄存器。 */
+#define SRE_BMU_INT_EN_REG                         (SRE_BMU_REG_BASE_ADDR + 0x18C)               /* BMU 中断使能寄存器。 */
+#define SRE_BMU_UNALIGN_ERR_PID_REG                (SRE_BMU_REG_BASE_ADDR + 0x190)               /* BMU 非对齐错误Poo ID 寄存器。 */
+#define SRE_BMU_ECC_1B_CNT_REG                     (SRE_BMU_REG_BASE_ADDR + 0x194)               /* BMU SRAM ecc 1bit错误统计计数器 */
+#define SRE_BMU_CPU_ADD_STATUS_L_REG               (SRE_BMU_REG_BASE_ADDR + 0x198)               /* CPU ADD BMU状态寄存器0~31 虚拟CPU */
+#define SRE_BMU_CPU_ADD_STATUS_H_REG               (SRE_BMU_REG_BASE_ADDR + 0x19C)               /* CPU ADD BMU状态寄存器32~63 虚拟CPU */
+#define SRE_BMU_CPU_ADD_ERROR_DATA0_REG            (SRE_BMU_REG_BASE_ADDR + 0x1A0)               /* CPU ADD 错误的数据寄存器地位 */
+#define SRE_BMU_CPU_ADD_ERROR_DATA1_REG            (SRE_BMU_REG_BASE_ADDR + 0x1A4)               /* CPU ADD 错误的数据寄存器高位 */
+#define SRE_BMU_BITMAP_ECC_1B_CNT_REG              (SRE_BMU_REG_BASE_ADDR + 0x1A8)               /* BMU bitmap SRAM ecc 1bit错误统计计数器 */
+#define SRE_BMU_PTRNUM_P_0_REG                     (SRE_BMU_REG_BASE_ADDR + 0x200)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_1_REG                     (SRE_BMU_REG_BASE_ADDR + 0x204)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_2_REG                     (SRE_BMU_REG_BASE_ADDR + 0x208)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_3_REG                     (SRE_BMU_REG_BASE_ADDR + 0x20C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_4_REG                     (SRE_BMU_REG_BASE_ADDR + 0x210)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_5_REG                     (SRE_BMU_REG_BASE_ADDR + 0x214)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_6_REG                     (SRE_BMU_REG_BASE_ADDR + 0x218)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_7_REG                     (SRE_BMU_REG_BASE_ADDR + 0x21C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_8_REG                     (SRE_BMU_REG_BASE_ADDR + 0x220)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_9_REG                     (SRE_BMU_REG_BASE_ADDR + 0x224)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_10_REG                    (SRE_BMU_REG_BASE_ADDR + 0x228)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_11_REG                    (SRE_BMU_REG_BASE_ADDR + 0x22C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_12_REG                    (SRE_BMU_REG_BASE_ADDR + 0x230)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_13_REG                    (SRE_BMU_REG_BASE_ADDR + 0x234)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_14_REG                    (SRE_BMU_REG_BASE_ADDR + 0x238)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_15_REG                    (SRE_BMU_REG_BASE_ADDR + 0x23C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_16_REG                    (SRE_BMU_REG_BASE_ADDR + 0x240)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_17_REG                    (SRE_BMU_REG_BASE_ADDR + 0x244)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_18_REG                    (SRE_BMU_REG_BASE_ADDR + 0x248)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_19_REG                    (SRE_BMU_REG_BASE_ADDR + 0x24C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_20_REG                    (SRE_BMU_REG_BASE_ADDR + 0x250)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_21_REG                    (SRE_BMU_REG_BASE_ADDR + 0x254)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_22_REG                    (SRE_BMU_REG_BASE_ADDR + 0x258)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_23_REG                    (SRE_BMU_REG_BASE_ADDR + 0x25C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_24_REG                    (SRE_BMU_REG_BASE_ADDR + 0x260)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_25_REG                    (SRE_BMU_REG_BASE_ADDR + 0x264)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_26_REG                    (SRE_BMU_REG_BASE_ADDR + 0x268)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_27_REG                    (SRE_BMU_REG_BASE_ADDR + 0x26C)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_28_REG                    (SRE_BMU_REG_BASE_ADDR + 0x270)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_29_REG                    (SRE_BMU_REG_BASE_ADDR + 0x274)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_30_REG                    (SRE_BMU_REG_BASE_ADDR + 0x278)               /* BMU pool的地址指针个数。 */
+#define SRE_BMU_PTRNUM_P_31_REG                    (SRE_BMU_REG_BASE_ADDR + 0x27C)               /* BMU pool的地址指针个数。 */
+
+#define SRE_BMU_P0_OUT_ADDR_REG                    (SRE_BMU_REG_BASE_ADDR + 0x280)
+#define SRE_BMU_P0_OUT_CUR_ADDR_REG                (SRE_BMU_REG_BASE_ADDR + 0x300)
+#define SRE_BMU_P0_OUT_LEN_REG                     (SRE_BMU_REG_BASE_ADDR + 0x380)
+#define SRE_BMU_BOUND_ERR_ADDR_REG                 (SRE_BMU_REG_BASE_ADDR + 0x400)
+#define SRE_BMU_IN_EMTPY_STA_ADDR_REG              (SRE_BMU_REG_BASE_ADDR + 0x404)
+#define SRE_BMU_IN_FULL_STA_ADDR_REG               (SRE_BMU_REG_BASE_ADDR + 0x408)
+#define SRE_BMU_ALL_EMTPY_STA_ADDR_REG             (SRE_BMU_REG_BASE_ADDR + 0x40c)
+#define SRE_BMU_ALL_FULL_STA_ADDR_REG              (SRE_BMU_REG_BASE_ADDR + 0x410)
+#define SRE_BMU_ALMST_FULL_STA_ADDR_REG            (SRE_BMU_REG_BASE_ADDR + 0x414)
+
+
+#define SRE_BMU_BUS_ERR_PID_REG                    (SRE_BMU_REG_BASE_ADDR + 0x418)               /* 当前总线出现错误的pool ID */
+#define SRE_BMU_PERR_SRAM_ADDR_REG                 (SRE_BMU_REG_BASE_ADDR + 0x41C)               /* 当前SRAMECC校验2bit错误指针 */
+#define SRE_BMU_PERR_LDST_ADDR_REG                 (SRE_BMU_REG_BASE_ADDR + 0x420)
+
+#define SRE_BMU_ECC_PID_REG                        (SRE_BMU_REG_BASE_ADDR + 0x424)               /* Peri错误pool ID */
+#define SRE_BMU_TEST_REG                           (SRE_BMU_REG_BASE_ADDR + 0x428)               /* BMU内部状态寄存器 */
+#define SRE_BMU_CFG_DLY_REG                        (SRE_BMU_REG_BASE_ADDR + 0x42C)               /* BMU快满后读/写延迟寄存器 */
+#define SRE_BMU_VMID_CFG_REG                       (SRE_BMU_REG_BASE_ADDR + 0x430)               /* BMU Master访问MDDRC的VMID的配置 */
+#define SRE_BMU_BOUND_ERR_STS_REG                  (SRE_BMU_REG_BASE_ADDR + 0x434)               /* BMU 释放缓存地址边界出错状态寄存器 */
+#define SRE_BMU_BOUND_P_0_REG                      (SRE_BMU_REG_BASE_ADDR + 0x438)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_1_REG                      (SRE_BMU_REG_BASE_ADDR + 0x43C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_2_REG                      (SRE_BMU_REG_BASE_ADDR + 0x440)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_3_REG                      (SRE_BMU_REG_BASE_ADDR + 0x444)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_4_REG                      (SRE_BMU_REG_BASE_ADDR + 0x448)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_5_REG                      (SRE_BMU_REG_BASE_ADDR + 0x44C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_6_REG                      (SRE_BMU_REG_BASE_ADDR + 0x450)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_7_REG                      (SRE_BMU_REG_BASE_ADDR + 0x454)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_8_REG                      (SRE_BMU_REG_BASE_ADDR + 0x458)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_9_REG                      (SRE_BMU_REG_BASE_ADDR + 0x45C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_10_REG                     (SRE_BMU_REG_BASE_ADDR + 0x460)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_11_REG                     (SRE_BMU_REG_BASE_ADDR + 0x464)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_12_REG                     (SRE_BMU_REG_BASE_ADDR + 0x468)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_13_REG                     (SRE_BMU_REG_BASE_ADDR + 0x46C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_14_REG                     (SRE_BMU_REG_BASE_ADDR + 0x470)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_15_REG                     (SRE_BMU_REG_BASE_ADDR + 0x474)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_16_REG                     (SRE_BMU_REG_BASE_ADDR + 0x478)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_17_REG                     (SRE_BMU_REG_BASE_ADDR + 0x47C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_18_REG                     (SRE_BMU_REG_BASE_ADDR + 0x480)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_19_REG                     (SRE_BMU_REG_BASE_ADDR + 0x484)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_20_REG                     (SRE_BMU_REG_BASE_ADDR + 0x488)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_21_REG                     (SRE_BMU_REG_BASE_ADDR + 0x48C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_22_REG                     (SRE_BMU_REG_BASE_ADDR + 0x490)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_23_REG                     (SRE_BMU_REG_BASE_ADDR + 0x494)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_24_REG                     (SRE_BMU_REG_BASE_ADDR + 0x498)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_25_REG                     (SRE_BMU_REG_BASE_ADDR + 0x49C)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_26_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4A0)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_27_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4A4)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_28_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4A8)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_29_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4AC)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_30_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4B0)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BOUND_P_31_REG                     (SRE_BMU_REG_BASE_ADDR + 0x4B4)               /* BMU Pool释放缓存地址边界寄存器 */
+#define SRE_BMU_BITMAP_BADDR_P0_REG                (SRE_BMU_REG_BASE_ADDR + 0x500)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P1_REG                (SRE_BMU_REG_BASE_ADDR + 0x504)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P2_REG                (SRE_BMU_REG_BASE_ADDR + 0x508)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P3_REG                (SRE_BMU_REG_BASE_ADDR + 0x50C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P4_REG                (SRE_BMU_REG_BASE_ADDR + 0x510)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P5_REG                (SRE_BMU_REG_BASE_ADDR + 0x514)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P6_REG                (SRE_BMU_REG_BASE_ADDR + 0x518)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P7_REG                (SRE_BMU_REG_BASE_ADDR + 0x51C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P8_REG                (SRE_BMU_REG_BASE_ADDR + 0x520)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P9_REG                (SRE_BMU_REG_BASE_ADDR + 0x524)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P10_REG               (SRE_BMU_REG_BASE_ADDR + 0x528)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P11_REG               (SRE_BMU_REG_BASE_ADDR + 0x52C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P12_REG               (SRE_BMU_REG_BASE_ADDR + 0x530)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P13_REG               (SRE_BMU_REG_BASE_ADDR + 0x534)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P14_REG               (SRE_BMU_REG_BASE_ADDR + 0x538)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P15_REG               (SRE_BMU_REG_BASE_ADDR + 0x53C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P16_REG               (SRE_BMU_REG_BASE_ADDR + 0x540)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P17_REG               (SRE_BMU_REG_BASE_ADDR + 0x544)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P18_REG               (SRE_BMU_REG_BASE_ADDR + 0x548)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P19_REG               (SRE_BMU_REG_BASE_ADDR + 0x54C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P20_REG               (SRE_BMU_REG_BASE_ADDR + 0x550)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P21_REG               (SRE_BMU_REG_BASE_ADDR + 0x554)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P22_REG               (SRE_BMU_REG_BASE_ADDR + 0x558)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P23_REG               (SRE_BMU_REG_BASE_ADDR + 0x55C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P24_REG               (SRE_BMU_REG_BASE_ADDR + 0x560)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P25_REG               (SRE_BMU_REG_BASE_ADDR + 0x564)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P26_REG               (SRE_BMU_REG_BASE_ADDR + 0x568)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P27_REG               (SRE_BMU_REG_BASE_ADDR + 0x56C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P28_REG               (SRE_BMU_REG_BASE_ADDR + 0x570)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P29_REG               (SRE_BMU_REG_BASE_ADDR + 0x574)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P30_REG               (SRE_BMU_REG_BASE_ADDR + 0x578)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_BADDR_P31_REG               (SRE_BMU_REG_BASE_ADDR + 0x57C)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_WIDTH_REG                   (SRE_BMU_REG_BASE_ADDR + 0x580)               /* BMU bitmap的SRAM中各个Pool的起始地址 */
+#define SRE_BMU_BITMAP_ST_ERR_INFO_REG             (SRE_BMU_REG_BASE_ADDR + 0x584)               /* BMU bitmap重复释放错误状态寄存器 */
+#define SRE_BMU_BITMAP_LD_ERR_INFO_REG             (SRE_BMU_REG_BASE_ADDR + 0x588)               /* BMU bitmap重复申请错误状态寄存器 */
+#define SRE_BMU_BITMAP_ERR_STS_REG                 (SRE_BMU_REG_BASE_ADDR + 0x58C)               /* BMU bitmap重复申请错误状态寄存器 */
+#define SRE_BMU_PPE_QOS_EN_REG                     (SRE_BMU_REG_BASE_ADDR + 0x590)               /* 送给PPE的QOS水线产生逻辑使能寄存器 */
+#define SRE_BMU_CPU_ID_H12_REG                     (SRE_BMU_REG_BASE_ADDR + 0x594)               /* CPU的Master ID 高12位 */
+#define SRE_BMU_PPE_QOS_WL_0_REG                   (SRE_BMU_REG_BASE_ADDR + 0x800)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_1_REG                   (SRE_BMU_REG_BASE_ADDR + 0x804)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_2_REG                   (SRE_BMU_REG_BASE_ADDR + 0x808)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_3_REG                   (SRE_BMU_REG_BASE_ADDR + 0x80C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_4_REG                   (SRE_BMU_REG_BASE_ADDR + 0x810)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_5_REG                   (SRE_BMU_REG_BASE_ADDR + 0x814)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_6_REG                   (SRE_BMU_REG_BASE_ADDR + 0x818)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_7_REG                   (SRE_BMU_REG_BASE_ADDR + 0x81C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_8_REG                   (SRE_BMU_REG_BASE_ADDR + 0x820)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_9_REG                   (SRE_BMU_REG_BASE_ADDR + 0x824)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_10_REG                  (SRE_BMU_REG_BASE_ADDR + 0x828)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_11_REG                  (SRE_BMU_REG_BASE_ADDR + 0x82C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_12_REG                  (SRE_BMU_REG_BASE_ADDR + 0x830)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_13_REG                  (SRE_BMU_REG_BASE_ADDR + 0x834)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_14_REG                  (SRE_BMU_REG_BASE_ADDR + 0x838)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_15_REG                  (SRE_BMU_REG_BASE_ADDR + 0x83C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_16_REG                  (SRE_BMU_REG_BASE_ADDR + 0x840)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_17_REG                  (SRE_BMU_REG_BASE_ADDR + 0x844)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_18_REG                  (SRE_BMU_REG_BASE_ADDR + 0x848)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_19_REG                  (SRE_BMU_REG_BASE_ADDR + 0x84C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_20_REG                  (SRE_BMU_REG_BASE_ADDR + 0x850)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_21_REG                  (SRE_BMU_REG_BASE_ADDR + 0x854)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_22_REG                  (SRE_BMU_REG_BASE_ADDR + 0x858)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_23_REG                  (SRE_BMU_REG_BASE_ADDR + 0x85C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_24_REG                  (SRE_BMU_REG_BASE_ADDR + 0x860)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_25_REG                  (SRE_BMU_REG_BASE_ADDR + 0x864)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_26_REG                  (SRE_BMU_REG_BASE_ADDR + 0x868)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_27_REG                  (SRE_BMU_REG_BASE_ADDR + 0x86C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_28_REG                  (SRE_BMU_REG_BASE_ADDR + 0x870)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_29_REG                  (SRE_BMU_REG_BASE_ADDR + 0x874)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_30_REG                  (SRE_BMU_REG_BASE_ADDR + 0x878)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_31_REG                  (SRE_BMU_REG_BASE_ADDR + 0x87C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_32_REG                  (SRE_BMU_REG_BASE_ADDR + 0x880)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_33_REG                  (SRE_BMU_REG_BASE_ADDR + 0x884)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_34_REG                  (SRE_BMU_REG_BASE_ADDR + 0x888)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_35_REG                  (SRE_BMU_REG_BASE_ADDR + 0x88C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_36_REG                  (SRE_BMU_REG_BASE_ADDR + 0x890)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_37_REG                  (SRE_BMU_REG_BASE_ADDR + 0x894)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_38_REG                  (SRE_BMU_REG_BASE_ADDR + 0x898)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_39_REG                  (SRE_BMU_REG_BASE_ADDR + 0x89C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_40_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8A0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_41_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8A4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_42_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8A8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_43_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8AC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_44_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8B0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_45_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8B4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_46_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8B8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_47_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8BC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_48_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8C0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_49_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8C4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_50_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8C8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_51_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8CC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_52_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8D0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_53_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8D4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_54_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8D8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_55_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8DC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_56_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8E0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_57_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8E4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_58_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8E8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_59_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8EC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_60_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8F0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_61_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8F4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_62_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8F8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_63_REG                  (SRE_BMU_REG_BASE_ADDR + 0x8FC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_64_REG                  (SRE_BMU_REG_BASE_ADDR + 0x900)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_65_REG                  (SRE_BMU_REG_BASE_ADDR + 0x904)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_66_REG                  (SRE_BMU_REG_BASE_ADDR + 0x908)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_67_REG                  (SRE_BMU_REG_BASE_ADDR + 0x90C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_68_REG                  (SRE_BMU_REG_BASE_ADDR + 0x910)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_69_REG                  (SRE_BMU_REG_BASE_ADDR + 0x914)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_70_REG                  (SRE_BMU_REG_BASE_ADDR + 0x918)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_71_REG                  (SRE_BMU_REG_BASE_ADDR + 0x91C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_72_REG                  (SRE_BMU_REG_BASE_ADDR + 0x920)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_73_REG                  (SRE_BMU_REG_BASE_ADDR + 0x924)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_74_REG                  (SRE_BMU_REG_BASE_ADDR + 0x928)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_75_REG                  (SRE_BMU_REG_BASE_ADDR + 0x92C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_76_REG                  (SRE_BMU_REG_BASE_ADDR + 0x930)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_77_REG                  (SRE_BMU_REG_BASE_ADDR + 0x934)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_78_REG                  (SRE_BMU_REG_BASE_ADDR + 0x938)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_79_REG                  (SRE_BMU_REG_BASE_ADDR + 0x93C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_80_REG                  (SRE_BMU_REG_BASE_ADDR + 0x940)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_81_REG                  (SRE_BMU_REG_BASE_ADDR + 0x944)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_82_REG                  (SRE_BMU_REG_BASE_ADDR + 0x948)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_83_REG                  (SRE_BMU_REG_BASE_ADDR + 0x94C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_84_REG                  (SRE_BMU_REG_BASE_ADDR + 0x950)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_85_REG                  (SRE_BMU_REG_BASE_ADDR + 0x954)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_86_REG                  (SRE_BMU_REG_BASE_ADDR + 0x958)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_87_REG                  (SRE_BMU_REG_BASE_ADDR + 0x95C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_88_REG                  (SRE_BMU_REG_BASE_ADDR + 0x960)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_89_REG                  (SRE_BMU_REG_BASE_ADDR + 0x964)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_90_REG                  (SRE_BMU_REG_BASE_ADDR + 0x968)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_91_REG                  (SRE_BMU_REG_BASE_ADDR + 0x96C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_92_REG                  (SRE_BMU_REG_BASE_ADDR + 0x970)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_93_REG                  (SRE_BMU_REG_BASE_ADDR + 0x974)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_94_REG                  (SRE_BMU_REG_BASE_ADDR + 0x978)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_95_REG                  (SRE_BMU_REG_BASE_ADDR + 0x97C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_96_REG                  (SRE_BMU_REG_BASE_ADDR + 0x980)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_97_REG                  (SRE_BMU_REG_BASE_ADDR + 0x984)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_98_REG                  (SRE_BMU_REG_BASE_ADDR + 0x988)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_99_REG                  (SRE_BMU_REG_BASE_ADDR + 0x98C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_100_REG                 (SRE_BMU_REG_BASE_ADDR + 0x990)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_101_REG                 (SRE_BMU_REG_BASE_ADDR + 0x994)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_102_REG                 (SRE_BMU_REG_BASE_ADDR + 0x998)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_103_REG                 (SRE_BMU_REG_BASE_ADDR + 0x99C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_104_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9A0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_105_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9A4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_106_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9A8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_107_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9AC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_108_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9B0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_109_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9B4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_110_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9B8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_111_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9BC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_112_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9C0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_113_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9C4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_114_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9C8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_115_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9CC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_116_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9D0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_117_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9D4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_118_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9D8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_119_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9DC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_120_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9E0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_121_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9E4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_122_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9E8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_123_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9EC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_124_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9F0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_125_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9F4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_126_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9F8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_127_REG                 (SRE_BMU_REG_BASE_ADDR + 0x9FC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_128_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA00)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_129_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA04)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_130_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA08)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_131_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA0C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_132_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA10)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_133_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA14)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_134_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA18)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_135_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA1C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_136_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA20)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_137_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA24)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_138_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA28)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_139_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA2C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_140_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA30)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_141_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA34)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_142_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA38)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_143_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA3C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_144_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA40)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_145_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA44)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_146_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA48)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_147_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA4C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_148_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA50)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_149_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA54)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_150_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA58)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_151_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA5C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_152_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA60)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_153_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA64)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_154_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA68)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_155_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA6C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_156_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA70)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_157_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA74)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_158_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA78)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_159_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA7C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_160_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA80)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_161_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA84)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_162_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA88)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_163_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA8C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_164_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA90)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_165_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA94)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_166_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA98)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_167_REG                 (SRE_BMU_REG_BASE_ADDR + 0xA9C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_168_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAA0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_169_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAA4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_170_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAA8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_171_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAAC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_172_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAB0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_173_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAB4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_174_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAB8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_175_REG                 (SRE_BMU_REG_BASE_ADDR + 0xABC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_176_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAC0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_177_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAC4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_178_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAC8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_179_REG                 (SRE_BMU_REG_BASE_ADDR + 0xACC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_180_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAD0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_181_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAD4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_182_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAD8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_183_REG                 (SRE_BMU_REG_BASE_ADDR + 0xADC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_184_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAE0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_185_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAE4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_186_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAE8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_187_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAEC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_188_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAF0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_189_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAF4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_190_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAF8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_191_REG                 (SRE_BMU_REG_BASE_ADDR + 0xAFC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_192_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB00)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_193_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB04)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_194_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB08)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_195_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB0C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_196_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB10)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_197_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB14)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_198_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB18)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_199_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB1C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_200_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB20)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_201_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB24)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_202_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB28)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_203_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB2C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_204_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB30)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_205_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB34)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_206_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB38)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_207_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB3C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_208_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB40)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_209_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB44)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_210_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB48)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_211_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB4C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_212_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB50)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_213_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB54)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_214_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB58)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_215_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB5C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_216_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB60)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_217_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB64)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_218_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB68)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_219_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB6C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_220_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB70)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_221_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB74)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_222_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB78)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_223_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB7C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_224_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB80)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_225_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB84)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_226_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB88)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_227_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB8C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_228_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB90)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_229_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB94)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_230_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB98)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_231_REG                 (SRE_BMU_REG_BASE_ADDR + 0xB9C)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_232_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBA0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_233_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBA4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_234_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBA8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_235_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBAC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_236_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBB0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_237_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBB4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_238_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBB8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_239_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBBC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_240_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBC0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_241_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBC4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_242_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBC8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_243_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBCC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_244_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBD0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_245_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBD4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_246_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBD8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_247_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBDC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_248_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBE0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_249_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBE4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_250_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBE8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_251_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBEC)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_252_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBF0)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_253_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBF4)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_254_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBF8)               /* 送给PPE的QOS水线寄存器。 */
+#define SRE_BMU_PPE_QOS_WL_255_REG                 (SRE_BMU_REG_BASE_ADDR + 0xBFC)               /* 送给PPE的QOS水线寄存器。 */
+
+
+/* Tring相关的IO地址宏定义 */
+#define SRE_TRING_REG_BASE_ADDR           (0x10840000)
+
+#define SRE_TIM_CTR_ADDR                   SRE_TRING_REG_BASE_ADDR
+#define SRE_TIM_ERR_INT_ADDR              (SRE_TRING_REG_BASE_ADDR +0x4)
+#define SRE_TIM_ERR_MASK_ADDR             (SRE_TRING_REG_BASE_ADDR +0x8)
+#define SRE_TIM_RING0_BASE_ADDR           (SRE_TRING_REG_BASE_ADDR +0x10)
+#define SRE_TIM_RING0_BSIZE_ADDR          (SRE_TRING_REG_BASE_ADDR +0x14)
+#define SRE_TIM_RING0_INTERVAL_ADDR       (SRE_TRING_REG_BASE_ADDR +0x18)
+#define SRE_TIM_RING0_CSIZE_ADDR          (SRE_TRING_REG_BASE_ADDR +0x1c)
+#define SRE_TIM_RING0_POE_ADDR            (SRE_TRING_REG_BASE_ADDR +0x20)
+#define SRE_TIM_RING0_POOL_ADDR           (SRE_TRING_REG_BASE_ADDR +0x24)
+#define SRE_TIM_RING0_COUNT_ADDR          (SRE_TRING_REG_BASE_ADDR +0x28)
+#define SRE_TIM_RING0_BUCKET_ADDR         (SRE_TRING_REG_BASE_ADDR +0x2c)
+#define SRE_TIM_RING0_WR_POE_TIMEOUT      (SRE_TRING_REG_BASE_ADDR +0x30)
+#define SRE_TIM_RING0_WR_BMU_TIMEOUT      (SRE_TRING_REG_BASE_ADDR +0x34)
+#define SRE_TIM_RING0_WR_TIMEOUT_ST       (SRE_TRING_REG_BASE_ADDR +0x38)
+#define SRE_TIM_RING0_REL_CHUNK_NUM       (SRE_TRING_REG_BASE_ADDR +0x3C)
+#define SRE_TIMEBASE0_INIT_L_ADDR         (SRE_TRING_REG_BASE_ADDR + 0x190)
+#define SRE_TIMEBASE0_INIT_H_ADDR         (SRE_TRING_REG_BASE_ADDR + 0x194)
+#define SRE_TIMEBASE0_CNT_L_ADDR          (SRE_TRING_REG_BASE_ADDR + 0x198)
+#define SRE_TIMEBASE0_CNT_H_ADDR          (SRE_TRING_REG_BASE_ADDR + 0x19C)
+
+#define SRE_MDIO_BASE_ADDR          (0x18000000 + 0x80000000)
+
+/******************************************************************************/
+/*                      PhosphorV600 MAC_CORE 寄存器定义                      */
+/******************************************************************************/
+#if 0     /* z00202052 */
+#define SRE_GMAC_BASE_ADDR                                 (0x12800000)
+#else
+#define SRE_GMAC_BASE_ADDR                                 (0xe2800000)
+#endif    /* z00202052 */
+
+
+#define SRE_GMAC_DUPLEX_TYPE_REG                           (0x0008UL)                          /*全双工半双工模式寄存器 */
+#define SRE_GMAC_FD_FC_TYPE_REG                            (0x000CUL)                          /*FD_FC_TYPE为流控帧类型域寄存器。*/
+#define SRE_GMAC_FC_TX_TIMER_REG                           (0x001CUL)                          /*FC_TX_TIMER为流控时间参数寄存器。*/
+#define SRE_GMAC_FD_FC_ADDR_LOW_REG                        (0x0020UL)                          /*FD_FC_ADDR_LOW为流控帧目的地址寄存器1。*/
+#define SRE_GMAC_FD_FC_ADDR_HIGH_REG                       (0x0024UL)                          /*FD_FC_ADDR_HIGH为流控帧目的地址寄存器2。 */
+#define SRE_GMAC_IPG_TX_TIMER_REG                          (0x0030UL)                          /*IPG_TX_TIMER为发送帧间隙寄存器。             */
+#define SRE_GMAC_PAUSE_THR_REG                             (0x0038UL)                          /*PAUSE_THR为发送流控帧间隙寄存器。         */
+#define SRE_GMAC_MAX_FRM_SIZE_REG                          (0x003CUL)                          /*MAX_FRM_SIZE为最大帧长寄存器。                    */
+#define SRE_GMAC_PORT_MODE_REG                             (0x0040UL)                          /*PORT_MODE为端口状态寄存器。                          */
+#define SRE_GMAC_PORT_EN_REG                               (0x0044UL)                          /*PORT_EN为通道使能寄存器。                                   */
+#define SRE_GMAC_PAUSE_EN_REG                              (0x0048UL)                          /*PAUSE_EN为流控使能寄存器。                                */
+#define SRE_GMAC_SHORT_RUNTS_THR_REG                       (0x0050UL)                          /*SHORT_RUNTS_THR为超短帧界限寄存器。 */
+#define SRE_GMAC_AN_NEG_STATE_REG                          (0x0058UL)                          /*SGMII自协商状态寄存器                                    */
+#define SRE_GMAC_TX_LOCAL_PAGE_REG                         (0x005CUL)                          /*自协商本地配置寄存器                                  */
+#define SRE_GMAC_TRANSMIT_CONTROL_REG                      (0x0060UL)                          /*TRANSMIT_CONTROL为常用配置寄存器。     */
+#define SRE_GMAC_REC_FILT_CONTROL_REG                      (0x0064UL)                          /*REC_FILT_CONTROL为接收帧过滤控制寄存器。 */
+#define SRE_GMAC_PTP_CONFIG_REG                            (0x0074UL)                          /*发送方向IPV6的1588报文CHCECKSUM使能和1588的修正域最高位置0使能 */
+#define SRE_GMAC_RX_OCTETS_TOTAL_OK_REG                    (0x0080UL)                          /*RX_OCTETS_TOTAL_OK为接收有效帧的字节统计寄存器。*/
+#define SRE_GMAC_RX_OCTETS_BAD_REG                         (0x0084UL)                          /*RX_OCTETS_BAD为接收错误帧字节统计寄存器。                     */
+#define SRE_GMAC_RX_UC_PKTS_REG                            (0x0088UL)                          /*RX_UC_PKTS为MAC接收单播帧数统计寄存器。                              */
+#define SRE_GMAC_RX_MC_PKTS_REG                            (0x008CUL)                          /*RX_MC_PKTS为接收多播帧数统计寄存器。                                     */
+#define SRE_GMAC_RX_BC_PKTS_REG                            (0x0090UL)                          /*RX_BC_PKTS为接收的广播帧数统计寄存器。                                 */
+#define SRE_GMAC_RX_PKTS_64OCTETS_REG                      (0x0094UL)                          /*RX_PKTS_64OCTETS为接收到帧长为64byte的帧数统计寄存器。*/
+#define SRE_GMAC_RX_PKTS_65TO127OCTETS_REG                 (0x0098UL)                          /*RX_PKTS_65TO127OCTETS为接收到帧长为65～127byte的帧数统计寄存器。 */
+#define SRE_GMAC_RX_PKTS_128TO255OCTETS_REG                (0x009CUL)                          /*RX_PKTS_128TO255OCTETS为接收到帧长为128～255byte的帧数统计寄存器。 */
+#define SRE_GMAC_RX_PKTS_255TO511OCTETS_REG                (0x00A0UL)                          /*RX_PKTS_255TO511OCTETS为接收到帧长为256～511byte的帧数统计寄存器。  */
+#define SRE_GMAC_RX_PKTS_512TO1023OCTETS_REG               (0x00A4UL)                          /*RX_PKTS_512TO1023OCTETS为接收到帧长为512～1023byte的帧数统计寄存器。 */
+#define SRE_GMAC_RX_PKTS_1024TO1518OCTETS_REG              (0x00A8UL)                          /*RX_PKTS_1024TO1518OCTETS为接收帧长为1024～1518byte的帧数统计寄存器。  */
+#define SRE_GMAC_RX_PKTS_1519TOMAXOCTETS_REG               (0x00ACUL)                          /*RX_PKTS_1519TOMAXOCTETS为接收到帧长为1519～最大byte的帧数统计寄存器。 */
+#define SRE_GMAC_RX_FCS_ERRORS_REG                         (0x00B0UL)                          /*RX_FCS_ERRORS为接收CRC检验错误的帧数统计寄存器。                                        */
+#define SRE_GMAC_RX_TAGGED_REG                             (0x00B4UL)                          /*RX_TAGGED为接收带TAG的帧统计寄存器。                                                    */
+#define SRE_GMAC_RX_DATA_ERR_REG                           (0x00B8UL)                          /*RX_DATA_ERR为接收数据错误帧统计寄存器。                                                 */
+#define SRE_GMAC_RX_ALIGN_ERRORS_REG                       (0x00BCUL)                          /*RX_ALIGN_ERRORS为接收数据非字节对齐错误帧统计寄存器。                                  */
+#define SRE_GMAC_RX_LONG_ERRORS_REG                        (0x00C0UL)                          /*RX_LONG_ERRORS为接收帧长大于允许的最大长度的帧数统计寄存器1。                        */
+#define SRE_GMAC_RX_JABBER_ERRORS_REG                      (0x00C4UL)                          /*RX_JABBER_ERRORS为接收帧长大于允许的最大长度的帧数统计寄存器2。                      */
+#define SRE_GMAC_RX_PAUSE_MACCONTROL_FRAMCOUNTER_REG       (0x00C8UL)                          /*RX_PAUSE_MACCONTROL_FRAMCOUNTER为接收到的流控帧数统计寄存器。                          */
+#define SRE_GMAC_RX_UNKNOWN_MACCONTROL_FRAMCOUNTER_REG     (0x00CCUL)                          /*RX_UNKNOWN_MACCONTROL_FRAMCOUNTER为MAC接收到的非流控控制帧数统计寄存器                */
+#define SRE_GMAC_RX_VERY_LONG_ERR_CNT_REG                  (0x00D0UL)                          /*RX_VERY_LONG_ERR_CNT为接收到超长帧统计寄存器。                                          */
+#define SRE_GMAC_RX_RUNT_ERR_CNT_REG                       (0x00D4UL)                          /*RX_RUNT_ERR_CNT为接收到帧长小于64byte大于等于short_runts_thr 字节的帧数寄存器。        */
+#define SRE_GMAC_RX_SHORT_ERR_CNT_REG                      (0x00D8UL)                          /*RX_SHORT_ERR_CNT为接收帧长小于short_runts_thr字节的帧数统计寄存器。                    */
+#define SRE_GMAC_RX_FILT_PKT_CNT_REG                       (0x00E8UL)                          /*接收方向过滤掉的包统计                                                                */
+#define SRE_GMAC_RX_OCTETS_TOTAL_FILT_REG                  (0x00ECUL)                          /*接收方向过滤掉的字节统计                                                              */
+#define SRE_GMAC_OCTETS_TRANSMITTED_OK_REG                 (0x0100UL)                          /*OCTETS_TRANSMITTED_OK为发送成功的好包字节数统计寄存器。                              */
+#define SRE_GMAC_OCTETS_TRANSMITTED_BAD_REG                (0x0104UL)                          /*OCTETS_TRANSMITTED_BAD为发送成功的坏包字节数统计寄存器。                             */
+#define SRE_GMAC_TX_UC_PKTS_REG                            (0x0108UL)                          /*TX_UC_PKTS为发送的单播帧数统计寄存器。                                                 */
+#define SRE_GMAC_TX_MC_PKTS_REG                            (0x010CUL)                          /*TX_MC_PKTS为发送的多播帧数统计寄存器。                                                 */
+#define SRE_GMAC_TX_BC_PKTS_REG                            (0x0110UL)                          /*TX_BC_PKTS为发送的广播帧数统计寄存器。                                                 */
+#define SRE_GMAC_TX_PKTS_64OCTETS_REG                      (0x0114UL)                          /*TX_PKTS_64OCTETS为发送帧长为64byte的帧数统计寄存器。                                    */
+#define SRE_GMAC_TX_PKTS_65TO127OCTETS_REG                 (0x0118UL)                          /*TX_PKTS_65TO127OCTETS为发送帧长为65～127byte的帧数统计寄存器。                          */
+#define SRE_GMAC_TX_PKTS_128TO255OCTETS_REG                (0x011CUL)                          /*TX_PKTS_128TO255OCTETS为发送帧长为128～255byte的帧数统计寄存器。                        */
+#define SRE_GMAC_TX_PKTS_255TO511OCTETS_REG                (0x0120UL)                          /*TX_PKTS_255TO511OCTETS为发送帧长为256～511byte的帧数统计寄存器。                        */
+#define SRE_GMAC_TX_PKTS_512TO1023OCTETS_REG               (0x0124UL)                          /*TX_PKTS_512TO1023OCTETS为发送帧长为512～1023byte节的帧数统计寄存器。                    */
+#define SRE_GMAC_TX_PKTS_1024TO1518OCTETS_REG              (0x0128UL)                          /*TX_PKTS_1024TO1518OCTETS为发送帧长为1024～1518byte的帧数统计寄存器。                    */
+#define SRE_GMAC_TX_PKTS_1519TOMAXOCTETS_REG               (0x012CUL)                          /*TX_PKTS_1519TOMAXOCTETS为发送帧长大于1519byte的帧数统计寄存器。                         */
+#define SRE_GMAC_TX_EXCESSIVE_LENGTH_DROP_REG              (0x014CUL)                          /*TX_EXCESSIVE_LENGTH_DROP为超过设定的最大帧长导致发送失败次数统计寄存器     。       */
+#define SRE_GMAC_TX_UNDERRUN_REG                           (0x0150UL)                          /*TX_UNDERRUN为帧发送过程中发生内部错误而导致发送失败的次数统计。                     */
+#define SRE_GMAC_TX_TAGGED_REG                             (0x0154UL)                          /*TX_TAGGED为发送的VLAN帧数统计寄存器。                                                  */
+#define SRE_GMAC_TX_CRC_ERROR_REG                          (0x0158UL)                          /*TX_CRC_ERROR为发送帧长正确CRC错误的帧数统计寄存器。                                   */
+#define SRE_GMAC_TX_PAUSE_FRAMES_REG                       (0x015CUL)                          /*TX_PAUSE_FRAMES为发送PAUSE帧数统计寄存器。                                             */
+#define SRE_GMAC_LED_MOD_REG                               (0x016CUL)                          /*LED_MOD为点灯模式控制寄存器。                                                         */
+#define SRE_GMAC_TS_DLY_ESTI_REG                           (0x0170UL)                          /*下行修正延时值                                                                         */
+#define SRE_GMAC_CF_ASYM_CRT_HIGH_REG                      (0x0174UL)                          /*非对称延时高32比特                                                                     */
+#define SRE_GMAC_CF_ASYM_CRT_LOW_REG                       (0x0178UL)                          /*非对称延时低32比特                                                                     */
+#define SRE_GMAC_TIMSTP_INGRESS_REG                        (0x017CUL)                          /*上行修正延时值                                                                         */
+#define SRE_GMAC_LINE_LOOP_BACK_REG                        (0x01A8UL)                          /*LINE_LOOP_BACK为MAC线路侧环回寄存器。                                                  */
+#define SRE_GMAC_CF_CRC_STRIP_REG                          (0x01B0UL)                          /*CF_CRC_STRIP为CRC剥离使能寄存器。                                                      */
+#define SRE_GMAC_MODE_CHANGE_EN_REG                        (0x01B4UL)                          /*MODE_CHANGE_EN为端口模式改变使能寄存器。                                              */
+#define SRE_GMAC_SIXTEEN_BIT_CNTR_REG                      (0x01CCUL)                          /*自协商链接时间寄存器                                                                   */
+#define SRE_GMAC_LD_LINK_COUNTER_REG                       (0x01D0UL)                          /*自协商链接时间更新寄存器                                                              */
+#define SRE_GMAC_LOOP_REG                                  (0x01DCUL)                          /*LOOP_REG为环回补充寄存器。                                                             */
+#define SRE_GMAC_RECV_CONTROL_REG                          (0x01E0UL)                          /*RECV_CONTROL为接收控制寄存器。                                                        */
+#define SRE_GMAC_VLAN_CODE_REG                             (0x01E8UL)                          /*VLAN_CODE为VLAN Code寄存器。                                                            */
+#define SRE_GMAC_RX_OVERRUN_CNT_REG                        (0x01ECUL)                          /*RX_OVERRUN_CNT为FIFO溢出统计寄存器。                                                   */
+#define SRE_GMAC_RX_LENGTHFIELD_ERR_CNT_REG                (0x01F4UL)                          /*RX_LENGTHFIELD_ERR_CNT为含PAD帧统计寄存器。                                             */
+#define SRE_GMAC_RX_FAIL_COMMA_CNT_REG                     (0x01F8UL)                          /*RX_FAIL_COMMA_CNT为字节定界COMMA统计寄存器。                                           */
+#define SRE_GMAC_STATION_ADDR_LOW_0_REG                    (0x0200UL)                          /*STATION_ADDR_LOW为本机MAC地址0寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_0_REG                   (0x0204UL)                          /*STATION_ADDR_HIGH为本机MAC地址0寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_1_REG                    (0x0208UL)                          /*STATION_ADDR_LOW为本机MAC地址1寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_1_REG                   (0x020CUL)                          /*STATION_ADDR_HIGH为本机MAC地址1寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_2_REG                    (0x0210UL)                          /*STATION_ADDR_LOW为本机MAC地址2寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_2_REG                   (0x0214UL)                          /*STATION_ADDR_HIGH为本机MAC地址2寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_3_REG                    (0x0218UL)                          /*STATION_ADDR_LOW为本机MAC地址3寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_3_REG                   (0x021CUL)                          /*STATION_ADDR_HIGH为本机MAC地址3寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_4_REG                    (0x0220UL)                          /*STATION_ADDR_LOW为本机MAC地址4寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_4_REG                   (0x0224UL)                          /*STATION_ADDR_HIGH为本机MAC地址4寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_5_REG                    (0x0228UL)                          /*STATION_ADDR_LOW为本机MAC地址5寄存器1。                                               */
+#define SRE_GMAC_STATION_ADDR_HIGH_5_REG                   (0x022CUL)                          /*STATION_ADDR_HIGH为本机MAC地址5寄存器2。                                              */
+#define SRE_GMAC_STATION_ADDR_LOW_MSK_0_REG                (0x0230UL)                          /*STATION_ADDR_LOW为本机MAC地址0寄存器1的掩码。                                        */
+#define SRE_GMAC_STATION_ADDR_HIGH_MSK_0_REG               (0x0234UL)                          /*STATION_ADDR_HIGH为本机MAC地址0寄存器2的掩码。                                       */
+#define SRE_GMAC_STATION_ADDR_LOW_MSK_1_REG                (0x0238UL)                          /*STATION_ADDR_LOW为本机MAC地址1寄存器1的掩码。                                        */
+#define SRE_GMAC_STATION_ADDR_HIGH_MSK_1_REG               (0x023CUL)                          /*STATION_ADDR_HIGH为本机MAC地址1寄存器2的掩码。                                       */
+#define SRE_GMAC_MAC_SKIP_LEN_REG                          (0x0240UL)                          /*SKIP_LEN为报文头不解析字段长度。                                                      */
+#define SRE_GMAC_DEBUG_RD_DATA_REG                         (0x0244UL)                          /*1588发送方向debug时，抓到包的数据 +mac_num*0x4                                                   */
+#define SRE_GMAC_DEBUG_PKT_PTR_REG                         (0x0344UL)                          /*报文指针寄存器                                                                        */
+#define SRE_GMAC_DEBUG_EN_REG                              (0x0348UL)                          /*捕获使能                                                                               */
+#define SRE_GMAC_INTR_STATE_REG                            (0x034CUL)                          /*中断状态                                                                               */
+#define SRE_GMAC_INTR_CLR_REG                              (0x0350UL)                          /*中断清除寄存器                                                                        */
+#define SRE_GMAC_INTR_MSK_REG                              (0x0354UL)                          /*中断屏蔽寄存器                                                                        */
+#define SRE_GMAC_SEQ_ID_REG                                (0x0358UL)                          /*捕获的sequence ID和时间戳的[79:64]                                                     */
+#define SRE_GMAC_STP_63_TO_32_REG                          (0x035CUL)                          /*上报时间戳的[63:32]                                                                     */
+#define SRE_GMAC_STP_31_TO_0_REG                           (0x0360UL)                          /*上报时间戳的[31:0]                                                                      */
+#define SRE_GMAC_DBG_GRP0_VLD_WORDS_REG                    (0x0364UL)                          /*第一组RAM中捕获的有效字数                                                             */
+#define SRE_GMAC_DBG_GRP1_VLD_WORDS_REG                    (0x0368UL)                          /*第二组RAM中捕获的有效字数                                                             */
+#define SRE_GMAC_DMAC_EN_REG                               (0x0370UL)                          /*DMAC为共用的32个不带掩码的本地MAC地址使能。                                          */
+#define SRE_GMAC_DMAC_WITH_MSK_EN_REG                      (0x0374UL)                          /*DMAC为共用的32个带掩码的本地MAC地址使能。。                                           */
+#define SRE_GMAC_TX_LOOP_PKT_PRI_REG                       (0x0378UL)                          /*指定环回报文优先级配置。                                                              */
+
+/******************************************************************************/
+/*                      P650 PPE_COMMON 寄存器定义                            */
+/******************************************************************************/
+
+#if 0         /* z00202052 */
+#define SRE_PPE_COMMON_BASE                                   (0x128c0000)
+#else
+#define SRE_PPE_COMMON_BASE                                   (0xe28c0000)
+#endif        /* z00202052 */
+
+#define SRE_PPE_CFG_WE_ADDR_REG      (SRE_PPE_COMMON_BASE + 0x0)   /* PPE_CFG_WE_ADDR为POE的写地址。 */
+#define SRE_PPE_CFG_BMU_ADDR_REG     (SRE_PPE_COMMON_BASE + 0x4)   /* PPE_CFG_BMU_ADDR为BMU申请和释放缓存的基地址。 */
+#define SRE_PPE_CFG_RX_BUFF_REQ_TIMER_REG  (SRE_PPE_COMMON_BASE + 0x8)   /* PPE_CFG_RX_BUFFREQ_TIMER为接收缓存申请超时寄存器。 */
+#define SRE_PPE_CFG_VMID_REG         (SRE_PPE_COMMON_BASE + 0xC)   /* PPE_CFG_VMID为访问BMU和POE的VMID。 */
+#define SRE_PPE_CFG_QOS_DROP_EN_REG  (SRE_PPE_COMMON_BASE + 0x10)  /* PPE_CFG_QOS_DROP_EN是32个POOL的按QoS丢包使能 */
+#define SRE_PPE_CFG_TM_ADDR_REG      (SRE_PPE_COMMON_BASE + 0x14)  /* PPE_CFG_TM_ADDR为TM的丢包寄存器地址，向该地址推包，TM完成丢弃。 */
+#define SRE_PPE_CFG_REQ_BMU_OUT_DEPTH_REG  (SRE_PPE_COMMON_BASE + 0x18)  /* PPE_CFG_REQ_BMU_OUT_DEPTH为向BMU申请缓存时的outstanding深度。 */
+#define SRE_PPE_CFG_CMM_TO_BE_RST_REG  (SRE_PPE_COMMON_BASE + 0x1C)  /* PPE_CFG_CMM_TO_BE_RST为该通道是否将要复位。 */
+#define SRE_PPE_CFG_MEM_TIMING_REG   (SRE_PPE_COMMON_BASE + 0x20)  /* PPE_CFG_MEM_TIMING为PPE的MEM时序配置。 */
+#define SRE_PPE_CFG_BP_BUS_TIME_REG  (SRE_PPE_COMMON_BASE + 0x24)  /* PPE_CFG_BP_BUS_TIME为PPE的反压总线的超时寄存器配置。 */
+#define SRE_PPE_CFG_RX_CFF_ADDR_0_REG  (SRE_PPE_COMMON_BASE + 0x100)  /* PPE_CFG_RX_CFF_ADD是32个POOL的对应FIFO被动分配BUF的地址，0x0100~0x017C依次是POOL0~POOL31的对应FIFO被动分配BUF的地址 */
+#define SRE_PPE_CFG_RX_CFF_ADDR_1_REG  (SRE_PPE_COMMON_BASE + 0x104)  /* PPE_CFG_RX_CFF_ADD是32个POOL的对应FIFO被动分配BUF的地址，0x0100~0x017C依次是POOL0~POOL31的对应FIFO被动分配BUF的地址 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_0_THRSLD_0_REG  (SRE_PPE_COMMON_BASE + 0x200)  /* PPE_CFG_RX_BUFF_FIFO_THRSLD为缓存FIFO水线寄存器。
+0x0200~0x027C依次是缓存FIFO_0~FIFO_31的水线配置寄存器 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_0_THRSLD_1_REG  (SRE_PPE_COMMON_BASE + 0x204)  /* PPE_CFG_RX_BUFF_FIFO_THRSLD为缓存FIFO水线寄存器。
+0x0200~0x027C依次是缓存FIFO_0~FIFO_31的水线配置寄存器 */
+#define SRE_PPE_CFG_POOL_GRP_0_REG   (SRE_PPE_COMMON_BASE + 0x300)  /* PPE_CFG_POOL_GRP是32个POOL可以分配给哪些GRP使用，0x0300~0x037C依次是POOL0~POOL31的配置 */
+#define SRE_PPE_CFG_POOL_GRP_1_REG   (SRE_PPE_COMMON_BASE + 0x304)  /* PPE_CFG_POOL_GRP是32个POOL可以分配给哪些GRP使用，0x0300~0x037C依次是POOL0~POOL31的配置 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_RX_BUF_SIZE_0_REG  (SRE_PPE_COMMON_BASE + 0x400)  /* PPE_CFG_RX_BUFF_FIFO_RX_BUF_SIZE为缓存FIFO的缓存大小配置寄存器。
+0x0400~0x047C依次是缓存FIFO_0~FIFO_31的缓存大小配置寄存器 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_RX_BUF_SIZE_1_REG  (SRE_PPE_COMMON_BASE + 0x404)  /* PPE_CFG_RX_BUFF_FIFO_RX_BUF_SIZE为缓存FIFO的缓存大小配置寄存器。
+0x0400~0x047C依次是缓存FIFO_0~FIFO_31的缓存大小配置寄存器 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_SIZE_0_REG  (SRE_PPE_COMMON_BASE + 0x500)  /* PPE_CFG_RX_BUFF_FIFO_SIZE缓存FIFO的大小配置寄存器。
+0x0500~0x057C依次是缓存FIFO_0~FIFO_31的大小配置寄存器 */
+#define SRE_PPE_CFG_RX_BUFF_FIFO_SIZE_1_REG  (SRE_PPE_COMMON_BASE + 0x504)  /* PPE_CFG_RX_BUFF_FIFO_SIZE缓存FIFO的大小配置寄存器。
+0x0500~0x057C依次是缓存FIFO_0~FIFO_31的大小配置寄存器 */
+#define SRE_PPE_CFG_TYPE_ITEM_0_REG  (SRE_PPE_COMMON_BASE + 0x2000)  /* PPE_CFG_TYPE_ITEM为需要按类型生成QOS/GRP/VMID的各种报文配置。
+0x2000~0x24FC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_1_REG  (SRE_PPE_COMMON_BASE + 0x2004)  /* PPE_CFG_TYPE_ITEM为需要按类型生成QOS/GRP/VMID的各种报文配置。
+0x2000~0x24FC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_MSK_0_REG  (SRE_PPE_COMMON_BASE + 0x2400)  /* PPE_CFG_TYPE_ITEM0_MSK为需要按类型生成QOS/GRP/VMID的各种报文的掩码配置。
+0x2400~0x27FC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_MSK_1_REG  (SRE_PPE_COMMON_BASE + 0x2404)  /* PPE_CFG_TYPE_ITEM0_MSK为需要按类型生成QOS/GRP/VMID的各种报文的掩码配置。
+0x2400~0x27FC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_QOS_MODE_0_REG  (SRE_PPE_COMMON_BASE + 0x2800)  /* PPE_CFG_TYPE_ITEM_QOS_MODE为需要按类型生成QOS/GRP/VMID的各种报文生成方式配置1。
+0x2800~0x2BFC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_QOS_MODE_1_REG  (SRE_PPE_COMMON_BASE + 0x2804)  /* PPE_CFG_TYPE_ITEM_QOS_MODE为需要按类型生成QOS/GRP/VMID的各种报文生成方式配置1。
+0x2800~0x2BFC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_QOS_OFFSET_0_REG  (SRE_PPE_COMMON_BASE + 0x2C00)  /* PPE_CFG_TYPE_ITEM_QOS_OFFSET为需要按类型生成QOS/GRP/VMID的各种报文生成方式配置2。0x2C00~0x2CFC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_TYPE_ITEM_QOS_OFFSET_1_REG  (SRE_PPE_COMMON_BASE + 0x2C04)  /* PPE_CFG_TYPE_ITEM_QOS_OFFSET为需要按类型生成QOS/GRP/VMID的各种报文生成方式配置2。0x2C00~0x2CFC依次是第0种~第255种报文的配置 */
+#define SRE_PPE_CFG_QOS_TBL0_0_REG   (SRE_PPE_COMMON_BASE + 0x4000)  /* PPE_CFG_QOS_TBL0是生成QOS的第0张表。 */
+#define SRE_PPE_CFG_QOS_TBL0_1_REG   (SRE_PPE_COMMON_BASE + 0x4004)  /* PPE_CFG_QOS_TBL0是生成QOS的第0张表。 */
+#define SRE_PPE_CFG_QOS_TBL1_0_REG   (SRE_PPE_COMMON_BASE + 0x4020)  /* PPE_CFG_QOS_TBL1是生成QOS的第1张表。 */
+#define SRE_PPE_CFG_QOS_TBL1_1_REG   (SRE_PPE_COMMON_BASE + 0x4024)  /* PPE_CFG_QOS_TBL1是生成QOS的第1张表。 */
+#define SRE_PPE_CFG_QOS_TBL2_0_REG   (SRE_PPE_COMMON_BASE + 0x4040)  /* PPE_CFG_QOS_TBL2是生成QOS的第2张表。 */
+#define SRE_PPE_CFG_QOS_TBL2_1_REG   (SRE_PPE_COMMON_BASE + 0x4044)  /* PPE_CFG_QOS_TBL2是生成QOS的第2张表。 */
+#define SRE_PPE_CFG_QOS_TBL3_0_REG   (SRE_PPE_COMMON_BASE + 0x4060)  /* PPE_CFG_QOS_TBL3是生成QOS的第3张表。 */
+#define SRE_PPE_CFG_QOS_TBL3_1_REG   (SRE_PPE_COMMON_BASE + 0x4064)  /* PPE_CFG_QOS_TBL3是生成QOS的第3张表。 */
+#define SRE_PPE_CFG_QOS_TBL4_0_REG   (SRE_PPE_COMMON_BASE + 0x4080)  /* PPE_CFG_QOS_TBL4是生成QOS的第4张表。 */
+#define SRE_PPE_CFG_QOS_TBL4_1_REG   (SRE_PPE_COMMON_BASE + 0x4084)  /* PPE_CFG_QOS_TBL4是生成QOS的第4张表。 */
+#define SRE_PPE_CFG_QOS_TBL5_0_REG   (SRE_PPE_COMMON_BASE + 0x40A0)  /* PPE_CFG_QOS_TBL5是生成QOS的第5张表。 */
+#define SRE_PPE_CFG_QOS_TBL5_1_REG   (SRE_PPE_COMMON_BASE + 0x40A4)  /* PPE_CFG_QOS_TBL5是生成QOS的第5张表。 */
+#define SRE_PPE_CFG_QOS_TBL6_0_REG   (SRE_PPE_COMMON_BASE + 0x40C0)  /* PPE_CFG_QOS_TBL6是生成QOS的第6张表。 */
+#define SRE_PPE_CFG_QOS_TBL6_1_REG   (SRE_PPE_COMMON_BASE + 0x40C4)  /* PPE_CFG_QOS_TBL6是生成QOS的第6张表。 */
+#define SRE_PPE_CFG_QOS_TBL7_0_REG   (SRE_PPE_COMMON_BASE + 0x40E0)  /* PPE_CFG_QOS_TBL7是生成QOS的第7张表。 */
+#define SRE_PPE_CFG_QOS_TBL7_1_REG   (SRE_PPE_COMMON_BASE + 0x40E4)  /* PPE_CFG_QOS_TBL7是生成QOS的第7张表。 */
+#define SRE_PPE_CFG_QOS_TBL_KEY_EN_0_REG  (SRE_PPE_COMMON_BASE + 0x4104)  /* PPE_CFG_QOS_TBL0_KEY_EN是生成QOS的表的键值产生配置寄存器1。0x4104~0x413C依次是表0~表7的配置 */
+#define SRE_PPE_CFG_QOS_TBL_KEY_EN_1_REG  (SRE_PPE_COMMON_BASE + 0x410C)  /* PPE_CFG_QOS_TBL0_KEY_EN是生成QOS的表的键值产生配置寄存器1。0x4104~0x413C依次是表0~表7的配置 */
+#define SRE_PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0_0_REG  (SRE_PPE_COMMON_BASE + 0x5D00)  /* PPE_CFG_GRP_VMID_TBL0_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器0。0x5D00~0x5D50依次是表0~表10的配置 */
+#define SRE_PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0_1_REG  (SRE_PPE_COMMON_BASE + 0x5D08)  /* PPE_CFG_GRP_VMID_TBL0_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器0。0x5D00~0x5D50依次是表0~表10的配置 */
+#define SRE_PPE_CFG_GRP_VMID_TBL_KEY_OFFSET1_0_REG  (SRE_PPE_COMMON_BASE + 0x5D04)  /* PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器1。0x5D04~0x5D54依次是表0~表10的配置 */
+#define SRE_PPE_CFG_GRP_VMID_TBL_KEY_OFFSET1_1_REG  (SRE_PPE_COMMON_BASE + 0x5D0C)  /* PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器1。0x5D04~0x5D54依次是表0~表10的配置 */
+#define SRE_PPE_CFG_GRP_TBL0_0_REG   (SRE_PPE_COMMON_BASE + 0x5000)  /* PPE_CFG_GRP_TBL0是查表生成GRP的第0张表。 */
+#define SRE_PPE_CFG_GRP_TBL0_1_REG   (SRE_PPE_COMMON_BASE + 0x5004)  /* PPE_CFG_GRP_TBL0是查表生成GRP的第0张表。 */
+#define SRE_PPE_CFG_GRP_TBL1_0_REG   (SRE_PPE_COMMON_BASE + 0x5100)  /* PPE_CFG_GRP_TBL1是查表生成GRP的第1张表。 */
+#define SRE_PPE_CFG_GRP_TBL1_1_REG   (SRE_PPE_COMMON_BASE + 0x5104)  /* PPE_CFG_GRP_TBL1是查表生成GRP的第1张表。 */
+#define SRE_PPE_CFG_GRP_TBL2_0_REG   (SRE_PPE_COMMON_BASE + 0x5200)  /* PPE_CFG_GRP_TBL2是查表生成GRP的第2张表。 */
+#define SRE_PPE_CFG_GRP_TBL2_1_REG   (SRE_PPE_COMMON_BASE + 0x5204)  /* PPE_CFG_GRP_TBL2是查表生成GRP的第2张表。 */
+#define SRE_PPE_CFG_GRP_TBL3_0_REG   (SRE_PPE_COMMON_BASE + 0x5300)  /* PPE_CFG_GRP_TBL3是查表生成GRP的第3张表。 */
+#define SRE_PPE_CFG_GRP_TBL3_1_REG   (SRE_PPE_COMMON_BASE + 0x5304)  /* PPE_CFG_GRP_TBL3是查表生成GRP的第3张表。 */
+#define SRE_PPE_CFG_GRP_TBL4_0_REG   (SRE_PPE_COMMON_BASE + 0x5400)  /* PPE_CFG_GRP_TBL4是查表生成GRP的第4张表。 */
+#define SRE_PPE_CFG_GRP_TBL4_1_REG   (SRE_PPE_COMMON_BASE + 0x5404)  /* PPE_CFG_GRP_TBL4是查表生成GRP的第4张表。 */
+#define SRE_PPE_CFG_GRP_TBL5_0_REG   (SRE_PPE_COMMON_BASE + 0x5500)  /* PPE_CFG_GRP_TBL5是查表生成GRP的第5张表。 */
+#define SRE_PPE_CFG_GRP_TBL5_1_REG   (SRE_PPE_COMMON_BASE + 0x5504)  /* PPE_CFG_GRP_TBL5是查表生成GRP的第5张表。 */
+#define SRE_PPE_CFG_GRP_TBL6_0_REG   (SRE_PPE_COMMON_BASE + 0x5600)  /* PPE_CFG_GRP_TBL6是查表生成GRP的第6张表。 */
+#define SRE_PPE_CFG_GRP_TBL6_1_REG   (SRE_PPE_COMMON_BASE + 0x5604)  /* PPE_CFG_GRP_TBL6是查表生成GRP的第6张表。 */
+#define SRE_PPE_CFG_GRP_TBL7_0_REG   (SRE_PPE_COMMON_BASE + 0x5700)  /* PPE_CFG_GRP_TBL7是查表生成GRP的第7张表。 */
+#define SRE_PPE_CFG_GRP_TBL7_1_REG   (SRE_PPE_COMMON_BASE + 0x5704)  /* PPE_CFG_GRP_TBL7是查表生成GRP的第7张表。 */
+#define SRE_PPE_CFG_GRP_TBL8_0_REG   (SRE_PPE_COMMON_BASE + 0x5800)  /* PPE_CFG_GRP_TBL8是查表生成GRP的第8张表。 */
+#define SRE_PPE_CFG_GRP_TBL8_1_REG   (SRE_PPE_COMMON_BASE + 0x5804)  /* PPE_CFG_GRP_TBL8是查表生成GRP的第8张表。 */
+#define SRE_PPE_CFG_GRP_TBL9_0_REG   (SRE_PPE_COMMON_BASE + 0x5900)  /* PPE_CFG_GRP_TBL9是查表生成GRP的第9张表。 */
+#define SRE_PPE_CFG_GRP_TBL9_1_REG   (SRE_PPE_COMMON_BASE + 0x5904)  /* PPE_CFG_GRP_TBL9是查表生成GRP的第9张表。 */
+#define SRE_PPE_CFG_GRP_TBL10_0_REG  (SRE_PPE_COMMON_BASE + 0x5A00)  /* PPE_CFG_GRP_TBL10是查表生成GRP的第10张表。 */
+#define SRE_PPE_CFG_GRP_TBL10_1_REG  (SRE_PPE_COMMON_BASE + 0x5A04)  /* PPE_CFG_GRP_TBL10是查表生成GRP的第10张表。 */
+#define SRE_PPE_CFG_GRP_CMP_TBL_VALUE_0_REG  (SRE_PPE_COMMON_BASE + 0x5B00)  /* PPE_CFG_GRP_CMP_TBL_VALUE是比较方式生成GRP的GRP的配置值 */
+#define SRE_PPE_CFG_GRP_CMP_TBL_VALUE_1_REG  (SRE_PPE_COMMON_BASE + 0x5B04)  /* PPE_CFG_GRP_CMP_TBL_VALUE是比较方式生成GRP的GRP的配置值 */
+#define SRE_PPE_CFG_GRP_CMP_TBL_VALUE_2_REG  (SRE_PPE_COMMON_BASE + 0x5B20)  /* PPE_CFG_GRP_CMP_TBL_VALUE是比较方式生成GRP的GRP的配置值 */
+#define SRE_PPE_CFG_GRP_CMP_TBL_VALUE_3_REG  (SRE_PPE_COMMON_BASE + 0x5B24)  /* PPE_CFG_GRP_CMP_TBL_VALUE是比较方式生成GRP的GRP的配置值 */
+#define SRE_PPE_CFG_VMID_TBL0_0_REG  (SRE_PPE_COMMON_BASE + 0x6000)  /* PPE_CFG_VMID_TBL0是生成vmid的第0张表。 */
+#define SRE_PPE_CFG_VMID_TBL0_1_REG  (SRE_PPE_COMMON_BASE + 0x6004)  /* PPE_CFG_VMID_TBL0是生成vmid的第0张表。 */
+#define SRE_PPE_CFG_VMID_TBL1_0_REG  (SRE_PPE_COMMON_BASE + 0x6080)  /* PPE_CFG_VMID_TBL1是生成vmid的第1张表。 */
+#define SRE_PPE_CFG_VMID_TBL1_1_REG  (SRE_PPE_COMMON_BASE + 0x6084)  /* PPE_CFG_VMID_TBL1是生成vmid的第1张表。 */
+#define SRE_PPE_CFG_VMID_TBL2_0_REG  (SRE_PPE_COMMON_BASE + 0x6100)  /* PPE_CFG_VMID_TBL2是生成vmid的第2张表。 */
+#define SRE_PPE_CFG_VMID_TBL2_1_REG  (SRE_PPE_COMMON_BASE + 0x6104)  /* PPE_CFG_VMID_TBL2是生成vmid的第2张表。 */
+#define SRE_PPE_CFG_VMID_TBL3_0_REG  (SRE_PPE_COMMON_BASE + 0x6180)  /* PPE_CFG_VMID_TBL3是生成vmid的第3张表。 */
+#define SRE_PPE_CFG_VMID_TBL3_1_REG  (SRE_PPE_COMMON_BASE + 0x6184)  /* PPE_CFG_VMID_TBL3是生成vmid的第3张表。 */
+#define SRE_PPE_CFG_VMID_TBL4_0_REG  (SRE_PPE_COMMON_BASE + 0x6200)  /* PPE_CFG_VMID_TBL4是生成vmid的第4张表。 */
+#define SRE_PPE_CFG_VMID_TBL4_1_REG  (SRE_PPE_COMMON_BASE + 0x6204)  /* PPE_CFG_VMID_TBL4是生成vmid的第4张表。 */
+#define SRE_PPE_CFG_VMID_TBL5_0_REG  (SRE_PPE_COMMON_BASE + 0x6280)  /* PPE_CFG_VMID_TBL5是生成vmid的第5张表。 */
+#define SRE_PPE_CFG_VMID_TBL5_1_REG  (SRE_PPE_COMMON_BASE + 0x6284)  /* PPE_CFG_VMID_TBL5是生成vmid的第5张表。 */
+#define SRE_PPE_CFG_VMID_TBL6_0_REG  (SRE_PPE_COMMON_BASE + 0x6300)  /* PPE_CFG_VMID_TBL6是生成vmid的第6张表。 */
+#define SRE_PPE_CFG_VMID_TBL6_1_REG  (SRE_PPE_COMMON_BASE + 0x6304)  /* PPE_CFG_VMID_TBL6是生成vmid的第6张表。 */
+#define SRE_PPE_CFG_VMID_TBL7_0_REG  (SRE_PPE_COMMON_BASE + 0x6380)  /* PPE_CFG_VMID_TBL7是生成vmid的第7张表。 */
+#define SRE_PPE_CFG_VMID_TBL7_1_REG  (SRE_PPE_COMMON_BASE + 0x6384)  /* PPE_CFG_VMID_TBL7是生成vmid的第7张表。 */
+#define SRE_PPE_CFG_VMID_TBL8_0_REG  (SRE_PPE_COMMON_BASE + 0x6400)  /* PPE_CFG_VMID_TBL8是生成vmid的第8张表。 */
+#define SRE_PPE_CFG_VMID_TBL8_1_REG  (SRE_PPE_COMMON_BASE + 0x6404)  /* PPE_CFG_VMID_TBL8是生成vmid的第8张表。 */
+#define SRE_PPE_CFG_VMID_TBL9_0_REG  (SRE_PPE_COMMON_BASE + 0x6480)  /* PPE_CFG_VMID_TBL9是生成vmid的第9张表。 */
+#define SRE_PPE_CFG_VMID_TBL9_1_REG  (SRE_PPE_COMMON_BASE + 0x6484)  /* PPE_CFG_VMID_TBL9是生成vmid的第9张表。 */
+#define SRE_PPE_CFG_VMID_TBL10_0_REG  (SRE_PPE_COMMON_BASE + 0x6500)  /* PPE_CFG_VMID_TBL0是生成vmid的第10张表。 */
+#define SRE_PPE_CFG_VMID_TBL10_1_REG  (SRE_PPE_COMMON_BASE + 0x6504)  /* PPE_CFG_VMID_TBL0是生成vmid的第10张表。 */
+#define SRE_PPE_CFG_VMID_CMP_TBL_VALUE_0_REG  (SRE_PPE_COMMON_BASE + 0x6580)  /* PPE_CFG_VMID_CMP_TBL_VALUE是比较方式生成VMID的VMID的配置值 */
+#define SRE_PPE_CFG_VMID_CMP_TBL_VALUE_1_REG  (SRE_PPE_COMMON_BASE + 0x6584)  /* PPE_CFG_VMID_CMP_TBL_VALUE是比较方式生成VMID的VMID的配置值 */
+#define SRE_PPE_CFG_VMID_CMP_TBL_VALUE_2_REG  (SRE_PPE_COMMON_BASE + 0x6590)  /* PPE_CFG_VMID_CMP_TBL_VALUE是比较方式生成VMID的VMID的配置值 */
+#define SRE_PPE_CFG_VMID_CMP_TBL_VALUE_3_REG  (SRE_PPE_COMMON_BASE + 0x6594)  /* PPE_CFG_VMID_CMP_TBL_VALUE是比较方式生成VMID的VMID的配置值 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL0_0_REG  (SRE_PPE_COMMON_BASE + 0x7000)  /* PPE_CFG_GRP_VMID_CMP_TBL0是比较方式生成GRP_VMID的第0张表。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL1_0_REG  (SRE_PPE_COMMON_BASE + 0x7100)  /* PPE_CFG_GRP_VMID_CMP_TBL1是比较方式生成GRP_VMID的第1张表。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL2_0_REG  (SRE_PPE_COMMON_BASE + 0x7200)  /* PPE_CFG_GRP_VMID_CMP_TBL2是比较方式生成GRP_VMID的第2张表。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL3_0_REG  (SRE_PPE_COMMON_BASE + 0x7300)  /* PPE_CFG_GRP_VMID_CMP_TBL3是比较方式生成GRP_VMID的第3张表。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL0_MSK_0_REG  (SRE_PPE_COMMON_BASE + 0x7B00)  /* PPE_CFG_GRP_VMID_CMP_TBL0_MSK是比较方式生成GRP_VMID的第0张表的掩码值。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL1_MSK_0_REG  (SRE_PPE_COMMON_BASE + 0x7B08)  /* PPE_CFG_GRP_VMID_CMP_TBL1_MSK是比较方式生成GRP_VMID的第1张表的掩码值。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL2_MSK_0_REG  (SRE_PPE_COMMON_BASE + 0x7B10)  /* PPE_CFG_GRP_VMID_CMP_TBL2_MSK是比较方式生成GRP_VMID的第2张表的掩码值。 */
+#define SRE_PPE_CFG_GRP_VMID_CMP_TBL3_MSK_0_REG  (SRE_PPE_COMMON_BASE + 0x7B18)  /* PPE_CFG_GRP_VMID_CMP_TBL3_MSK是比较方式生成GRP_VMID的第3张表的掩码值。 */
+#define SRE_PPE_INTEN_0_REG          (SRE_PPE_COMMON_BASE + 0x8000)  /* PPE_INTEN_0是使能中断寄存器0。 */
+#define SRE_PPE_RINT_0_REG           (SRE_PPE_COMMON_BASE + 0x8004)  /* PPE_RINT_0是原始中断寄存器0。 */
+#define SRE_PPE_INTSTS_0_REG         (SRE_PPE_COMMON_BASE + 0x8008)  /* PPE_INTSTS_0是中断状态寄存器0。 */
+#define SRE_PPE_INTEN_1_REG          (SRE_PPE_COMMON_BASE + 0x8010)  /* PPE_INTEN_1是使能中断寄存器1。 */
+#define SRE_PPE_RINT_1_REG           (SRE_PPE_COMMON_BASE + 0x8014)  /* PPE_RINT_1是原始中断寄存器1。 */
+#define SRE_PPE_INTSTS_1_REG         (SRE_PPE_COMMON_BASE + 0x8018)  /* PPE_INTSTS_1是中断状态寄存器1。 */
+#define SRE_PPE_INTEN_2_REG          (SRE_PPE_COMMON_BASE + 0x8020)  /* PPE_RINT_2是使能中断寄存器2。 */
+#define SRE_PPE_RINT_2_REG           (SRE_PPE_COMMON_BASE + 0x8024)  /* PPE_RINT_2是原始中断寄存器2。 */
+#define SRE_PPE_INTSTS_2_REG         (SRE_PPE_COMMON_BASE + 0x8028)  /* PPE_INTSTS_2是中断状态寄存器2。 */
+#define SRE_PPE_CFG_STS_MODE_0_REG   (SRE_PPE_COMMON_BASE + 0xA000)  /* PPE_CFG_STS_MODE_0是寄存器属性为为CNT_CYC读清使能寄存器0。 */
+#define SRE_PPE_CFG_STS_MODE_1_REG   (SRE_PPE_COMMON_BASE + 0xA004)  /* PPE_CFG_STS_MODE_1是寄存器属性为为CNT_CYC读清使能寄存器1。 */
+#define SRE_PPE_HIS_PKT_GRP_CNT_0_REG  (SRE_PPE_COMMON_BASE + 0xA100)  /* PPE_HIS_PKT_GRP_CN是接收报文按GRP的统计。 */
+#define SRE_PPE_HIS_PKT_GRP_CNT_1_REG  (SRE_PPE_COMMON_BASE + 0xA104)  /* PPE_HIS_PKT_GRP_CN是接收报文按GRP的统计。 */
+#define SRE_PPE_HIS_PKT_QOS_CNT_0_REG  (SRE_PPE_COMMON_BASE + 0xA180)  /* PPE_HIS_PKT_QOS_CN是接收报文按QOS的统计。 */
+#define SRE_PPE_HIS_PKT_QOS_CNT_1_REG  (SRE_PPE_COMMON_BASE + 0xA184)  /* PPE_HIS_PKT_QOS_CN是接收报文按QOS的统计。 */
+#define SRE_PPE_HIS_DROP_PKT_QOS_CNT_0_REG  (SRE_PPE_COMMON_BASE + 0xA1A0)  /* PPE_HIS_DROP_PKT_QOS_CNT是丢弃报文按QOS的统计。 */
+#define SRE_PPE_HIS_DROP_PKT_QOS_CNT_1_REG  (SRE_PPE_COMMON_BASE + 0xA1A4)  /* PPE_HIS_DROP_PKT_QOS_CNT是丢弃报文按QOS的统计。 */
+#define SRE_PPE_HIS_MST_WR_CNT_0_REG  (SRE_PPE_COMMON_BASE + 0xA1C0)  /* PPE_HIS_MST_WR_CNT是MASTER写操作的统计。 */
+#define SRE_PPE_HIS_MST_WR_CNT_1_REG  (SRE_PPE_COMMON_BASE + 0xA1C4)  /* PPE_HIS_MST_WR_CNT是MASTER写操作的统计。 */
+#define SRE_PPE_HIS_MST_RD_CNT_0_REG  (SRE_PPE_COMMON_BASE + 0xA1D8)  /* PPE_HIS_MST_RD_CNT是MASTER写操作的统计。 */
+#define SRE_PPE_HIS_MST_RD_CNT_1_REG  (SRE_PPE_COMMON_BASE + 0xA1DC)  /* PPE_HIS_MST_RD_CNT是MASTER写操作的统计。 */
+#define SRE_PPE_HIS_REQ_BMU_FAIL_CNT_REG  (SRE_PPE_COMMON_BASE + 0xA1F0)  /* PPE_HIS_REQ_BMU_FAIL_CNT是申请BMU失败的统计。 */
+#define SRE_PPE_HIS_REQ_BMU_OK_CNT_REG  (SRE_PPE_COMMON_BASE + 0xA1F4)  /* PPE_HIS_REQ_BMU_OK_CNT是申请BMU成功的统计。 */
+#define SRE_PPE_CURR_BUF_CNT_0_REG   (SRE_PPE_COMMON_BASE + 0xA200)  /* PPE_CURR_BUF_CNT。
+0xA200~0xA27C依次是缓存pool_0~pool_31的缓存指针个数 */
+#define SRE_PPE_CURR_BUF_CNT_1_REG   (SRE_PPE_COMMON_BASE + 0xA204)  /* PPE_CURR_BUF_CNT。
+0xA200~0xA27C依次是缓存pool_0~pool_31的缓存指针个数 */
+#define SRE_PPE_CURR_CMM_CAN_RST_REG  (SRE_PPE_COMMON_BASE + 0xA300)  /* PPE_CURR_CAN_RST为该通道是否可以复位。 */
+#define SRE_PPE_HIS_FIFO_ERR_REG     (SRE_PPE_COMMON_BASE + 0xA304)  /* PPE_HIS_FIFO_ERR是内部FIFO溢出。 */
+#define SRE_PPE_CURR_FIFO_0_REG      (SRE_PPE_COMMON_BASE + 0xA308)  /* PPE_CURR_FIFO_0为BMU返回数据FIFO的状态。 */
+#define SRE_PPE_CURR_FIFO_1_REG      (SRE_PPE_COMMON_BASE + 0xA30C)  /* PPE_CURR_FIFO_0为BMU申请命令FIFO的状态。 */
+#define SRE_PPE_HIS_MST_RD_LAT_0_REG  (SRE_PPE_COMMON_BASE + 0xA310)  /* PPE_HIS_MST_RD_LAT是MASTER读操作的延时统计。 */
+#define SRE_PPE_HIS_MST_RD_LAT_1_REG  (SRE_PPE_COMMON_BASE + 0xA314)  /* PPE_HIS_MST_RD_LAT是MASTER读操作的延时统计。 */
+#define SRE_PPE_HIS_MST_WR_LAT_0_REG  (SRE_PPE_COMMON_BASE + 0xA328)  /* PPE_HIS_MST_WR_LAT是MASTER写操作的延时统计。 */
+#define SRE_PPE_HIS_MST_WR_LAT_1_REG  (SRE_PPE_COMMON_BASE + 0xA32C)  /* PPE_HIS_MST_WR_LAT是MASTER写操作的延时统计。 */
+#define SRE_PPE_HIS_MST_RD_STS_1_0_REG  (SRE_PPE_COMMON_BASE + 0xA340)  /* PPE_HIS_MST_RD_STS_1是MASTER读操作的状态1。 */
+#define SRE_PPE_HIS_MST_RD_STS_1_1_REG  (SRE_PPE_COMMON_BASE + 0xA344)  /* PPE_HIS_MST_RD_STS_1是MASTER读操作的状态1。 */
+#define SRE_PPE_HIS_MST_RD_STS_2_0_REG  (SRE_PPE_COMMON_BASE + 0xA358)  /* PPE_HIS_MST_RD_STS_2是MASTER读操作的状态2。 */
+#define SRE_PPE_HIS_MST_RD_STS_2_1_REG  (SRE_PPE_COMMON_BASE + 0xA35C)  /* PPE_HIS_MST_RD_STS_2是MASTER读操作的状态2。 */
+#define SRE_PPE_HIS_MST_WR_STS_1_0_REG  (SRE_PPE_COMMON_BASE + 0xA370)  /* PPE_HIS_MST_RD_STS_1是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_WR_STS_1_1_REG  (SRE_PPE_COMMON_BASE + 0xA374)  /* PPE_HIS_MST_RD_STS_1是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_WR_STS_2_0_REG  (SRE_PPE_COMMON_BASE + 0xA388)  /* PPE_HIS_MST_RD_STS_2是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_WR_STS_2_1_REG  (SRE_PPE_COMMON_BASE + 0xA38C)  /* PPE_HIS_MST_RD_STS_2是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_WR_STS_3_0_REG  (SRE_PPE_COMMON_BASE + 0xA3A0)  /* PPE_HIS_MST_RD_STS_3是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_WR_STS_3_1_REG  (SRE_PPE_COMMON_BASE + 0xA3A4)  /* PPE_HIS_MST_RD_STS_3是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_RD_STS_3_0_REG  (SRE_PPE_COMMON_BASE + 0xA3B8)  /* PPE_HIS_MST_RD_STS_3是MASTER写操作的状态。 */
+#define SRE_PPE_HIS_MST_RD_STS_3_1_REG  (SRE_PPE_COMMON_BASE + 0xA3BC)  /* PPE_HIS_MST_RD_STS_3是MASTER写操作的状态。 */
+#define SRE_PPE_CFG_MST_STS_CLR_0_REG  (SRE_PPE_COMMON_BASE + 0xA3D0)  /* PPE_CFG_MST_STS_CLR是MASTER统计清除寄存器。 */
+#define SRE_PPE_CFG_MST_STS_CLR_1_REG  (SRE_PPE_COMMON_BASE + 0xA3D4)  /* PPE_CFG_MST_STS_CLR是MASTER统计清除寄存器。 */
+#define SRE_PPE_CFG_OAM_TX_ITEM_STS_0_REG  (SRE_PPE_COMMON_BASE + 0xB000)  /* PPE_CFG_OAM_TX_TIEM是Y.1731发送方向的流匹配统计。 */
+#define SRE_PPE_CFG_OAM_TX_ITEM_STS_1_REG  (SRE_PPE_COMMON_BASE + 0xB004)  /* PPE_CFG_OAM_TX_TIEM是Y.1731发送方向的流匹配统计。 */
+#define SRE_PPE_CFG_TIME_SYNC_H_REG  (SRE_PPE_COMMON_BASE + 0xC000)  /* 时间同步秒时间高位配置寄存器。 */
+#define SRE_PPE_CFG_TIME_SYNC_M_REG  (SRE_PPE_COMMON_BASE + 0xC004)  /* 时间同步秒时间低位配置寄存器。 */
+#define SRE_PPE_CFG_TIME_SYNC_L_REG  (SRE_PPE_COMMON_BASE + 0xC008)  /* 时间同步纳秒时间配置寄存器。 */
+#define SRE_PPE_CFG_TIME_SYNC_RDY_REG  (SRE_PPE_COMMON_BASE + 0xC00C)  /* 时间同步使能配置寄存器。 */
+#define SRE_PPE_CFG_PTP_OFFSET_ADD_RDY_REG  (SRE_PPE_COMMON_BASE + 0xC010)  /* 时间同步偏移使能配置寄存器。 */
+#define SRE_PPE_CFG_TIME_CYC_NS_REG  (SRE_PPE_COMMON_BASE + 0xC014)  /* RTC计时时钟周期时间纳秒整数值配置寄存器。 */
+#define SRE_PPE_CFG_TIME_CYC_NS_DEC_REG  (SRE_PPE_COMMON_BASE + 0xC018)  /* RTC计时时钟周期时间纳秒小数值配置寄存器。 */
+#define SRE_PPE_CFG_SYS_CYC_REG      (SRE_PPE_COMMON_BASE + 0xC01C)  /* 系统时钟周期时间配置寄存器。 */
+#define SRE_PPE_CFG_INT_1PPS_EN_REG  (SRE_PPE_COMMON_BASE + 0xC020)  /* 1PPS中断使能寄存器。 */
+#define SRE_PPE_CFG_INTS_1PPS_CLR_REG  (SRE_PPE_COMMON_BASE + 0xC024)  /* 1PPS中断清除寄存器。 */
+#define SRE_PPE_CFG_INTS_1PPS_REG    (SRE_PPE_COMMON_BASE + 0xC028)  /* 1PPS中断状态寄存器。 */
+#define SRE_PPE_CURR_TIME_OUT_H_REG  (SRE_PPE_COMMON_BASE + 0xC02C)  /* 本地时间秒高位输出寄存器。 */
+#define SRE_PPE_CURR_TIME_OUT_L_REG  (SRE_PPE_COMMON_BASE + 0xC030)  /* 本地时间秒低位输出寄存器。 */
+#define SRE_PPE_CURR_TIME_OUT_NS_REG  (SRE_PPE_COMMON_BASE + 0xC034)  /* 本地时间纳秒输出寄存器。 */
+#define SRE_PPE_CFG_TS_CLK_SEL_REG   (SRE_PPE_COMMON_BASE + 0xC038)  /* 本地计时时钟选择寄存器 */
+#define SRE_PPE_CFG_SYS_TIME_OFFSET_REG  (SRE_PPE_COMMON_BASE + 0xC03C)  /* 系统时钟采样时间补偿偏移值配置寄存器。 */
+
+
+/******************************************************************************/
+/*                      P650 PPE_TNL 寄存器定义                               */
+/******************************************************************************/
+
+#if 0         /* z00202052 */
+#define SRE_PPE_TNL_BASE                                   (0x12800000)
+#else
+#define SRE_PPE_TNL_BASE                                   (0xe2800000)
+#endif        /* z00202052 */
+
+#define SRE_PPE_TNL_CFG_TX_FIFO_THRSLD_REG  (SRE_PPE_TNL_BASE + 0x400)  /* PPE_CFG_TX_FIFO_THRSLD为发送FIFO水线寄存器。 */
+#define SRE_PPE_TNL_CFG_RX_FIFO_THRSLD_REG  (SRE_PPE_TNL_BASE + 0x404)  /* PPE_CFG_RX_FIFO_THRSLD为接收FIFO水线寄存器。 */
+#define SRE_PPE_TNL_CFG_MAX_FRAME_LEN_REG  (SRE_PPE_TNL_BASE + 0x408)  /* MAX_FRAME_LEN为接收超长帧界限寄存器。 */
+#define SRE_PPE_TNL_CFG_TX_PAUSE_REG   (SRE_PPE_TNL_BASE + 0x40C)  /* PPE_CFG_TX_PAUSE为发送流控控制寄存器。 */
+#define SRE_PPE_TNL_CFG_RX_FIFO_PAUSE_THRSLD_REG  (SRE_PPE_TNL_BASE + 0x410)  /* PPE_CFG_RX_FIFO_PAUSE_THRSLD为接收FIFO的流控制水线寄存器。 */
+#define SRE_PPE_TNL_CFG_RX_FIFO_BUS_THRSLD_REG  (SRE_PPE_TNL_BASE + 0x414)  /* PPE_CFG_RX_FIFO_BUS_THRSLD为接收FIFO的反压总线的水线寄存器。 */
+#define SRE_PPE_TNL_CFG_TX_BD_ADDR_THRSLD_REG  (SRE_PPE_TNL_BASE + 0x418)  /* PPE_CFG_TX_BD_ADDR_THRSLD为发送描述符地址的FIFO水线寄存器。 */
+#define SRE_PPE_TNL_CFG_XGE_MODE_REG   (SRE_PPE_TNL_BASE + 0x41C)  /* PPE_CFG_XGE_MODE配置该通道对接的是GE还是XGE */
+#define SRE_PPE_TNL_CFG_TX_PKT_BD_ADDR_REG  (SRE_PPE_TNL_BASE + 0x420)  /* PPE_CFG_TX_PKT_BUF_ADDR为发送描述符的地址。 */
+#define SRE_PPE_TNL_CFG_BUS_CTRL_REG   (SRE_PPE_TNL_BASE + 0x424)  /* PPE_CFG_BUS_CTRL为总线控制寄存器 */
+#define SRE_PPE_TNL_CFG_RX_CTRL_REG    (SRE_PPE_TNL_BASE + 0x428)  /* PPE_CFG_RX_CTRL为接收控制寄存器。 */
+#define SRE_PPE_TNL_CFG_RX_WE_TIMER_REG  (SRE_PPE_TNL_BASE + 0x42C)  /* PPE_CFG_RX_PD_TIMER为接收写work entry失败后的超时寄存器。 */
+#define SRE_PPE_TNL_CFG_REL_BMU_TIMER_REG  (SRE_PPE_TNL_BASE + 0x430)  /* PPE_CFG_REL_BMU_TIMER为释放BMU配置寄存器。 */
+#define SRE_PPE_TNL_CFG_PAUSE_IDLE_CNT_REG  (SRE_PPE_TNL_BASE + 0x434)  /* PPE_CFG_PAUSE_IDLE_CNT是发送PAUSE帧控制寄存器 */
+#define SRE_PPE_TNL_CFG_RX_PKT_MODE_REG  (SRE_PPE_TNL_BASE + 0x438)  /* PPE_CFG_RX_PKT_MODE为接收报文输入模式。 */
+#define SRE_PPE_TNL_CFG_RX_VLAN_TAG_REG  (SRE_PPE_TNL_BASE + 0x43C)  /* PPE_CFG_RX_VLAN_TAG是接收报文的2层VLAN的外层tag值 */
+#define SRE_PPE_TNL_CFG_TX_DECT_EN_REG  (SRE_PPE_TNL_BASE + 0x440)  /* PPE_CFG_TX_DECT_EN是发送1588DECT使能 */
+#define SRE_PPE_TNL_CFG_TX_VLAN_TAG_REG  (SRE_PPE_TNL_BASE + 0x444)  /* 发送DECT检测的VLAN的TAG配置寄存器。 */
+#define SRE_PPE_TNL_CFG_TX_PTP_DPN_REG  (SRE_PPE_TNL_BASE + 0x448)  /* 发送DECT检测的PTP报文UDP的目的端口号配置寄存器。 */
+#define SRE_PPE_TNL_CFG_QOS_GRP_VMID_GEN_REG  (SRE_PPE_TNL_BASE + 0x500)  /* PPE_CFG_QOS_GRP_VMID_GEN为QOS、GRP、VMID的生成方式寄存器。 */
+#define SRE_PPE_TNL_CFG_TAG_TT_GEN_REG  (SRE_PPE_TNL_BASE + 0x504)  /* PPE_CFG_TAG_TT_GEN为TAG、TT的生成方式寄存器 */
+#define SRE_PPE_TNL_CFG_PARSE_TAG_REG  (SRE_PPE_TNL_BASE + 0x508)  /* PPE_CFG_PARSE_TAG为解析模式下各元的掩码配置寄存器 */
+#define SRE_PPE_TNL_CFG_TAG_OFFSET_REG  (SRE_PPE_TNL_BASE + 0x50C)  /* PPE_CFG_TAG_OFFSET是掩码模式计算tag时选128字节报文的偏移寄存器配置 */
+#define SRE_PPE_TNL_CFG_TAG_BYTE_MASK1_REG  (SRE_PPE_TNL_BASE + 0x510)  /* PPE_CFG_TAG_BIT_MASK1是掩码模式计算tag时选128字节报文的第0~31字节掩码配置寄存器。 */
+#define SRE_PPE_TNL_CFG_TAG_BYTE_MASK2_REG  (SRE_PPE_TNL_BASE + 0x514)  /* PPE_CFG_TAG_BIT_MASK2是掩码模式计算tag时选128字节报文的第32~63字节字节掩码配置寄存器。 */
+#define SRE_PPE_TNL_CFG_TAG_BYTE_MASK3_REG  (SRE_PPE_TNL_BASE + 0x518)  /* PPE_CFG_TAG_BIT_MASK3是掩码模式计算tag时选128字节报文的第64~95字节掩码配置寄存器。 */
+#define SRE_PPE_TNL_CFG_TAG_BYTE_MASK4_REG  (SRE_PPE_TNL_BASE + 0x51C)  /* PPE_CFG_TAG_BIT_MASK3是掩码模式计算tag时选128字节报文的第96~127字节掩码配置寄存器。 */
+#define SRE_PPE_TNL_CFG_TAG_OTHER_TYPE_REG  (SRE_PPE_TNL_BASE + 0x520)  /* PPE_CFG_TAG_BIT_MASK是解析模式下4种非IP报文ID配置寄存器 */
+#define SRE_PPE_TNL_CFG_TAG_BIT_MASK_REG  (SRE_PPE_TNL_BASE + 0x524)  /* PPE_CFG_TAG_BIT_MASK是掩码模式计算tag时选128字节报文中的2个按位掩码字节的配置寄存器。 */
+#define SRE_PPE_TNL_CFG_AR_TAG1_CFG_REG  (SRE_PPE_TNL_BASE + 0x528)  /* PPE_CFG_AR_TAG1_CFG是AR的特殊VLAN_ID生成指定TAG的配置。 */
+#define SRE_PPE_TNL_CFG_AR_TAG2_CFG_REG  (SRE_PPE_TNL_BASE + 0x52C)  /* PPE_CFG_AR_TAG1_CFG是AR的指定类型报文生成指定TAG的配置。 */
+#define SRE_PPE_TNL_CFG_AR_SPE_CFG_REG  (SRE_PPE_TNL_BASE + 0x530)  /* PPE_CFG_AR_SPE_CFG是AR的2种指定TAG。 */
+#define SRE_PPE_TNL_CFG_PRO_CHECK_EN_REG  (SRE_PPE_TNL_BASE + 0x534)  /* PPE_CFG_PRO_CHECK_EN是协议检查的使能。 */
+#define SRE_PPE_TNL_CFG_RX_PKT_INT_REG  (SRE_PPE_TNL_BASE + 0x538)  /* PPE_CFG_RX_PKT_INT是接收到指定数目报文或接收报文超时上报中断的配置。 */
+#define SRE_PPE_TNL_CFG_HEAT_DECT_TIME0_REG  (SRE_PPE_TNL_BASE + 0x53C)  /* *704* */
+#define SRE_PPE_TNL_CFG_HEAT_DECT_TIME1_REG  (SRE_PPE_TNL_BASE + 0x540)  /* PPE_CFG_HEAT_DECT_TIME1是状态机心跳检测超时寄存器配置寄存器1 */
+#define SRE_PPE_TNL_CFG_TNL_TO_BE_RST_REG  (SRE_PPE_TNL_BASE + 0x544)  /* PPE_CFG_TNL_TO_BE_RST为该通道是否将要复位。 */
+#define SRE_PPE_TNL_CFG_DELAY_CLR_REG  (SRE_PPE_TNL_BASE + 0x548)  /* PPE_CFG_DELAY_CLR是读写DDR的最大延时。 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_0_REG  (SRE_PPE_TNL_BASE + 0x580)  /* PPE_CFG_CPU_ADD_ADDR是16个CPU推送发送描述符的地址，0x0580~0x05BC依次是CPU0~CPU15的推送地址 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_1_REG  (SRE_PPE_TNL_BASE + 0x584)  /* PPE_CFG_CPU_ADD_ADDR是16个CPU推送发送描述符的地址，0x0580~0x05BC依次是CPU0~CPU15的推送地址 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL0_REG  (SRE_PPE_TNL_BASE + 0x5C0)  /* PPE_CFG_CPU_ADD_ADDR_FAIL0是CPU0推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL1_REG  (SRE_PPE_TNL_BASE + 0x5C4)  /* PPE_CFG_CPU_ADD_ADDR_FAIL1是CPU1推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL2_REG  (SRE_PPE_TNL_BASE + 0x5C8)  /* PPE_CFG_CPU_ADD_ADDR_FAIL2是CPU2推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL3_REG  (SRE_PPE_TNL_BASE + 0x5CC)  /* PPE_CFG_CPU_ADD_ADDR_FAIL3是CPU3推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL4_REG  (SRE_PPE_TNL_BASE + 0x5D0)  /* PPE_CFG_CPU_ADD_ADDR_FAIL4是CPU4推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL5_REG  (SRE_PPE_TNL_BASE + 0x5D4)  /* PPE_CFG_CPU_ADD_ADDR_FAIL5是CPU5推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL6_REG  (SRE_PPE_TNL_BASE + 0x5D8)  /* PPE_CFG_CPU_ADD_ADDR_FAIL6是CPU6推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL7_REG  (SRE_PPE_TNL_BASE + 0x5DC)  /* PPE_CFG_CPU_ADD_ADDR_FAIL7是CPU7推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL8_REG  (SRE_PPE_TNL_BASE + 0x5E0)  /* PPE_CFG_CPU_ADD_ADDR_FAIL8是CPU8推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL9_REG  (SRE_PPE_TNL_BASE + 0x5E4)  /* PPE_CFG_CPU_ADD_ADDR_FAIL9是CPU9推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL10_REG  (SRE_PPE_TNL_BASE + 0x5E8)  /* PPE_CFG_CPU_ADD_ADDR_FAIL10是CPU10推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL11_REG  (SRE_PPE_TNL_BASE + 0x5EC)  /* PPE_CFG_CPU_ADD_ADDR_FAIL11是CPU11推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL12_REG  (SRE_PPE_TNL_BASE + 0x5F0)  /* PPE_CFG_CPU_ADD_ADDR_FAIL12是CPU12推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL13_REG  (SRE_PPE_TNL_BASE + 0x5F4)  /* PPE_CFG_CPU_ADD_ADDR_FAIL13是CPU13推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL14_REG  (SRE_PPE_TNL_BASE + 0x5F8)  /* PPE_CFG_CPU_ADD_ADDR_FAIL14是CPU14推送发送描述符失败指示 */
+#define SRE_PPE_TNL_CFG_CPU_ADD_ADDR_FAIL15_REG  (SRE_PPE_TNL_BASE + 0x5FC)  /* PPE_CFG_CPU_ADD_ADDR_FAIL15是CPU15推送发送描述符失败指示 */
+#define SRE_PPE_TNL_INTEN_REG          (SRE_PPE_TNL_BASE + 0x600)  /* PPE_INTEN是使能中断寄存器。 */
+#define SRE_PPE_TNL_RINT_REG           (SRE_PPE_TNL_BASE + 0x604)  /* PPE_RINT是原始中断寄存器。 */
+#define SRE_PPE_TNL_INTSTS_REG         (SRE_PPE_TNL_BASE + 0x608)  /* PPE_INTSTS是中断状态寄存器。 */
+#define SRE_PPE_TNL_INT_VMID_REG       (SRE_PPE_TNL_BASE + 0x60C)  /* PPE_INT_VMID是中断VMID寄存器。 */
+#define SRE_PPE_TNL_CFG_AXI_DBG_REG    (SRE_PPE_TNL_BASE + 0x610)  /* PPE_CFG_AXI_DBG是AXI DEBUG寄存器。 */
+#define SRE_PPE_TNL_CFG_STS_MODE_REG   (SRE_PPE_TNL_BASE + 0x700)  /* PPE_CFG_STS_MODE是寄存器属性为为CNT_CYC读清使能寄存器1。 */
+#define SRE_PPE_TNL_HIS_RX_PKT_OK_CNT_REG  (SRE_PPE_TNL_BASE + 0x704)  /* PPE_HIS_RX_PKT_OK_CNT是成功接收且添加POE成功的报文统计。 */
+#define SRE_PPE_TNL_HIS_RX_PKT_DROP_FUL_CNT_REG  (SRE_PPE_TNL_BASE + 0x708)  /* PPE_HIS_RX_PKT_DROP_FUL_CNT是因FIFO满整包丢弃的统计。 */
+#define SRE_PPE_TNL_HIS_RX_PKT_DROP_PRT_CNT_REG  (SRE_PPE_TNL_BASE + 0x70C)  /* PPE_HIS_RX_PKT_DROP_PRT_CNT是因FIFO满报文截断的统计。 */
+#define SRE_PPE_TNL_HIS_RX_PKT_LOW_QOS_CNT_REG  (SRE_PPE_TNL_BASE + 0x710)  /* PPE_HIS_RX_PKT_LOW_QOS_CNT是因QOS不足丢弃的报文统计。 */
+#define SRE_PPE_TNL_HIS_RX_PKT_NO_BUF_CNT_REG  (SRE_PPE_TNL_BASE + 0x714)  /* PPE_HIS_RX_PKT_NO_BUF_CNT是因没有对应BUF且接收FIFO丢弃报文的统计。 */
+#define SRE_PPE_TNL_HIS_TX_PKT_OK_CNT_REG  (SRE_PPE_TNL_BASE + 0x718)  /* PPE_HIS_TX_PKT_OK_CNT是成功发送的报文统计。 */
+#define SRE_PPE_TNL_HIS_TX_PKT_EPT_CNT_REG  (SRE_PPE_TNL_BASE + 0x71C)  /* PPE_HIS_TX_PKT_EPT_CNT是发送FIFO空报文截断统计。 */
+#define SRE_PPE_TNL_HIS_TX_PKT_CS_FAIL_CNT_REG  (SRE_PPE_TNL_BASE + 0x720)  /* PPE_HIS_TX_PKT_CS_FAIL_CNT是发送计算checksum失败的报文统计。 */
+#define SRE_PPE_TNL_HIS_REL_BUF_FAIL_CNT_REG  (SRE_PPE_TNL_BASE + 0x724)  /* PPE_HIS_REL_BUF_FAIL_CNT是发送释放缓存失败的统计。 */
+#define SRE_PPE_TNL_HIS_RX_ADD_POE_TM_BMU_FAIL_CNT_REG  (SRE_PPE_TNL_BASE + 0x728)  /* PPE_HIS_RX_ADD_POE_TM_BMU_FAIL_CNT是接收写POE/TM/BMU失败的统计。 */
+#define SRE_PPE_TNL_HIS_RX_ADD_TM_BMU_OK_CNT_REG  (SRE_PPE_TNL_BASE + 0x72C)  /* PPE_HIS_RX_ADD_TM_BMU_OK_CNTT是接收写TM/BMU的成功统计统计。 */
+#define SRE_PPE_TNL_CURR_CFF_DATA_NUM_REG  (SRE_PPE_TNL_BASE + 0x730)  /* PPE_CURR_DATA_NUM为配置FIFO数据个数寄存器。 */
+#define SRE_PPE_TNL_CURR_TNL_CAN_RST_REG  (SRE_PPE_TNL_BASE + 0x734)  /* PPE_CURR_TNL_CAN_RST为该通道是否可以复位。 */
+#define SRE_PPE_TNL_HIS_PRO_ERR_REG    (SRE_PPE_TNL_BASE + 0x738)  /* PPE_HIS_PRO_ERR是协议检查曾经检查到的错误。 */
+#define SRE_PPE_TNL_HIS_TNL_FIFO_ERR_REG  (SRE_PPE_TNL_BASE + 0x73C)  /* PPE_HIS_TNL_FIFO_ERR是内部FIFO溢出。 */
+#define SRE_PPE_TNL_CURR_RX_ST_REG     (SRE_PPE_TNL_BASE + 0x740)  /* PPE_CURR_RX_ST是接收状态机当前状态。 */
+#define SRE_PPE_TNL_CURR_TX_ST_REG     (SRE_PPE_TNL_BASE + 0x744)  /* PPE_CURR_TX_ST是接收状态机当前状态。 */
+#define SRE_PPE_TNL_CURR_RX_FIFO0_REG  (SRE_PPE_TNL_BASE + 0x748)  /* PPE_CURR_RX_FIFO0是接收FIFO状态0。 */
+#define SRE_PPE_TNL_CURR_RX_FIFO1_REG  (SRE_PPE_TNL_BASE + 0x74C)  /* PPE_CURR_RX_FIFO1是接收FIFO状态1。 */
+#define SRE_PPE_TNL_CURR_TX_FIFO0_REG  (SRE_PPE_TNL_BASE + 0x750)  /* PPE_CURR_TX_FIFO0是发送FIFO状态0。 */
+#define SRE_PPE_TNL_CURR_TX_FIFO1_REG  (SRE_PPE_TNL_BASE + 0x754)  /* PPE_CURR_TX_FIFO1是发送FIFO状态1。 */
+#define SRE_PPE_TNL_CURR_DDR_DELAY_REG  (SRE_PPE_TNL_BASE + 0x758)  /* PPE_CURR_DDR_DELAY为读写DDR的最大延时。 */
+#define SRE_PPE_TNL_ECO0_REG           (SRE_PPE_TNL_BASE + 0x75C)  /* PPE_ECO0是eco寄存器0。 */
+#define SRE_PPE_TNL_ECO1_REG           (SRE_PPE_TNL_BASE + 0x760)  /* PPE_ECO1是eco寄存器1。 */
+#define SRE_PPE_TNL_ECO2_REG           (SRE_PPE_TNL_BASE + 0x764)  /* PPE_ECO2是eco寄存器2。 */
+#define SRE_PPE_TNL_HIS_RX_MAC_PKT_CNT_REG  (SRE_PPE_TNL_BASE + 0x800)  /* PPE_HIS_RX_MAC_PKT_CNT是接收到MAC侧的报文个数。 */
+#define SRE_PPE_TNL_HIS_RX_WR_BD_OK_PKT_CNT_REG  (SRE_PPE_TNL_BASE + 0x804)  /* PPE_HIS_RX_WR_BD_OK_PKT_CNT是成功写入接收描述符的报文个数。 */
+#define SRE_PPE_TNL_HIS_TX_BD_ADDR_WR_CNT_REG  (SRE_PPE_TNL_BASE + 0x808)  /* PPE_HIS_TX_BD_ADDR_WR_CNT是被写入发送描述符地址个数。 */
+#define SRE_PPE_TNL_HIS_RX_REL_BUF_CNT_REG  (SRE_PPE_TNL_BASE + 0x80C)  /* PPE_HIS_RX_REL_BUF_CNT是接收释放缓存的个数。 */
+#define SRE_PPE_TNL_HIS_TX_REL_BUF_CNT_REG  (SRE_PPE_TNL_BASE + 0x810)  /* PPE_HIS_TX_REL_BUF_CNT是发送释放缓存的个数。 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_0_REG  (SRE_PPE_TNL_BASE + 0x1000)  /* PPE_CFG_L3_TYPE_VALUE_0为第0种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_0_REG  (SRE_PPE_TNL_BASE + 0x1004)  /* PPE_CFG_L3_TYPE_VALUE为第0种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_0_REG  (SRE_PPE_TNL_BASE + 0x1008)  /* PPE_CFG_L3_TYPE_VALUE为第0种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_1_REG  (SRE_PPE_TNL_BASE + 0x1010)  /* PPE_CFG_L3_TYPE_VALUE_1为第1种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_1_REG  (SRE_PPE_TNL_BASE + 0x1014)  /* PPE_CFG_L3_TYPE_VALUE为第1种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_1_REG  (SRE_PPE_TNL_BASE + 0x1018)  /* PPE_CFG_L3_TYPE_VALUE为第1种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_2_REG  (SRE_PPE_TNL_BASE + 0x1020)  /* PPE_CFG_L3_TYPE_VALUE_2为第2种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_2_REG  (SRE_PPE_TNL_BASE + 0x1024)  /* PPE_CFG_L3_TYPE_VALUE为第2种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_2_REG  (SRE_PPE_TNL_BASE + 0x1028)  /* PPE_CFG_L3_TYPE_VALUE为第2种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_3_REG  (SRE_PPE_TNL_BASE + 0x1030)  /* PPE_CFG_L3_TYPE_VALUE_3为第3种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_3_REG  (SRE_PPE_TNL_BASE + 0x1034)  /* PPE_CFG_L3_TYPE_VALUE为第3种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_3_REG  (SRE_PPE_TNL_BASE + 0x1038)  /* PPE_CFG_L3_TYPE_VALUE为第3种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_4_REG  (SRE_PPE_TNL_BASE + 0x1040)  /* PPE_CFG_L3_TYPE_VALUE_4为第4种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_4_REG  (SRE_PPE_TNL_BASE + 0x1044)  /* PPE_CFG_L3_TYPE_VALUE为第4种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_4_REG  (SRE_PPE_TNL_BASE + 0x1048)  /* PPE_CFG_L3_TYPE_VALUE为第4种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_5_REG  (SRE_PPE_TNL_BASE + 0x1050)  /* PPE_CFG_L3_TYPE_VALUE_5为第5种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_5_REG  (SRE_PPE_TNL_BASE + 0x1054)  /* PPE_CFG_L3_TYPE_VALUE为第5种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_5_REG  (SRE_PPE_TNL_BASE + 0x1058)  /* PPE_CFG_L3_TYPE_VALUE为第5种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_6_REG  (SRE_PPE_TNL_BASE + 0x1060)  /* PPE_CFG_L3_TYPE_VALUE_6为第6种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_6_REG  (SRE_PPE_TNL_BASE + 0x1064)  /* PPE_CFG_L3_TYPE_VALUE为第6种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_6_REG  (SRE_PPE_TNL_BASE + 0x1068)  /* PPE_CFG_L3_TYPE_VALUE为第7种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_7_REG  (SRE_PPE_TNL_BASE + 0x1070)  /* PPE_CFG_L3_TYPE_VALUE_7为第7种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_7_REG  (SRE_PPE_TNL_BASE + 0x1074)  /* PPE_CFG_L3_TYPE_VALUE为第7种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_7_REG  (SRE_PPE_TNL_BASE + 0x1078)  /* PPE_CFG_L3_TYPE_VALUE为第8种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_8_REG  (SRE_PPE_TNL_BASE + 0x1080)  /* PPE_CFG_L3_TYPE_VALUE_8为第8种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_8_REG  (SRE_PPE_TNL_BASE + 0x1084)  /* PPE_CFG_L3_TYPE_VALUE为第8种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_8_REG  (SRE_PPE_TNL_BASE + 0x1088)  /* PPE_CFG_L3_TYPE_VALUE为第9种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_9_REG  (SRE_PPE_TNL_BASE + 0x1090)  /* PPE_CFG_L3_TYPE_VALUE_9为第9种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_9_REG  (SRE_PPE_TNL_BASE + 0x1094)  /* PPE_CFG_L3_TYPE_VALUE为第9种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_9_REG  (SRE_PPE_TNL_BASE + 0x1098)  /* PPE_CFG_L3_TYPE_VALUE为第9种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_10_REG  (SRE_PPE_TNL_BASE + 0x10A0)  /* PPE_CFG_L3_TYPE_VALUE_10为第10种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_10_REG  (SRE_PPE_TNL_BASE + 0x10A4)  /* PPE_CFG_L3_TYPE_VALUE为第10种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_10_REG  (SRE_PPE_TNL_BASE + 0x10A8)  /* PPE_CFG_L3_TYPE_VALUE为第10种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_11_REG  (SRE_PPE_TNL_BASE + 0x10B0)  /* PPE_CFG_L3_TYPE_VALUE_11为第1种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_11_REG  (SRE_PPE_TNL_BASE + 0x10B4)  /* PPE_CFG_L3_TYPE_VALUE为第11种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_11_REG  (SRE_PPE_TNL_BASE + 0x10B8)  /* PPE_CFG_L3_TYPE_VALUE为第11种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_12_REG  (SRE_PPE_TNL_BASE + 0x10C0)  /* PPE_CFG_L3_TYPE_VALUE_12为第12种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_12_REG  (SRE_PPE_TNL_BASE + 0x10C4)  /* PPE_CFG_L3_TYPE_VALUE为第12种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_12_REG  (SRE_PPE_TNL_BASE + 0x10C8)  /* PPE_CFG_L3_TYPE_VALUE为第12种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_13_REG  (SRE_PPE_TNL_BASE + 0x10D0)  /* PPE_CFG_L3_TYPE_VALUE_13为第13种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_13_REG  (SRE_PPE_TNL_BASE + 0x10D4)  /* PPE_CFG_L3_TYPE_VALUE为第13种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_13_REG  (SRE_PPE_TNL_BASE + 0x10D8)  /* PPE_CFG_L3_TYPE_VALUE为第13种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L3_TYPE_VALUE_14_REG  (SRE_PPE_TNL_BASE + 0x10E0)  /* PPE_CFG_L3_TYPE_VALUE_14为第14种3层类型配置值 */
+#define SRE_PPE_TNL_CFG_L3_TYPE_MASK_14_REG  (SRE_PPE_TNL_BASE + 0x10E4)  /* PPE_CFG_L3_TYPE_VALUE为第14种3层类型配置值的MASK */
+#define SRE_PPE_TNL_CFG_L3_TYPE_OFFSET_14_REG  (SRE_PPE_TNL_BASE + 0x10E8)  /* PPE_CFG_L3_TYPE_VALUE为第14种3层类型的头部协议域偏移值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_0_REG  (SRE_PPE_TNL_BASE + 0x1100)  /* PPE_CFG_L4_TYPE_VALUE_0为第0种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_0_REG  (SRE_PPE_TNL_BASE + 0x1104)  /* PPE_CFG_L4_TYPE_VALUE_0为第0种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_0_REG  (SRE_PPE_TNL_BASE + 0x1108)  /* PPE_CFG_L4_SUB_ID_0为第0种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_1_REG  (SRE_PPE_TNL_BASE + 0x1110)  /* PPE_CFG_L4_TYPE_VALUE_1为第1种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_1_REG  (SRE_PPE_TNL_BASE + 0x1114)  /* PPE_CFG_L4_TYPE_VALUE_1为第1种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_1_REG  (SRE_PPE_TNL_BASE + 0x1118)  /* PPE_CFG_L4_SUB_ID_1为第1种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_2_REG  (SRE_PPE_TNL_BASE + 0x1120)  /* PPE_CFG_L4_TYPE_VALUE_2为第2种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_2_REG  (SRE_PPE_TNL_BASE + 0x1124)  /* PPE_CFG_L4_TYPE_VALUE_2为第2种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_2_REG  (SRE_PPE_TNL_BASE + 0x1128)  /* PPE_CFG_L4_SUB_ID_2为第2种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_3_REG  (SRE_PPE_TNL_BASE + 0x1130)  /* PPE_CFG_L4_TYPE_VALUE_3为第3种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_3_REG  (SRE_PPE_TNL_BASE + 0x1134)  /* PPE_CFG_L4_TYPE_VALUE_3为第3种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_3_REG  (SRE_PPE_TNL_BASE + 0x1138)  /* PPE_CFG_L4_SUB_ID_3为第3种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_4_REG  (SRE_PPE_TNL_BASE + 0x1140)  /* PPE_CFG_L4_TYPE_VALUE_4为第4种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_4_REG  (SRE_PPE_TNL_BASE + 0x1144)  /* PPE_CFG_L4_TYPE_VALUE_4为第4种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_4_REG  (SRE_PPE_TNL_BASE + 0x1148)  /* PPE_CFG_L4_SUB_ID_4为第4种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_5_REG  (SRE_PPE_TNL_BASE + 0x1150)  /* PPE_CFG_L4_TYPE_VALUE_5为第5种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_5_REG  (SRE_PPE_TNL_BASE + 0x1154)  /* PPE_CFG_L4_TYPE_VALUE_5为第5种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_5_REG  (SRE_PPE_TNL_BASE + 0x1158)  /* PPE_CFG_L4_SUB_ID_5为第5种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_6_REG  (SRE_PPE_TNL_BASE + 0x1160)  /* PPE_CFG_L4_TYPE_VALUE_6为第6种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_6_REG  (SRE_PPE_TNL_BASE + 0x1164)  /* PPE_CFG_L4_TYPE_VALUE_6为第6种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_6_REG  (SRE_PPE_TNL_BASE + 0x1168)  /* PPE_CFG_L4_SUB_ID_6为第6种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_7_REG  (SRE_PPE_TNL_BASE + 0x1170)  /* PPE_CFG_L4_TYPE_VALUE_7为第7种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_7_REG  (SRE_PPE_TNL_BASE + 0x1174)  /* PPE_CFG_L4_TYPE_VALUE_7为第7种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_7_REG  (SRE_PPE_TNL_BASE + 0x1178)  /* PPE_CFG_L4_SUB_ID_7为第7种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_8_REG  (SRE_PPE_TNL_BASE + 0x1180)  /* PPE_CFG_L4_TYPE_VALUE_8为第8种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_8_REG  (SRE_PPE_TNL_BASE + 0x1184)  /* PPE_CFG_L4_TYPE_VALUE_8为第8种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_8_REG  (SRE_PPE_TNL_BASE + 0x1188)  /* PPE_CFG_L4_SUB_ID_8为第8种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_9_REG  (SRE_PPE_TNL_BASE + 0x1190)  /* PPE_CFG_L4_TYPE_VALUE_9为第9种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_9_REG  (SRE_PPE_TNL_BASE + 0x1194)  /* PPE_CFG_L4_TYPE_VALUE_9为第9种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_9_REG  (SRE_PPE_TNL_BASE + 0x1198)  /* PPE_CFG_L4_SUB_ID_9为第9种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_10_REG  (SRE_PPE_TNL_BASE + 0x11A0)  /* PPE_CFG_L4_TYPE_VALUE_10为第10种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_10_REG  (SRE_PPE_TNL_BASE + 0x11A4)  /* PPE_CFG_L4_TYPE_VALUE_10为第10种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_10_REG  (SRE_PPE_TNL_BASE + 0x11A8)  /* PPE_CFG_L4_SUB_ID_10为第10种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_11_REG  (SRE_PPE_TNL_BASE + 0x11B0)  /* PPE_CFG_L4_TYPE_VALUE_11为第11种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_11_REG  (SRE_PPE_TNL_BASE + 0x11B4)  /* PPE_CFG_L4_TYPE_VALUE_11为第11种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_11_REG  (SRE_PPE_TNL_BASE + 0x11B8)  /* PPE_CFG_L4_SUB_ID_11为第11种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_12_REG  (SRE_PPE_TNL_BASE + 0x11C0)  /* PPE_CFG_L4_TYPE_VALUE_12为第12种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_12_REG  (SRE_PPE_TNL_BASE + 0x11C4)  /* PPE_CFG_L4_TYPE_VALUE_12为第12种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_12_REG  (SRE_PPE_TNL_BASE + 0x11C8)  /* PPE_CFG_L4_SUB_ID_12为第12种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_13_REG  (SRE_PPE_TNL_BASE + 0x11D0)  /* PPE_CFG_L4_TYPE_VALUE_13为第13种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_13_REG  (SRE_PPE_TNL_BASE + 0x11D4)  /* PPE_CFG_L4_TYPE_VALUE_13为第13种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_13_REG  (SRE_PPE_TNL_BASE + 0x11D8)  /* PPE_CFG_L4_SUB_ID_13为第13种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_VALUE_14_REG  (SRE_PPE_TNL_BASE + 0x11E0)  /* PPE_CFG_L4_TYPE_VALUE_14为第14种4层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L4_TYPE_MASK_14_REG  (SRE_PPE_TNL_BASE + 0x11E4)  /* PPE_CFG_L4_TYPE_VALUE_14为第14种4层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L4_SUB_ID_14_REG  (SRE_PPE_TNL_BASE + 0x11E8)  /* PPE_CFG_L4_SUB_ID_14为第14种4层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_0_REG  (SRE_PPE_TNL_BASE + 0x1200)  /* PPE_CFG_L5_TYPE_VALUE_0为第0种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_0_REG  (SRE_PPE_TNL_BASE + 0x1204)  /* PPE_CFG_L5_TYPE_VALUE_0为第0种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_0_REG  (SRE_PPE_TNL_BASE + 0x1208)  /* PPE_CFG_L5_SUB_ID_0为第0种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_1_REG  (SRE_PPE_TNL_BASE + 0x1210)  /* PPE_CFG_L5_TYPE_VALUE_1为第1种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_1_REG  (SRE_PPE_TNL_BASE + 0x1214)  /* PPE_CFG_L5_TYPE_VALUE_1为第1种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_1_REG  (SRE_PPE_TNL_BASE + 0x1218)  /* PPE_CFG_L5_SUB_ID_1为第1种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_2_REG  (SRE_PPE_TNL_BASE + 0x1220)  /* PPE_CFG_L5_TYPE_VALUE_2为第2种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_2_REG  (SRE_PPE_TNL_BASE + 0x1224)  /* PPE_CFG_L5_TYPE_VALUE_2为第2种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_2_REG  (SRE_PPE_TNL_BASE + 0x1228)  /* PPE_CFG_L5_SUB_ID_2为第2种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_3_REG  (SRE_PPE_TNL_BASE + 0x1230)  /* PPE_CFG_L5_TYPE_VALUE_3为第3种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_3_REG  (SRE_PPE_TNL_BASE + 0x1234)  /* PPE_CFG_L5_TYPE_VALUE_3为第3种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_3_REG  (SRE_PPE_TNL_BASE + 0x1238)  /* PPE_CFG_L5_SUB_ID_3为第3种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_4_REG  (SRE_PPE_TNL_BASE + 0x1240)  /* PPE_CFG_L5_TYPE_VALUE_4为第4种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_4_REG  (SRE_PPE_TNL_BASE + 0x1244)  /* PPE_CFG_L5_TYPE_VALUE_4为第4种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_4_REG  (SRE_PPE_TNL_BASE + 0x1248)  /* PPE_CFG_L5_SUB_ID_4为第4种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_5_REG  (SRE_PPE_TNL_BASE + 0x1250)  /* PPE_CFG_L5_TYPE_VALUE_5为第5种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_5_REG  (SRE_PPE_TNL_BASE + 0x1254)  /* PPE_CFG_L5_TYPE_VALUE_5为第5种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_5_REG  (SRE_PPE_TNL_BASE + 0x1258)  /* PPE_CFG_L5_SUB_ID_5为第5种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_6_REG  (SRE_PPE_TNL_BASE + 0x1260)  /* PPE_CFG_L5_TYPE_VALUE_6为第6种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_6_REG  (SRE_PPE_TNL_BASE + 0x1264)  /* PPE_CFG_L5_TYPE_VALUE_6为第6种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_6_REG  (SRE_PPE_TNL_BASE + 0x1268)  /* PPE_CFG_L5_SUB_ID_6为第6种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_7_REG  (SRE_PPE_TNL_BASE + 0x1270)  /* PPE_CFG_L5_TYPE_VALUE_7为第7种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_7_REG  (SRE_PPE_TNL_BASE + 0x1274)  /* PPE_CFG_L5_TYPE_VALUE_7为第7种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_7_REG  (SRE_PPE_TNL_BASE + 0x1278)  /* PPE_CFG_L5_SUB_ID_7为第7种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_8_REG  (SRE_PPE_TNL_BASE + 0x1280)  /* PPE_CFG_L5_TYPE_VALUE_8为第8种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_8_REG  (SRE_PPE_TNL_BASE + 0x1284)  /* PPE_CFG_L5_TYPE_VALUE_8为第8种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_8_REG  (SRE_PPE_TNL_BASE + 0x1288)  /* PPE_CFG_L5_SUB_ID_8为第8种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_9_REG  (SRE_PPE_TNL_BASE + 0x1290)  /* PPE_CFG_L5_TYPE_VALUE_9为第9种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_9_REG  (SRE_PPE_TNL_BASE + 0x1294)  /* PPE_CFG_L5_TYPE_VALUE_9为第9种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_9_REG  (SRE_PPE_TNL_BASE + 0x1298)  /* PPE_CFG_L5_SUB_ID_9为第9种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_10_REG  (SRE_PPE_TNL_BASE + 0x12A0)  /* PPE_CFG_L5_TYPE_VALUE_10为第10种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_10_REG  (SRE_PPE_TNL_BASE + 0x12A4)  /* PPE_CFG_L5_TYPE_VALUE_10为第10种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_10_REG  (SRE_PPE_TNL_BASE + 0x12A8)  /* PPE_CFG_L5_SUB_ID_10为第10种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_11_REG  (SRE_PPE_TNL_BASE + 0x12B0)  /* PPE_CFG_L5_TYPE_VALUE_11为第11种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_11_REG  (SRE_PPE_TNL_BASE + 0x12B4)  /* PPE_CFG_L5_TYPE_VALUE_11为第11种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_11_REG  (SRE_PPE_TNL_BASE + 0x12B8)  /* PPE_CFG_L5_SUB_ID_11为第11种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_12_REG  (SRE_PPE_TNL_BASE + 0x12C0)  /* PPE_CFG_L5_TYPE_VALUE_12为第12种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_12_REG  (SRE_PPE_TNL_BASE + 0x12C4)  /* PPE_CFG_L5_TYPE_VALUE_12为第12种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_12_REG  (SRE_PPE_TNL_BASE + 0x12C8)  /* PPE_CFG_L5_SUB_ID_12为第12种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_13_REG  (SRE_PPE_TNL_BASE + 0x12D0)  /* PPE_CFG_L5_TYPE_VALUE_13为第13种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_13_REG  (SRE_PPE_TNL_BASE + 0x12D4)  /* PPE_CFG_L5_TYPE_VALUE_13为第13种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_13_REG  (SRE_PPE_TNL_BASE + 0x12D8)  /* PPE_CFG_L5_SUB_ID_13为第13种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_VALUE_14_REG  (SRE_PPE_TNL_BASE + 0x12E0)  /* PPE_CFG_L5_TYPE_VALUE_14为第14种5层类型配置值
+ */
+#define SRE_PPE_TNL_CFG_L5_TYPE_MASK_14_REG  (SRE_PPE_TNL_BASE + 0x12E4)  /* PPE_CFG_L5_TYPE_VALUE_14为第14种5层类型值的MASK
+ */
+#define SRE_PPE_TNL_CFG_L5_SUB_ID_14_REG  (SRE_PPE_TNL_BASE + 0x12E8)  /* PPE_CFG_L5_SUB_ID_14为第14种5层的从属类型配置
+ */
+#define SRE_PPE_TNL_CFG_QOS_TBL_KEY_OFFSET_0_REG  (SRE_PPE_TNL_BASE + 0x4100)  /* PPE_CFG_QOS_TBL0_KEY_OFFSET是生成QOS的表的键值产生配置寄存器0。0x4100~0x4138依次是表0~表7的配置 */
+#define SRE_PPE_TNL_CFG_QOS_TBL_KEY_OFFSET_1_REG  (SRE_PPE_TNL_BASE + 0x4108)  /* PPE_CFG_QOS_TBL0_KEY_OFFSET是生成QOS的表的键值产生配置寄存器0。0x4100~0x4138依次是表0~表7的配置 */
+#define SRE_PPE_TNL_CFG_GRP_VMID_TBL_KEY_OFFSET0_0_REG  (SRE_PPE_TNL_BASE + 0x5D00)  /* PPE_CFG_GRP_VMID_TBL0_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器0。0x5D00~0x5D50依次是表0~表10的配置 */
+#define SRE_PPE_TNL_CFG_GRP_VMID_TBL_KEY_OFFSET0_1_REG  (SRE_PPE_TNL_BASE + 0x5D08)  /* PPE_CFG_GRP_VMID_TBL0_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器0。0x5D00~0x5D50依次是表0~表10的配置 */
+#define SRE_PPE_TNL_CFG_GRP_VMID_TBL_KEY_OFFSET1_0_REG  (SRE_PPE_TNL_BASE + 0x5D04)  /* PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器1。0x5D04~0x5D54依次是表0~表10的配置 */
+#define SRE_PPE_TNL_CFG_GRP_VMID_TBL_KEY_OFFSET1_1_REG  (SRE_PPE_TNL_BASE + 0x5D0C)  /* PPE_CFG_GRP_VMID_TBL_KEY_OFFSET0是生成GRP和VMID的表的键值产生配置寄存器1。0x5D04~0x5D54依次是表0~表10的配置 */
+
+
+
+/******************************************************************************/
+/*                      PhosphorV600 PCU 寄存器定义                           */
+/******************************************************************************/
+#define SRE_GMAC_CF_TX_FIFO_THRSLD_REG   (0x420)  /* CF_TX_FIFO_THRSLD为发送FIFO水线寄存器。 */
+#define SRE_GMAC_CF_RX_FIFO_THRSLD_REG   (0x424)  /* CF_RX_FIFO_THRSLD为接收FIFO水线寄存器。 */
+#define SRE_GMAC_CF_CFG_FIFO_THRSLD_REG  (0x428)  /* CF_CFG_FIFO_THRSLD为配置FIFO水线寄存器。 */
+#define SRE_GMAC_CF_INTRPT_MSK_REG       (0x42C)  /* CF_INTRPT_MSK为中断屏蔽寄存器。 */
+#define SRE_GMAC_CF_FIFO_CLR_REG         (0x430)  /* CF_FIFO_CLR为FIFO清零寄存器。 */
+#define SRE_GMAC_CF_INTRPT_STAT_REG      (0x434)  /* CF_INTRPT_STAT为中断状态寄存器。 */
+#define SRE_GMAC_CF_INTRPT_CLR_REG       (0x438)  /* CF_INTRPT_CLR为中断清零寄存器。 */
+#define SRE_GMAC_BUS_ERR_ADDR_REG        (0x43C)  /* BUS_ERR_ADDR为出错总线地址。 */
+#define SRE_GMAC_PCU_MAXFRAME_SIZE_REG   (0x444) /*接收最大帧长设置寄存器*/
+#define SRE_GMAC_TX_DROP_CNT_REG         (0x448)  /* TX_DROP_CNT为发送方向因FIFO空而丢弃的包的统计计数器。 */
+#define SRE_GMAC_RX_OVER_FLOW_CNT_REG    (0x44C)  /* OVER_FLOW_CNT为因接收FIFO满而丢弃的包的统计计数器。 */
+#define SRE_GMAC_DEBUG_ST_MCH_REG        (0x450)  /* DEBUG_ST_MCH状态机上报寄存器。 */
+#define SRE_GMAC_FIFO_CURR_STATUS_REG    (0x454)  /* FIFO_CURR_STATUS为FIFO当前状态寄存器。 */
+#define SRE_GMAC_FIFO_HIS_STATUS_REG     (0x458)  /* FIFO_HIS_STATUS为FIFO历史状态寄存器。 */
+#define SRE_GMAC_CF_CFF_DATA_NUM_REG     (0x45C)  /* CF_CFF_DATA_NUM为配置FIFO数据个数寄存器。 */
+#define SRE_GMAC_TX_CS_FAIL_CNT_REG      (0x460)  /* TX_CS_FAIL_CNT为发送添加校验和失败计数器。 */
+#define SRE_GMAC_RX_TRANS_PKG_CNT_REG    (0x464)  /* RX_TRANS_PKG_CNT为下行搬运成功的包计数器。 */
+#define SRE_GMAC_TX_TRANS_PKG_CNT_REG    (0x468)  /* TX_TRANS_PKG_CNT为上行搬运成功的包计数器。 */
+#define SRE_GMAC_RX_ADDR_OVERFLOW_REG    (0x46C)  /* RX_ADDR_OVERFLOW为写下行配置FIFO溢出计数器。 */
+#define SRE_GMAC_CF_TX_PAUSE_REG         (0x470)  /* CF_TX_PAUSE为发送流控控制寄存器。 */
+#define SRE_GMAC_TX_CFF_ADDR_0_REG       (0x488)  /* TX_CFF_ADDR_0为发送描述符FIFO地址寄存器0。 */
+#define SRE_GMAC_TX_CFF_ADDR_1_REG       (0x48C)  /* TX_CFF_ADDR_1为发送描述符FIFO地址寄存器1。 */
+#define SRE_GMAC_TX_CFF_ADDR_2_REG       (0x490)  /* TX_CFF_ADDR_2为发送描述符FIFO地址寄存器2。 */
+#define SRE_GMAC_TX_CFF_ADDR_3_REG       (0x494)  /* TX_CFF_ADDR_3为发送描述符FIFO地址寄存器3。 */
+#define SRE_GMAC_RX_CFF_ADDR_REG         (0x4A0)  /* RX_CFF_ADDR为接收配置FIFO地址寄存器。 */
+#define SRE_GMAC_WE_ADDR_REG             (0x4E0)  /* WE_ADDR为报文描述符的写地址。 */
+#define SRE_GMAC_RX_BUF_SIZE_REG         (0x4E4)  /* RX_BUF_SIZE为接收缓存大小。 */
+#define SRE_GMAC_BUS_CTRL_REG            (0x4E8)  /* BUS_CTRL为总线控制寄存器。 */
+#define SRE_GMAC_RX_BUF_REQ_ADDR_REG     (0x4EC)  /* RX_BUF_REQ_ADDR为接收缓存的申请地址。 */
+#define SRE_GMAC_RX_CTRL_REG             (0x4F0)  /* RX_CTRL为接收控制寄存器。 */
+#define SRE_GMAC_RX_PKT_MODE_REG         (0x4F4)  /* RX_PKT_MODE为接收报文输入模式。 */
+#define SRE_GMAC_QOS_MODE_REG            (0x4F8)  /* QOS_MODE为QOS信息的生成模式。 */
+#define SRE_GMAC_VLAN_QOS_REG            (0x4FC)  /* VLAN_QOS为vlan帧中优先级到qos的查找表。 */
+#define SRE_GMAC_IP_QOS_0_REG            (0x500)  /* IP_QOS_0为IP帧中优先级到qos的查找表0。 */
+#define SRE_GMAC_IP_QOS_1_REG            (0x504)  /* IP_QOS_1为IP帧中优先级到qos的查找表11。 */
+#define SRE_GMAC_IP_QOS_2_REG            (0x508)  /* IP_QOS_2为IP帧中优先级到qos的查找表22。 */
+#define SRE_GMAC_IP_QOS_3_REG            (0x50C)  /* IP_QOS_3为IP帧中优先级到qos的查找表3。 */
+#define SRE_GMAC_IP_QOS_4_REG            (0x510)  /* IP_QOS_4为IP帧中优先级到qos的查找表4。 */
+#define SRE_GMAC_IP_QOS_5_REG            (0x514)  /* IP_QOS_5为IP帧中优先级到qos的查找表55。 */
+#define SRE_GMAC_IP_QOS_6_REG            (0x518)  /* IP_QOS_6为IP帧中优先级到qos的查找表66。 */
+#define SRE_GMAC_IP_QOS_7_REG            (0x51C)  /* IP_QOS_6为IP帧中优先级到qos的查找表7。 */
+#define SRE_GMAC_GRP_MODE_0_REG          (0x520)  /* GRP_MODE为group信息的生成模式寄存器0。 */
+#define SRE_GMAC_GRP_MODE_1_REG          (0x524)  /* GRP_MODE为group信息的生成模式寄存器1。 */
+#define SRE_GMAC_TT_MODE_REG             (0x528)  /* TT_MODE为type信息的生成模式。 */
+#define SRE_GMAC_TAG_MODE_REG            (0x52C)  /* TAG_MODE为tag信息的生成模式。 */
+#define SRE_GMAC_TAG_MASK_0_REG          (0x530)  /* TAG_MASK_0为参与tag计算的报文头部字节掩码表0。 */
+#define SRE_GMAC_TAG_MASK_1_REG          (0x534)  /* TAG_MASK_0为参与tag计算的报文头部字节掩码表1。 */
+#define SRE_GMAC_MATCH_MASK_0_REG        (0x538)  /* MATCH_MASK_0为参与匹配的报文头部字节掩码表0。 */
+#define SRE_GMAC_MATCH_TBL_0_REG         (0x540)  /* MATCH_TBL_0为进行报头匹配的字节表0。 */
+#define SRE_GMAC_MATCH_TBL_1_REG         (0x544)  /* MATCH_TBL_1为进行报头匹配的字节表1。 */
+#define SRE_GMAC_MATCH_TBL_2_REG         (0x548)  /* MATCH_TBL_2为进行报头匹配的字节表2。 */
+#define SRE_GMAC_MATCH_TBL_3_REG         (0x54C)  /* MATCH_TBL_3为进行报头匹配的字节表3。 */
+#define SRE_GMAC_MATCH_TBL_4_REG         (0x550)  /* MATCH_TBL_4为进行报头匹配的字节表4。 */
+#define SRE_GMAC_MATCH_TBL_5_REG         (0x554)  /* MATCH_TBL_5为进行报头匹配的字节表5。 */
+#define SRE_GMAC_MATCH_TBL_6_REG         (0x558)  /* MATCH_TBL_6为进行报头匹配的字节表6。 */
+#define SRE_GMAC_MATCH_TBL_7_REG         (0x55C)  /* MATCH_TBL_7为进行报头匹配的字节表7。 */
+#define SRE_GMAC_RXBUF_REQ_TIMER_REG     (0x580)  /* RXBUF_REQ_TIMER为接收缓存申请超时寄存器。 */
+#define SRE_GMAC_RX_WE_TIMER_REG         (0x584)  /* RX_PD_TIMER为接收写work entry失败后的超时寄存器。 */
+#define SRE_GMAC_TX_REL_TIMER_REG        (0x588)  /* TX_REL_TIMER为发送完成释放缓存失败后的超时寄存器。 */
+#define SRE_GMAC_RX_BUFRQ_ERR_CNT_REG    (0x58C)  /* RX_BUFRQ_ERR_CNT为接收方向申请缓存错误计数器。 */
+#define SRE_GMAC_TX_BUFRL_ERR_CNT_REG    (0x590)  /* RX_BUFRQ_ERR_CNT为发送方向释放缓存错误计数器。 */
+#define SRE_GMAC_TX_WE_ERR_CNT_REG       (0x594)  /* TX_WE_ERR_CNT为发送方向写工作描述符错误计数器。 */
+#define SRE_GMAC_RX_GRP_TBL_0_REG        (0x598)  /* RX_GRP_TBL_0为group匹配表项0 */
+#define SRE_GMAC_RX_GRP_TBL_1_REG        (0x59C)  /* RX_GRP_TBL_1为group匹配表项1 */
+#define SRE_GMAC_RX_GRP_TBL_2_REG        (0x5A0)  /* RX_GRP_TBL_2为group匹配表项2 */
+#define SRE_GMAC_RX_GRP_TBL_3_REG        (0x5A4)  /* RX_GRP_TBL_3为group匹配表项3 */
+#define SRE_GMAC_RX_GRP_TBL_4_REG        (0x5A8)  /* RX_GRP_TBL_4为group匹配表项4 */
+#define SRE_GMAC_RX_GRP_TBL_5_REG        (0x5AC)  /* RX_GRP_TBL_5为group匹配表项5 */
+#define SRE_GMAC_RX_GRP_TBL_6_REG        (0x5B0)  /* RX_GRP_TBL_6为group匹配表项6 */
+#define SRE_GMAC_RX_GRP_TBL_7_REG        (0x5B4)  /* RX_GRP_TBL_7为group匹配表项7 */
+#define SRE_GMAC_RX_GRP_RES_REG          (0x5B8)  /* RX_GRP_RES为匹配结果配置寄存器 */
+#define SRE_GMAC_RX_GRP_MSK_REG          (0x5BC)  /* RX_GRP_MSK为字节匹配模式下group匹配掩码寄存器 */
+#define SRE_GMAC_ADDR_FILT_S0_REG        (0x5C0)  /* ADDR_FILT_S0为地址过滤范围0的起始地址 */
+#define SRE_GMAC_ADDR_FILT_E0_REG        (0x5C4)  /* ADDR_FILT_S0为地址过滤范围0的结束地址 */
+#define SRE_GMAC_ADDR_FILT_S1_REG        (0x5C8)  /* ADDR_FILT_S1为地址过滤范围1的起始地址 */
+#define SRE_GMAC_ADDR_FILT_E1_REG        (0x5CC)  /* ADDR_FILT_S1为地址过滤范围1的结束地址 */
+#define SRE_GMAC_ADDR_FILT_S2_REG        (0x5D0)  /* ADDR_FILT_S0为地址过滤范围2的起始地址 */
+#define SRE_GMAC_ADDR_FILT_E2_REG        (0x5D4)  /* ADDR_FILT_S0为地址过滤范围2的结束地址 */
+#define SRE_GMAC_ADDR_FILT_S3_REG        (0x5D8)  /* ADDR_FILT_S1为地址过滤范围3的起始地址 */
+#define SRE_GMAC_ADDR_FILT_E3_REG        (0x5DC)  /* ADDR_FILT_S1为地址过滤范围3的结束地址 */
+#define SRE_GMAC_IDLE_CNT_REG            (0x5E0)  /* 发送pause帧控制寄存器 */
+
+
+
+/******************************************************************************/
+/*                      MC XGEM 寄存器定义                                    */
+/******************************************************************************/
+
+#if 0         /* z00202052 */
+#define SRE_XGE_BASE                                   (0x128d0000)
+#else
+#define SRE_XGE_BASE                                   (0xe28d0000)
+#endif        /* z00202052 */
+
+#define SRE_XGE_RCI_MODE_CFG_REG                   (0x0)                 /* RCI寄存器模式配置寄存器。 */
+#define SRE_XGE_MAC_MODE_CONTRL_REG                (0x4)                 /* 工作模式控制寄存器。 */
+#define SRE_XGE_TX_TEST_PATTERN_REG                (0x8)                 /* 发送侧测试模式配置寄存器。 */
+#define SRE_XGE_MAC_TX_CONTROL_REG                 (0xC)                 /* XGE发送控制寄存器。 */
+#define SRE_XGE_MAC_TX_PRBS31_INSERT_ONCE_REG      (0x10)                /* 发送PRBS31插入一次误码控制寄存器 */
+#define SRE_XGE_STP_TX_CONTROL_REG                 (0x18)                /* XGE发送控制寄存器2。 */
+#define SRE_XGE_MAC_LONG_FRAME_REG                 (0x24)                /* 超长包长配置寄存器。 */
+#define SRE_XGE_MAC_GAP_REG                        (0x28)                /* 包间隙配置寄存器。 */
+#define SRE_XGE_MAC_TX_VLAN_TAG_REG                (0x2C)                /* VLAN TAG配置寄存器。 */
+#define SRE_XGE_MAC_PAUSE_TIME_REG                 (0x34)                /* 流控时间配置寄存器。 */
+#define SRE_XGE_MAC_PAUSE_CONTRL_REG               (0x3C)                /* 流控指示配置寄存器。 */
+#define SRE_XGE_MIB_CONTRL_REG                     (0x40)                /* MIB控制配置寄存器 */
+#define SRE_XGE_MIB_WR_DATA_REG                    (0x44)                /* MIB写数据寄存器 */
+#define SRE_XGE_MIB_WR_DATA1_REG                   (0x48)                /* MIB写数据寄存器1 */
+#define SRE_XGE_MIB_RD_DATA_REG                    (0x4C)                /* MIB读数据寄存器 */
+#define SRE_XGE_MIB_RD_DATA1_REG                   (0x50)                /* MIB读数据寄存器1 */
+#define SRE_XGE_MIB_ADDR_REG                       (0x54)                /* MIB地址配置寄存器 */
+#define SRE_XGE_MAC_SOURCE_ADDR0_REG               (0x58)                /* MAC源地址配置寄存器。 */
+#define SRE_XGE_MAC_SOURCE_ADDR1_REG               (0x5C)                /* MAC源地址配置寄存器。 */
+#define SRE_XGE_MAC_INT_REG                        (0x60)                /* XGE MAC接口中断标志寄存器 */
+#define SRE_XGE_MAC_INTMASK_REG                    (0x64)                /* XGE MAC 中断屏蔽寄存器 */
+#define SRE_XGE_MAC_STATE_REG                      (0x68)                /* XGE MAC状态寄存器。 */
+#define SRE_XGE_MAC_TX_STATE_REG                   (0x6C)                /* XGE MAC状态寄存器。 */
+#define SRE_XGE_PCS_PRBS31_INSER_PATTERN_0_REG     (0x94)                /* 10GE PCS PRBS31单次插入误码掩码寄存器0。 */
+#define SRE_XGE_PCS_PRBS31_INSER_PATTERN_1_REG     (0x98)                /* 10GE PCS PRBS31单次插入误码掩码寄存器1。 */
+#define SRE_XGE_PCS_PRBS31_INSER_CYCLE_REG         (0x9C)                /* 10GE PCS PRBS31多次插入误码配置寄存器（周期与数目）。 */
+#define SRE_XGE_TEST_PATTERN_SEED_A_0_REG          (0xA4)                /* 10GE PCS伪随机测试模式随机种子A寄存器0。 */
+#define SRE_XGE_TEST_PATTERN_SEED_A_1_REG          (0xA8)                /* 10GE PCS伪随机测试模式随机种子A寄存器1。 */
+#define SRE_XGE_TEST_PATTERN_SEED_B_0_REG          (0xAC)                /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define SRE_XGE_TEST_PATTERN_SEED_B_1_REG          (0xB0)                /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define SRE_XGE_TX_FAULT_REG                       (0xB4)                /* 10GE PCS发送通道错误告警寄存器。 */
+#define SRE_XGE_TX_STAT_REG                        (0xB8)                /* 10GE PCS发送通道状态寄存器。 */
+#define SRE_XGE_MAC_SHORT_FRAME_REG                (0xBC)                /* 最短包长配置寄存器。 */
+#define SRE_XGE_DTE_XGXS_TX_CURR_STA_REG           (0xC0)                /* 10GE XGXS发送状态机当前状态寄存器。 */
+#define SRE_XGE_TIMESTAMP_ESTI_REG                 (0xC4)                /* 发送时戳延迟估计 */
+#define SRE_XGE_ASYM_CRT_HIGH_REG                  (0xC8)                /* 非对称校正值高32位 */
+#define SRE_XGE_ASYM_CRT_LOW_REG                   (0xCC)                /* 非对称校正值低32位 */
+#define SRE_XGE_SEQID_REG                          (0xD0)                /* 包ID返回值 */
+#define SRE_XGE_CF_MSB_REG                         (0xD4)                /* 包ID返回值 */
+#define SRE_XGE_TIMESTP_HIGH_REG                   (0xD8)                /* 返回时戳的32到63位 */
+#define SRE_XGE_TIMESTP_LOW_REG                    (0xDC)                /* 返回时戳的0到31位 */
+#define SRE_XGE_MEM_ADAPT_REG                      (0xE0)                /* memory时序调试信息 */
+#define SRE_XGE_RCI_RX_MODE_CFG_REG                (0x2000)              /* RCI寄存器模式配置寄存器。 */
+#define SRE_XGE_RX_TEST_PATTERN_REG                (0x2004)              /* 接收侧测试模式配置寄存器。 */
+#define SRE_XGE_MAC_RX_CONTROL_REG                 (0x2008)              /* XGE接收控制寄存器 */
+#define SRE_XGE_STP_RX_CONTROL_REG                 (0x200C)              /* XGE接收控制寄存器2 */
+#define SRE_XGE_MAC_RX_FIFO_REG                    (0x2010)              /* XGE接收侧FIFON配置寄存器 */
+#define SRE_XGE_MAC_RX_VLAN_REG                    (0x2014)              /* XGE接收侧VLAN配置寄存器 */
+#define SRE_XGE_MAC_INT2_REG                       (0x2018)              /* XGE MAC接口中断标志寄存器 */
+#define SRE_XGE_MAC_INTMASK2_REG                   (0x201C)              /* XGE MAC 中断屏蔽寄存器 */
+#define SRE_XGE_MAC_STATE1_REG                     (0x202C)              /* XGE MAC状态寄存器。 */
+#define SRE_XGE_MAC_TX_STATE1_REG                  (0x2030)              /* XGE MAC状态寄存器。 */
+#define SRE_XGE_PCS_PRBS31_THLD_A_REG              (0x2034)              /* PCS PRBS31窗口内误码阈值配置寄存器。 */
+#define SRE_XGE_PCS_PRBS31_TB_REG                  (0x2038)              /* PCS PRBS31时间窗口配置寄存器。 */
+#define SRE_XGE_PCS_SYNC_LK_CNT_REG                (0x203C)              /* PCS配置SYNC的配置寄存器。 */
+#define SRE_XGE_PCS_CONTROL1_REG                   (0x2040)              /* PCS中PRBS31测试模式控制寄存器1。 */
+#define SRE_XGE_PCS_SYNC_ERR_REG                   (0x2048)              /* 同步头错误统计寄存器。 */
+#define SRE_XGE_PCS_TYPE_STA_2_REG                 (0x2050)              /* 10GE PCS 10GBASE_R_PCS状态寄存器寄存器2。 */
+#define SRE_XGE_TEST_PATTERN_ERR_CNT_REG           (0x2058)              /* 10GE PCS测试模式误码计数器。 */
+#define SRE_XGE_PCS_ALARM_REG                      (0x205C)              /* PCS告警寄存器。 */
+#define SRE_XGE_PCS_STATE_REG                      (0x2060)              /* XGE PCS状态寄存器。 */
+#define SRE_XGE_RX_LANE_1_SYNC_CURR_STA_REG        (0x20B8)              /* 10GE XGXS通道0/1同步状态机当前状态寄存器。 */
+#define SRE_XGE_RX_LANE_2_SYNC_CURR_STA_REG        (0x20BC)              /* 10GE XGXS通道2/3同步状态机当前状态寄存器。 */
+#define SRE_XGE_RX_DESKEW_CURR_STA_REG             (0x20C0)              /* 10GE XGXS通道间DESKEW状态机当前状态寄存器。 */
+#define SRE_XGE_DTE_XGXS_STA_1_REG                 (0x20C4)              /* 10GE XGXS状态寄存器1。 */
+#define SRE_XGE_DTE_XGXS_RX_LANE0_10B_ERROR_REG    (0x20C8)              /* 10GE XGXS接收LANE0/1误码计数器。 */
+#define SRE_XGE_DTE_XGXS_RX_LANE2_10B_ERROR_REG    (0x20CC)              /* 10GE XGXS接收LANE2/3误码计数器。 */
+#define SRE_XGE_DTE_XGXS_RX_PRJ_ERROR_REG          (0x20D0)              /* 10GE XGXS接收方向工程需求。 */
+#define SRE_XGE_RXCHAN_CTRL_SIGNALS_REG            (0x20E0)              /* 接收通道控制信号补充 */
+#define SRE_XGE_UNICAST_ADDR_EN_REG                (0x2290)              /* XGE0接收单播地址过滤使能寄存器。 */
+#define SRE_XGE_UNICAST_ADDR_EN_HIGH_REG           (0x2294)              /* XGE0接收单播、多播、广播地址过滤使能寄存器。 */
+#define SRE_XGE_TIMESTAMP_INGRESS_REG              (0x2298)              /* XGE0接收时戳延迟估计。 */
+#define SRE_XGE_NLST_REG                           (0x229C)              /* XGE0无损环回FIFO */
+#define SRE_XGE_BIT_ERR_REG                        (0x22A0)              /* 链路异常统计寄存器 */
+#define MC_XGE1_RCI_MODE_CFG_REG                  (0x4000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE1_MAC_MODE_CONTRL_REG               (0x4004)              /* 工作模式控制寄存器。 */
+#define MC_XGE1_TX_TEST_PATTERN_REG               (0x4008)              /* 发送侧测试模式配置寄存器。 */
+#define MC_XGE1_MAC_TX_CONTROL_REG                (0x400C)              /* XGE发送控制寄存器。 */
+#define MC_XGE1_MAC_TX_PRBS31_INSERT_ONCE_REG     (0x4010)
+#define MC_XGE1_STP_TX_CONTROL_REG                (0x4018)              /* XGE发送控制寄存器2。 */
+#define MC_XGE1_MAC_LONG_FRAME_REG                (0x4024)              /* 超长包长配置寄存器。 */
+#define MC_XGE1_MAC_GAP_REG                       (0x4028)              /* 包间隙配置寄存器。 */
+#define MC_XGE1_MAC_TX_VLAN_TAG_REG               (0x402C)              /* VLAN TAG配置寄存器。 */
+#define MC_XGE1_MAC_PAUSE_TIME_REG                (0x4034)              /* 流控时间配置寄存器。 */
+#define MC_XGE1_MAC_PAUSE_CONTRL_REG              (0x403C)              /* 流控指示配置寄存器。 */
+#define MC_XGE1_MIB_CONTRL_REG                    (0x4040)              /* MIB控制配置寄存器 */
+#define MC_XGE1_MIB_WR_DATA_REG                   (0x4044)              /* MIB写数据寄存器 */
+#define MC_XGE1_MIB_WR_DATA1_REG                  (0x4048)              /* MIB写数据寄存器1 */
+#define MC_XGE1_MIB_RD_DATA_REG                   (0x404C)              /* MIB读数据寄存器 */
+#define MC_XGE1_MIB_RD_DATA1_REG                  (0x4050)              /* MIB读数据寄存器1 */
+#define MC_XGE1_MIB_ADDR_REG                      (0x4054)              /* MIB地址配置寄存器 */
+#define MC_XGE1_MAC_SOURCE_ADDR0_REG              (0x4058)              /* MAC源地址配置寄存器。 */
+#define MC_XGE1_MAC_SOURCE_ADDR1_REG              (0x405C)              /* MAC源地址配置寄存器。 */
+#define MC_XGE1_MAC_INT_REG                       (0x4060)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE1_MAC_INTMASK_REG                   (0x4064)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE1_MAC_STATE_REG                     (0x4068)              /* XGE MAC状态寄存器。 */
+#define MC_XGE1_MAC_TX_STATE_REG                  (0x406C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE1_PCS_PRBS31_INSER_PATTERN_0_REG    (0x4094)              /* 10GE PCS PRBS31单次插入误码掩码寄存器0。 */
+#define MC_XGE1_PCS_PRBS31_INSER_PATTERN_1_REG    (0x4098)              /* 10GE PCS PRBS31单次插入误码掩码寄存器1。 */
+#define MC_XGE1_PCS_PRBS31_INSER_CYCLE_REG        (0x409C)              /* 10GE PCS PRBS31多次插入误码配置寄存器（周期与数目）。 */
+#define MC_XGE1_TEST_PATTERN_SEED_A_0_REG         (0x40A4)              /* 10GE PCS伪随机测试模式随机种子A寄存器0。 */
+#define MC_XGE1_TEST_PATTERN_SEED_A_1_REG         (0x40A8)              /* 10GE PCS伪随机测试模式随机种子A寄存器1。 */
+#define MC_XGE1_TEST_PATTERN_SEED_B_0_REG         (0x40AC)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE1_TEST_PATTERN_SEED_B_1_REG         (0x40B0)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE1_TX_FAULT_REG                      (0x40B4)              /* 10GE PCS发送通道错误告警寄存器。 */
+#define MC_XGE1_TX_STAT_REG                       (0x40B8)              /* 10GE PCS发送通道状态寄存器。 */
+#define MC_XGE1_MAC_SHORT_FRAME_REG               (0x40BC)              /* 最短包长配置寄存器。 */
+#define MC_XGE1_DTE_XGXS_TX_CURR_STA_REG          (0x40C0)              /* 10GE XGXS发送状态机当前状态寄存器。 */
+#define MC_XGE1_TIMESTAMP_ESTI_REG                (0x40C4)              /* 发送时戳延迟估计 */
+#define MC_XGE1_ASYM_CRT_HIGH_REG                 (0x40C8)              /* 非对称校正值高32位 */
+#define MC_XGE1_ASYM_CRT_LOW_REG                  (0x40CC)              /* 非对称校正值低32位 */
+#define MC_XGE1_SEQID_REG                         (0x40D0)              /* 包ID返回值 */
+#define MC_XGE1_CF_MSB_REG                        (0x40D4)              /* 包ID返回值 */
+#define MC_XGE1_TIMESTP_HIGH_REG                  (0x40D8)              /* 返回时戳的32到63位 */
+#define MC_XGE1_TIMESTP_LOW_REG                   (0x40DC)              /* 返回时戳的0到31位 */
+#define MC_XGE1_RCI_RX_MODE_CFG_REG               (0x6000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE1_RX_TEST_PATTERN_REG               (0x6004)              /* 接收侧测试模式配置寄存器。 */
+#define MC_XGE1_MAC_RX_CONTROL_REG                (0x6008)              /* XGE接收控制寄存器 */
+#define MC_XGE1_STP_RX_CONTROL_REG                (0x600C)              /* XGE接收控制寄存器2 */
+#define MC_XGE1_MAC_RX_FIFO_REG                   (0x6010)              /* XGE接收侧FIFON配置寄存器 */
+#define MC_XGE1_MAC_RX_VLAN_REG                   (0x6014)              /* XGE接收侧VLAN配置寄存器 */
+#define MC_XGE1_MAC_INT2_REG                      (0x6018)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE1_MAC_INTMASK2_REG                  (0x601C)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE1_MAC_STATE1_REG                    (0x602C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE1_MAC_TX_STATE1_REG                 (0x6030)              /* XGE MAC状态寄存器。 */
+#define MC_XGE1_PCS_PRBS31_THLD_A_REG             (0x6034)              /* PCS PRBS31窗口内误码阈值配置寄存器。 */
+#define MC_XGE1_PCS_PRBS31_TB_REG                 (0x6038)              /* PCS PRBS31时间窗口配置寄存器。 */
+#define MC_XGE1_PCS_SYNC_LK_CNT_REG               (0x603C)              /* PCS配置SYNC的配置寄存器。 */
+#define MC_XGE1_PCS_CONTROL1_REG                  (0x6040)              /* PCS中PRBS31测试模式控制寄存器1。 */
+#define MC_XGE1_PCS_SYNC_ERR_REG                  (0x6048)              /* 同步头错误统计寄存器。 */
+#define MC_XGE1_PCS_TYPE_STA_2_REG                (0x6050)              /* 10GE PCS 10GBASE_R_PCS状态寄存器寄存器2。 */
+#define MC_XGE1_TEST_PATTERN_ERR_CNT_REG          (0x6058)              /* 10GE PCS测试模式误码计数器。 */
+#define MC_XGE1_PCS_ALARM_REG                     (0x605C)              /* PCS告警寄存器。 */
+#define MC_XGE1_PCS_STATE_REG                     (0x6060)              /* XGE PCS状态寄存器。 */
+#define MC_XGE1_RX_LANE_1_SYNC_CURR_STA_REG       (0x60B8)              /* 10GE XGXS通道0/1同步状态机当前状态寄存器。 */
+#define MC_XGE1_RX_LANE_2_SYNC_CURR_STA_REG       (0x60BC)              /* 10GE XGXS通道2/3同步状态机当前状态寄存器。 */
+#define MC_XGE1_RX_DESKEW_CURR_STA_REG            (0x60C0)              /* 10GE XGXS通道间DESKEW状态机当前状态寄存器。 */
+#define MC_XGE1_DTE_XGXS_STA_1_REG                (0x60C4)              /* 10GE XGXS状态寄存器1。 */
+#define MC_XGE1_DTE_XGXS_RX_LANE0_10B_ERROR_REG   (0x60C8)              /* 10GE XGXS接收LANE0/1误码计数器。 */
+#define MC_XGE1_DTE_XGXS_RX_LANE2_10B_ERROR_REG   (0x60CC)              /* 10GE XGXS接收LANE2/3误码计数器。 */
+#define MC_XGE1_DTE_XGXS_RX_PRJ_ERROR_REG         (0x60D0)              /* 10GE XGXS接收方向工程需求。 */
+#define SRE_XGE_RXCHAN_CTRL_SIGNALS_1_REG          (0x60E0)              /* 接收通道控制信号补充 */
+#define MC_XGE1_UNICAST_ADDR_EN_REG               (0x60E4)              /* XGE1接收单播地址过滤使能寄存器。 */
+#define MC_XGE1_UNICAST_ADDR_EN_HIGH_REG          (0x60E8)              /* XGE1接收单播、多播、广播地址过滤使能寄存器。 */
+#define MC_XGE1_TIMESTAMP_INGRESS_REG             (0x60EC)              /* XGE1接收时戳延迟估计。 */
+#define MC_XGE1_NLST_REG                          (0x60F0)              /* XGE0无损环回FIFO */
+#define MC_XGE1_BIT_ERR_REG                       (0x60F4)              /* 链路异常统计寄存器 */
+#define MC_XGE2_RCI_MODE_CFG_REG                  (0x8000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE2_MAC_MODE_CONTRL_REG               (0x8004)              /* 工作模式控制寄存器。 */
+#define MC_XGE2_TX_TEST_PATTERN_REG               (0x8008)              /* 发送侧测试模式配置寄存器。 */
+#define MC_XGE2_MAC_TX_CONTROL_REG                (0x800C)              /* XGE发送控制寄存器。 */
+#define MC_XGE2_MAC_TX_PRBS31_INSERT_ONCE_REG     (0x8010)
+#define MC_XGE2_STP_TX_CONTROL_REG                (0x8018)              /* XGE发送控制寄存器2。 */
+#define MC_XGE2_MAC_LONG_FRAME_REG                (0x8024)              /* 超长包长配置寄存器。 */
+#define MC_XGE2_MAC_GAP_REG                       (0x8028)              /* 包间隙配置寄存器。 */
+#define MC_XGE2_MAC_TX_VLAN_TAG_REG               (0x802C)              /* VLAN TAG配置寄存器。 */
+#define MC_XGE2_MAC_PAUSE_TIME_REG                (0x8034)              /* 流控时间配置寄存器。 */
+#define MC_XGE2_MAC_PAUSE_CONTRL_REG              (0x803C)              /* 流控指示配置寄存器。 */
+#define MC_XGE2_MIB_CONTRL_REG                    (0x8040)              /* MIB控制配置寄存器 */
+#define MC_XGE2_MIB_WR_DATA_REG                   (0x8044)              /* MIB写数据寄存器 */
+#define MC_XGE2_MIB_WR_DATA1_REG                  (0x8048)              /* MIB写数据寄存器1 */
+#define MC_XGE2_MIB_RD_DATA_REG                   (0x804C)              /* MIB读数据寄存器 */
+#define MC_XGE2_MIB_RD_DATA1_REG                  (0x8050)              /* MIB读数据寄存器1 */
+#define MC_XGE2_MIB_ADDR_REG                      (0x8054)              /* MIB地址配置寄存器 */
+#define MC_XGE2_MAC_SOURCE_ADDR0_REG              (0x8058)              /* MAC源地址配置寄存器。 */
+#define MC_XGE2_MAC_SOURCE_ADDR1_REG              (0x805C)              /* MAC源地址配置寄存器。 */
+#define MC_XGE2_MAC_INT_REG                       (0x8060)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE2_MAC_INTMASK_REG                   (0x8064)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE2_MAC_STATE_REG                     (0x8068)              /* XGE MAC状态寄存器。 */
+#define MC_XGE2_MAC_TX_STATE_REG                  (0x806C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE2_PCS_PRBS31_INSER_PATTERN_0_REG    (0x8094)              /* 10GE PCS PRBS31单次插入误码掩码寄存器0。 */
+#define MC_XGE2_PCS_PRBS31_INSER_PATTERN_1_REG    (0x8098)              /* 10GE PCS PRBS31单次插入误码掩码寄存器1。 */
+#define MC_XGE2_PCS_PRBS31_INSER_CYCLE_REG        (0x809C)              /* 10GE PCS PRBS31多次插入误码配置寄存器（周期与数目）。 */
+#define MC_XGE2_TEST_PATTERN_SEED_A_0_REG         (0x80A4)              /* 10GE PCS伪随机测试模式随机种子A寄存器0。 */
+#define MC_XGE2_TEST_PATTERN_SEED_A_1_REG         (0x80A8)              /* 10GE PCS伪随机测试模式随机种子A寄存器1。 */
+#define MC_XGE2_TEST_PATTERN_SEED_B_0_REG         (0x80AC)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE2_TEST_PATTERN_SEED_B_1_REG         (0x80B0)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE2_TX_FAULT_REG                      (0x80B4)              /* 10GE PCS发送通道错误告警寄存器。 */
+#define MC_XGE2_TX_STAT_REG                       (0x80B8)              /* 10GE PCS发送通道状态寄存器。 */
+#define MC_XGE2_MAC_SHORT_FRAME_REG               (0x80BC)              /* 最短包长配置寄存器。 */
+#define MC_XGE2_TIMESTAMP_ESTI_REG                (0x80C4)              /* 发送时戳延迟估计 */
+#define MC_XGE2_ASYM_CRT_HIGH_REG                 (0x80C8)              /* 非对称校正值高32位 */
+#define MC_XGE2_ASYM_CRT_LOW_REG                  (0x80CC)              /* 非对称校正值低32位 */
+#define MC_XGE2_SEQID_REG                         (0x80D0)              /* 包ID返回值 */
+#define MC_XGE2_CF_MSB_REG                        (0x80D4)              /* 包ID返回值 */
+#define MC_XGE2_TIMESTP_HIGH_REG                  (0x80D8)              /* 返回时戳的32到63位 */
+#define MC_XGE2_TIMESTP_LOW_REG                   (0x80DC)              /* 返回时戳的0到31位 */
+#define MC_XGE2_RCI_RX_MODE_CFG_REG               (0xA000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE2_RX_TEST_PATTERN_REG               (0xA004)              /* 接收侧测试模式配置寄存器。 */
+#define MC_XGE2_MAC_RX_CONTROL_REG                (0xA008)              /* XGE接收控制寄存器 */
+#define MC_XGE2_STP_RX_CONTROL_REG                (0xA00C)              /* XGE接收控制寄存器2 */
+#define MC_XGE2_MAC_RX_FIFO_REG                   (0xA010)              /* XGE接收侧FIFON配置寄存器 */
+#define MC_XGE2_MAC_RX_VLAN_REG                   (0xA014)              /* XGE接收侧VLAN配置寄存器 */
+#define MC_XGE2_MAC_INT2_REG                      (0xA018)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE2_MAC_INTMASK2_REG                  (0xA01C)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE2_MAC_STATE1_REG                    (0xA02C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE2_MAC_TX_STATE1_REG                 (0xA030)              /* XGE MAC状态寄存器。 */
+#define MC_XGE2_PCS_PRBS31_THLD_A_REG             (0xA034)              /* PCS PRBS31窗口内误码阈值配置寄存器。 */
+#define MC_XGE2_PCS_PRBS31_TB_REG                 (0xA038)              /* PCS PRBS31时间窗口配置寄存器。 */
+#define MC_XGE2_PCS_SYNC_LK_CNT_REG               (0xA03C)              /* PCS配置SYNC的配置寄存器。 */
+#define MC_XGE2_PCS_CONTROL1_REG                  (0xA040)              /* PCS中PRBS31测试模式控制寄存器1。 */
+#define MC_XGE2_PCS_SYNC_ERR_REG                  (0xA048)              /* 同步头错误统计寄存器。 */
+#define MC_XGE2_PCS_TYPE_STA_2_REG                (0xA050)              /* 10GE PCS 10GBASE_R_PCS状态寄存器寄存器2。 */
+#define MC_XGE2_TEST_PATTERN_ERR_CNT_REG          (0xA058)              /* 10GE PCS测试模式误码计数器。 */
+#define MC_XGE2_PCS_ALARM_REG                     (0xA05C)              /* PCS告警寄存器。 */
+#define MC_XGE2_PCS_STATE_REG                     (0xA060)              /* XGE PCS状态寄存器。 */
+#define SRE_XGE_RXCHAN_CTRL_SIGNALS_2_REG          (0xA0E0)              /* 接收通道控制信号补充 */
+#define MC_XGE2_UNICAST_ADDR_EN_REG               (0xA0E4)              /* XGE2接收单播地址过滤使能寄存器。 */
+#define MC_XGE2_UNICAST_ADDR_EN_HIGH_REG          (0xA0E8)              /* XGE2接收单播、多播、广播地址过滤使能寄存器。 */
+#define MC_XGE2_TIMESTAMP_INGRESS_REG             (0xA0EC)              /* XGE2接收时戳延迟估计。 */
+#define MC_XGE2_NLST_REG                          (0xA0F0)              /* XGE0无损环回FIFO */
+#define MC_XGE2_BIT_ERR_REG                       (0xA0F4)              /* 链路异常统计寄存器 */
+#define MC_XGE3_RCI_MODE_CFG_REG                  (0xC000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE3_MAC_MODE_CONTRL_REG               (0xC004)              /* 工作模式控制寄存器。 */
+#define MC_XGE3_TX_TEST_PATTERN_REG               (0xC008)              /* 发送侧测试模式配置寄存器。 */
+#define MC_XGE3_MAC_TX_CONTROL_REG                (0xC00C)              /* XGE发送控制寄存器。 */
+#define MC_XGE3_MAC_TX_PRBS31_INSERT_ONCE_REG     (0xC010)
+#define MC_XGE3_STP_TX_CONTROL_REG                (0xC018)              /* XGE发送控制寄存器2。 */
+#define MC_XGE3_MAC_LONG_FRAME_REG                (0xC024)              /* 超长包长配置寄存器。 */
+#define MC_XGE3_MAC_GAP_REG                       (0xC028)              /* 包间隙配置寄存器。 */
+#define MC_XGE3_MAC_TX_VLAN_TAG_REG               (0xC02C)              /* VLAN TAG配置寄存器。 */
+#define MC_XGE3_MAC_PAUSE_TIME_REG                (0xC034)              /* 流控时间配置寄存器。 */
+#define MC_XGE3_MAC_PAUSE_CONTRL_REG              (0xC03C)              /* 流控指示配置寄存器。 */
+#define MC_XGE3_MIB_CONTRL_REG                    (0xC040)              /* MIB控制配置寄存器 */
+#define MC_XGE3_MIB_WR_DATA_REG                   (0xC044)              /* MIB写数据寄存器 */
+#define MC_XGE3_MIB_WR_DATA1_REG                  (0xC048)              /* MIB写数据寄存器1 */
+#define MC_XGE3_MIB_RD_DATA_REG                   (0xC04C)              /* MIB读数据寄存器 */
+#define MC_XGE3_MIB_RD_DATA1_REG                  (0xC050)              /* MIB读数据寄存器1 */
+#define MC_XGE3_MIB_ADDR_REG                      (0xC054)              /* MIB地址配置寄存器 */
+#define MC_XGE3_MAC_SOURCE_ADDR0_REG              (0xC058)              /* MAC源地址配置寄存器。 */
+#define MC_XGE3_MAC_SOURCE_ADDR1_REG              (0xC05C)              /* MAC源地址配置寄存器。 */
+#define MC_XGE3_MAC_INT_REG                       (0xC060)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE3_MAC_INTMASK_REG                   (0xC064)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE3_MAC_STATE_REG                     (0xC068)              /* XGE MAC状态寄存器。 */
+#define MC_XGE3_MAC_TX_STATE_REG                  (0xC06C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE3_PCS_PRBS31_INSER_PATTERN_0_REG    (0xC094)              /* 10GE PCS PRBS31单次插入误码掩码寄存器0。 */
+#define MC_XGE3_PCS_PRBS31_INSER_PATTERN_1_REG    (0xC098)              /* 10GE PCS PRBS31单次插入误码掩码寄存器1。 */
+#define MC_XGE3_PCS_PRBS31_INSER_CYCLE_REG        (0xC09C)              /* 10GE PCS PRBS31多次插入误码配置寄存器（周期与数目）。 */
+#define MC_XGE3_TEST_PATTERN_SEED_A_0_REG         (0xC0A4)              /* 10GE PCS伪随机测试模式随机种子A寄存器0。 */
+#define MC_XGE3_TEST_PATTERN_SEED_A_1_REG         (0xC0A8)              /* 10GE PCS伪随机测试模式随机种子A寄存器1。 */
+#define MC_XGE3_TEST_PATTERN_SEED_B_0_REG         (0xC0AC)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE3_TEST_PATTERN_SEED_B_1_REG         (0xC0B0)              /* 10GE PCS伪随机测试模式随机种子B寄存器0。 */
+#define MC_XGE3_TX_FAULT_REG                      (0xC0B4)              /* 10GE PCS发送通道错误告警寄存器。 */
+#define MC_XGE3_TX_STAT_REG                       (0xC0B8)              /* 10GE PCS发送通道状态寄存器。 */
+#define MC_XGE3_MAC_SHORT_FRAME_REG               (0xC0BC)              /* 最短包长配置寄存器。 */
+#define MC_XGE3_TIMESTAMP_ESTI_REG                (0xC0C4)              /* 发送时戳延迟估计 */
+#define MC_XGE3_ASYM_CRT_HIGH_REG                 (0xC0C8)              /* 非对称校正值高32位 */
+#define MC_XGE3_ASYM_CRT_LOW_REG                  (0xC0CC)              /* 非对称校正值低32位 */
+#define MC_XGE3_SEQID_REG                         (0xC0D0)              /* 包ID返回值 */
+#define MC_XGE3_CF_MSB_REG                        (0xC0D4)              /* 包ID返回值 */
+#define MC_XGE3_TIMESTP_HIGH_REG                  (0xC0D8)              /* 返回时戳的32到63位 */
+#define MC_XGE3_TIMESTP_LOW_REG                   (0xC0DC)              /* 返回时戳的0到31位 */
+#define MC_XGE3_RCI_RX_MODE_CFG_REG               (0xE000)              /* RCI寄存器模式配置寄存器。 */
+#define MC_XGE3_RX_TEST_PATTERN_REG               (0xE004)              /* 接收侧测试模式配置寄存器。 */
+#define MC_XGE3_MAC_RX_CONTROL_REG                (0xE008)              /* XGE接收控制寄存器 */
+#define MC_XGE3_STP_RX_CONTROL_REG                (0xE00C)              /* XGE接收控制寄存器2 */
+#define MC_XGE3_MAC_RX_FIFO_REG                   (0xE010)              /* XGE接收侧FIFON配置寄存器 */
+#define MC_XGE3_MAC_RX_VLAN_REG                   (0xE014)              /* XGE接收侧VLAN配置寄存器 */
+#define MC_XGE3_MAC_INT2_REG                      (0xE018)              /* XGE MAC接口中断标志寄存器 */
+#define MC_XGE3_MAC_INTMASK2_REG                  (0xE01C)              /* XGE MAC 中断屏蔽寄存器 */
+#define MC_XGE3_MAC_STATE1_REG                    (0xE02C)              /* XGE MAC状态寄存器。 */
+#define MC_XGE3_MAC_TX_STATE1_REG                 (0xE030)              /* XGE MAC状态寄存器。 */
+#define MC_XGE3_PCS_PRBS31_THLD_A_REG             (0xE034)              /* PCS PRBS31窗口内误码阈值配置寄存器。 */
+#define MC_XGE3_PCS_PRBS31_TB_REG                 (0xE038)              /* PCS PRBS31时间窗口配置寄存器。 */
+#define MC_XGE3_PCS_SYNC_LK_CNT_REG               (0xE03C)              /* PCS配置SYNC的配置寄存器。 */
+#define MC_XGE3_PCS_CONTROL1_REG                  (0xE040)              /* PCS中PRBS31测试模式控制寄存器1。 */
+#define MC_XGE3_PCS_SYNC_ERR_REG                  (0xE048)              /* 同步头错误统计寄存器。 */
+#define MC_XGE3_PCS_TYPE_STA_2_REG                (0xE050)              /* 10GE PCS 10GBASE_R_PCS状态寄存器寄存器2。 */
+#define MC_XGE3_TEST_PATTERN_ERR_CNT_REG          (0xE058)              /* 10GE PCS测试模式误码计数器。 */
+#define MC_XGE3_PCS_ALARM_REG                     (0xE05C)              /* PCS告警寄存器。 */
+#define MC_XGE3_PCS_STATE_REG                     (0xE060)              /* XGE PCS状态寄存器。 */
+#define SRE_XGE_RXCHAN_CTRL_SIGNALS_3_REG          (0xE0E0)              /* 接收通道控制信号补充 */
+#define MC_XGE3_UNICAST_ADDR_EN_REG               (0xE0E4)              /* XGE3接收单播地址过滤使能寄存器。 */
+#define MC_XGE3_UNICAST_ADDR_EN_HIGH_REG          (0xE0E8)              /* XGE3接收单播、多播、广播地址过滤使能寄存器。 */
+#define MC_XGE3_TIMESTAMP_INGRESS_REG             (0xE0EC)              /* XGE3接收时戳延迟估计。 */
+#define MC_XGE3_NLST_REG                          (0xE0F0)              /* XGE0无损环回FIFO */
+#define MC_XGE3_BIT_ERR_REG                       (0xE0F4)              /* 链路异常统计寄存器 */
+
+/******************************************************************************/
+/*                      MC XGEM_ADDR 寄存器定义                               */
+/******************************************************************************/
+
+#define SRE_XGE_UNICAST_ADDR_EN_0_REG              (0x20E4)              /* 接收单播地址过滤使能寄存器。 */
+#define SRE_XGE_UNICAST_ADDR_EN_1_REG              (0x20E8)              /* 接收单播地址过滤使能寄存器。 */
+#define SRE_XGE_MULTICAST_ADDR_EN_0_REG            (0x20EC)              /* 接收多地址过滤使能寄存器。 */
+#define SRE_XGE_UNICAST_ADDR0_REG                  (0x20F0)              /* 接收单播地址0。 */
+#define SRE_XGE_UNICAST_ADDR0_HIGH_REG             (0x20F4)              /* 接收单播地址0。 */
+#define SRE_XGE_UNICAST_ADDR1_REG                  (0x20F8)              /* 接收单播地址1。 */
+#define SRE_XGE_UNICAST_ADDR1_HIGH_REG             (0x20FC)              /* 接收单播地址1。 */
+#define SRE_XGE_UNICAST_ADDR2_REG                  (0x2100)              /* 接收单播地址2。 */
+#define SRE_XGE_UNICAST_ADDR2_HIGH_REG             (0x2104)              /* 接收单播地址2。 */
+#define SRE_XGE_UNICAST_ADDR3_REG                  (0x2108)              /* 接收单播地址3。 */
+#define SRE_XGE_UNICAST_ADDR3_HIGH_REG             (0x210C)              /* 接收单播地址3。 */
+#define SRE_XGE_UNICAST_ADDR4_REG                  (0x2110)              /* 接收单播地址4。 */
+#define SRE_XGE_UNICAST_ADDR4_HIGH_REG             (0x2114)              /* 接收单播地址4。 */
+#define SRE_XGE_UNICAST_ADDR5_REG                  (0x2118)              /* 接收单播地址5。 */
+#define SRE_XGE_UNICAST_ADDR5_HIGH_REG             (0x211C)              /* 接收单播地址5。 */
+#define SRE_XGE_UNICAST_ADDR6_REG                  (0x2120)              /* 接收单播地址6。 */
+#define SRE_XGE_UNICAST_ADDR6_HIGH_REG             (0x2124)              /* 接收单播地址6。 */
+#define SRE_XGE_UNICAST_ADDR7_REG                  (0x2128)              /* 接收单播地址7。 */
+#define SRE_XGE_UNICAST_ADDR7_HIGH_REG             (0x212C)              /* 接收单播地址7。 */
+#define SRE_XGE_UNICAST_ADDR8_REG                  (0x2130)              /* 接收单播地址8。 */
+#define SRE_XGE_UNICAST_ADDR8_HIGH_REG             (0x2134)              /* 接收单播地址8。 */
+#define SRE_XGE_UNICAST_ADDR9_REG                  (0x2138)              /* 接收单播地址9。 */
+#define SRE_XGE_UNICAST_ADDR9_HIGH_REG             (0x213C)              /* 接收单播地址9。 */
+#define SRE_XGE_UNICAST_ADDR10_REG                 (0x2140)              /* 接收单播地址10。 */
+#define SRE_XGE_UNICAST_ADDR10_HIGH_REG            (0x2144)              /* 接收单播地址10。 */
+#define SRE_XGE_UNICAST_ADDR11_REG                 (0x2148)              /* 接收单播地址11。 */
+#define SRE_XGE_UNICAST_ADDR11_HIGH_REG            (0x214C)              /* 接收单播地址11。 */
+#define SRE_XGE_UNICAST_ADDR12_REG                 (0x2150)              /* 接收单播地址12。 */
+#define SRE_XGE_UNICAST_ADDR12_HIGH_REG            (0x2154)              /* 接收单播地址12。 */
+#define SRE_XGE_UNICAST_ADDR13_REG                 (0x2158)              /* 接收单播地址13。 */
+#define SRE_XGE_UNICAST_ADDR13_HIGH_REG            (0x215C)              /* 接收单播地址13。 */
+#define SRE_XGE_UNICAST_ADDR14_REG                 (0x2160)              /* 接收单播地址14。 */
+#define SRE_XGE_UNICAST_ADDR14_HIGH_REG            (0x2164)              /* 接收单播地址14。 */
+#define SRE_XGE_UNICAST_ADDR15_REG                 (0x2168)              /* 接收单播地址15。 */
+#define SRE_XGE_UNICAST_ADDR15_HIGH_REG            (0x216C)              /* 接收单播地址15。 */
+#define SRE_XGE_UNICAST_ADDR16_REG                 (0x2170)              /* 接收单播地址16。 */
+#define SRE_XGE_UNICAST_ADDR16_HIGH_REG            (0x2174)              /* 接收单播地址16。 */
+#define SRE_XGE_UNICAST_ADDR17_REG                 (0x2178)              /* 接收单播地址17。 */
+#define SRE_XGE_UNICAST_ADDR17_HIGH_REG            (0x217C)              /* 接收单播地址17。 */
+#define SRE_XGE_UNICAST_ADDR18_REG                 (0x2180)              /* 接收单播地址18。 */
+#define SRE_XGE_UNICAST_ADDR18_HIGH_REG            (0x2184)              /* 接收单播地址18。 */
+#define SRE_XGE_UNICAST_ADDR19_REG                 (0x2188)              /* 接收单播地址19。 */
+#define SRE_XGE_UNICAST_ADDR19_HIGH_REG            (0x218C)              /* 接收单播地址19。 */
+#define SRE_XGE_UNICAST_ADDR20_REG                 (0x2190)              /* 接收单播地址20。 */
+#define SRE_XGE_UNICAST_ADDR20_HIGH_REG            (0x2194)              /* 接收单播地址20。 */
+#define SRE_XGE_UNICAST_ADDR21_REG                 (0x2198)              /* 接收单播地址21。 */
+#define SRE_XGE_UNICAST_ADDR21_HIGH_REG            (0x219C)              /* 接收单播地址21。 */
+#define SRE_XGE_UNICAST_ADDR22_REG                 (0x21A0)              /* 接收单播地址22。 */
+#define SRE_XGE_UNICAST_ADDR22_HIGH_REG            (0x21A4)              /* 接收单播地址22。 */
+#define SRE_XGE_UNICAST_ADDR23_REG                 (0x21A8)              /* 接收单播地址23。 */
+#define SRE_XGE_UNICAST_ADDR23_HIGH_REG            (0x21AC)              /* 接收单播地址23。 */
+#define SRE_XGE_UNICAST_ADDR24_REG                 (0x21B0)              /* 接收单播地址24。 */
+#define SRE_XGE_UNICAST_ADDR24_HIGH_REG            (0x21B4)              /* 接收单播地址24。 */
+#define SRE_XGE_UNICAST_ADDR25_REG                 (0x21B8)              /* 接收单播地址25。 */
+#define SRE_XGE_UNICAST_ADDR25_HIGH_REG            (0x21BC)              /* 接收单播地址25。 */
+#define SRE_XGE_UNICAST_ADDR26_REG                 (0x21C0)              /* 接收单播地址26。 */
+#define SRE_XGE_UNICAST_ADDR26_HIGH_REG            (0x21C4)              /* 接收单播地址26。 */
+#define SRE_XGE_UNICAST_ADDR27_REG                 (0x21C8)              /* 接收单播地址27。 */
+#define SRE_XGE_UNICAST_ADDR27_HIGH_REG            (0x21CC)              /* 接收单播地址27。 */
+#define SRE_XGE_UNICAST_ADDR28_REG                 (0x21D0)              /* 接收单播地址28。 */
+#define SRE_XGE_UNICAST_ADDR28_HIGH_REG            (0x21D4)              /* 接收单播地址28。 */
+#define SRE_XGE_UNICAST_ADDR29_REG                 (0x21D8)              /* 接收单播地址29。 */
+#define SRE_XGE_UNICAST_ADDR29_HIGH_REG            (0x21DC)              /* 接收单播地址29。 */
+#define SRE_XGE_UNICAST_ADDR30_REG                 (0x21E0)              /* 接收单播地址30。 */
+#define SRE_XGE_UNICAST_ADDR30_HIGH_REG            (0x21E4)              /* 接收单播地址30。 */
+#define SRE_XGE_UNICAST_ADDR31_REG                 (0x21E8)              /* 接收单播地址31。 */
+#define SRE_XGE_UNICAST_ADDR31_HIGH_REG            (0x21EC)              /* 接收单播地址31。 */
+#define SRE_XGE_UNICAST_ADDR32_REG                 (0x21F0)              /* 接收单播地址32。 */
+#define SRE_XGE_UNICAST_ADDR32_HIGH_REG            (0x21F4)              /* 接收单播地址32。 */
+#define SRE_XGE_UNICAST_ADDR33_REG                 (0x21F8)              /* 接收单播地址33。 */
+#define SRE_XGE_UNICAST_ADDR33_HIGH_REG            (0x21FC)              /* 接收单播地址33。 */
+#define SRE_XGE_UNICAST_ADDR34_REG                 (0x2200)              /* 接收单播地址34。 */
+#define SRE_XGE_UNICAST_ADDR34_HIGH_REG            (0x2204)              /* 接收单播地址34。 */
+#define SRE_XGE_UNICAST_ADDR35_REG                 (0x2208)              /* 接收单播地址35。 */
+#define SRE_XGE_UNICAST_ADDR35_HIGH_REG            (0x220C)              /* 接收单播地址35。 */
+#define SRE_XGE_MULTICAST_ADDR0_REG                (0x2210)              /* 接收多播地址0。 */
+#define SRE_XGE_MULTICAST_ADDR0_HIGH_REG           (0x2214)              /* 接收多播地址0。 */
+#define SRE_XGE_MULTICAST_ADDR1_REG                (0x2218)              /* 接收多播地址1。 */
+#define SRE_XGE_MULTICAST_ADDR1_HIGH_REG           (0x221C)              /* 接收多播地址1。 */
+#define SRE_XGE_MULTICAST_ADDR2_REG                (0x2220)              /* 接收多播地址2。 */
+#define SRE_XGE_MULTICAST_ADDR2_HIGH_REG           (0x2224)              /* 接收多播地址2。 */
+#define SRE_XGE_MULTICAST_ADDR3_REG                (0x2228)              /* 接收多播地址3。 */
+#define SRE_XGE_MULTICAST_ADDR3_HIGH_REG           (0x222C)              /* 接收多播地址3。 */
+#define SRE_XGE_MULTICAST_ADDR4_REG                (0x2230)              /* 接收多播地址4。 */
+#define SRE_XGE_MULTICAST_ADDR4_HIGH_REG           (0x2234)              /* 接收多播地址4。 */
+#define SRE_XGE_MULTICAST_ADDR5_REG                (0x2238)              /* 接收多播地址5。 */
+#define SRE_XGE_MULTICAST_ADDR5_HIGH_REG           (0x223C)              /* 接收多播地址5。 */
+#define SRE_XGE_MULTICAST_ADDR6_REG                (0x2240)              /* 接收多播地址6。 */
+#define SRE_XGE_MULTICAST_ADDR6_HIGH_REG           (0x2244)              /* 接收多播地址6。 */
+#define SRE_XGE_MULTICAST_ADDR7_REG                (0x2248)              /* 接收多播地址7。 */
+#define SRE_XGE_MULTICAST_ADDR7_HIGH_REG           (0x224C)              /* 接收多播地址7。 */
+#define SRE_XGE_MULTICAST_MSK0_REG                 (0x2250)              /* 接收多播掩码0。 */
+#define SRE_XGE_MULTICAST_MSK0_HIGH_REG            (0x2254)              /* 接收多播掩码0。 */
+#define SRE_XGE_MULTICAST_MSK1_REG                 (0x2258)              /* 接收多播掩码1。 */
+#define SRE_XGE_MULTICAST_MSK1_HIGH_REG            (0x225C)              /* 接收多播掩码1。 */
+#define SRE_XGE_MULTICAST_MSK2_REG                 (0x2260)              /* 接收多播掩码2。 */
+#define SRE_XGE_MULTICAST_MSK2_HIGH_REG            (0x2264)              /* 接收多播掩码2。 */
+#define SRE_XGE_MULTICAST_MSK3_REG                 (0x2268)              /* 接收多播掩码3。 */
+#define SRE_XGE_MULTICAST_MSK3_HIGH_REG            (0x226C)              /* 接收多播掩码3。 */
+#define SRE_XGE_MULTICAST_MSK4_REG                 (0x2270)              /* 接收多播掩码4。 */
+#define SRE_XGE_MULTICAST_MSK4_HIGH_REG            (0x2274)              /* 接收多播掩码4。 */
+#define SRE_XGE_MULTICAST_MSK5_REG                 (0x2278)              /* 接收多播掩码5。 */
+#define SRE_XGE_MULTICAST_MSK5_HIGH_REG            (0x227C)              /* 接收多播掩码5。 */
+#define SRE_XGE_MULTICAST_MSK6_REG                 (0x2280)              /* 接收多播掩码6。 */
+#define SRE_XGE_MULTICAST_MSK6_HIGH_REG            (0x2284)              /* 接收多播掩码6。 */
+#define SRE_XGE_MULTICAST_MSK7_REG                 (0x2288)              /* 接收多播掩码7。 */
+#define SRE_XGE_MULTICAST_MSK7_HIGH_REG            (0x228C)              /* 接收多播掩码7。 */
+
+/*                      SERDES1 寄存器定义              z00202052            */
+/******************************************************************************/
+#define SERDES1_BASE_ADDR            (0xe28e0000)
+
+/*                      MDIO 寄存器偏移地址定义                          */
+/******************************************************************************/
+#if 0         /* z00202052 */
+#define MDIO_BASE_ADDR               (0x128f0000)
+#else
+#define MDIO_BASE_ADDR               (0xe28f0000)
+#endif        /* z00202052 */
+
+#define MDIO_COMMAND_REG            (0x0)          /* MDIO控制寄存器 */
+#define MDIO_ADDR_REG               (0x4)          /* MDIO间接地址寄存器 */
+#define MDIO_WDATA_REG              (0x8)          /* MDIO写数据寄存器 */
+#define MDIO_RDATA_REG              (0xc)          /* MDIO读数据寄存器 */
+#define MDIO_STA_REG                (0x10)         /* MDIO访问状态寄存器 */
+
+
+/******************************************************************************/
+/*                      PhosphorV600 MDIO PCU 寄存器定义                      */
+/******************************************************************************/
+#define SRE_MDIO_CMD_REG                 (0x0)
+#define SRE_MDIO_RD_WR_DATA_REG          (0x4)
+#define SRE_MDIO_AUTOSCAN_PHY_ADDR_REG   (0x8)
+#define SRE_MDIO_CTROL_REG               (0xC)
+#define SRE_MDIO_STAT_REG                (0x10)
+#define SRE_MDIO_SOFT_RST_MDIO_REG       (0x14)
+#define SRE_MDIO_PHY0_ADDR_REG           (0x18)
+#define SRE_MDIO_PHY1_ADDR_REG           (0x1C)
+#define SRE_MDIO_PHY2_ADDR_REG           (0x20)
+#define SRE_MDIO_PHY3_ADDR_REG           (0x24)
+#define SRE_MDIO_PHY4_ADDR_REG           (0x28)
+#define SRE_MDIO_PHY_TYPE_REG            (0x2C)
+#define SRE_MDIO_PHY0_CONTROL_REG        (0x600)
+#define SRE_MDIO_PHY0_STATUS_REG         (0x610)
+#define SRE_MDIO_PHY0_ID1_REG            (0x620)
+#define SRE_MDIO_PHY0_ID2_REG            (0x630)
+#define SRE_MDIO_AN0_ADVERTISEMENT_REG   (0x640)
+#define SRE_MDIO_LINK0_BASE_PAGE_REG     (0x650)
+#define SRE_MDIO_AN0_EXPANSION_REG       (0x660)
+#define SRE_MDIO_AN0_NP_TX_REG           (0x670)
+#define SRE_MDIO_PHY1_CONTROL_REG        (0x700)
+#define SRE_MDIO_PHY1_STATUS_REG         (0x710)
+#define SRE_MDIO_PHY1_ID1_REG            (0x720)
+#define SRE_MDIO_PHY1_ID2_REG            (0x730)
+#define SRE_MDIO_AN1_ADVERTISEMENT_REG   (0x740)
+#define SRE_MDIO_LINK1_BASE_PAGE_REG     (0x750)
+#define SRE_MDIO_AN1_EXPANSION_REG       (0x760)
+#define SRE_MDIO_AN1_NP_TX_REG           (0x770)
+#define SRE_MDIO_PHY2_CONTROL_REG        (0x800)
+#define SRE_MDIO_PHY2_STATUS_REG         (0x810)
+#define SRE_MDIO_PHY2_ID1_REG            (0x820)
+#define SRE_MDIO_PHY2_ID2_REG            (0x830)
+#define SRE_MDIO_AN2_ADVERTISEMENT_REG   (0x840)
+#define SRE_MDIO_LINK2_BASE_PAGE_REG     (0x850)
+#define SRE_MDIO_AN2_EXPANSION_REG       (0x860)
+#define SRE_MDIO_AN2_NP_TX_REG           (0x870)
+#define SRE_MDIO_PHY3_CONTROL_REG        (0x900)
+#define SRE_MDIO_PHY3_STATUS_REG         (0x910)
+#define SRE_MDIO_PHY3_ID1_REG            (0x920)
+#define SRE_MDIO_PHY3_ID2_REG            (0x930)
+#define SRE_MDIO_AN3_ADVERTISEMENT_REG   (0x940)
+#define SRE_MDIO_LINK3_BASE_PAGE_REG     (0x950)
+#define SRE_MDIO_AN3_EXPANSION_REG       (0x960)
+#define SRE_MDIO_AN3_NP_TX_REG           (0x970)
+#define SRE_MDIO_PHY4_CONTROL_REG        (0xA00)
+#define SRE_MDIO_PHY4_STATUS_REG         (0xA10)
+#define SRE_MDIO_PHY4_ID1_REG            (0xA20)
+#define SRE_MDIO_PHY4_ID2_REG            (0xA30)
+#define SRE_MDIO_AN4_ADVERTISEMENT_REG   (0xA40)
+#define SRE_MDIO_LINK4_BASE_PAGE_REG     (0xA50)
+#define SRE_MDIO_AN4_EXPANSION_REG       (0xA60)
+#define SRE_MDIO_AN4_NP_TX_REG           (0xA70)
+
+/*                      SERDES0_L 寄存器定义            z00202052            */
+/******************************************************************************/
+#define SERDES0_LOW_BASE_ADDR        (0xe28f2000)
+
+/*                      SERDES0_H 寄存器定义            z00202052            */
+/******************************************************************************/
+#define SERDES0_HIGHT_BASE_ADDR      (0xe28f3000)
+
+/*                      IOCTRL0 寄存器定义              z00202052            */
+/******************************************************************************/
+#define IOCTRL0_BASE_ADDR                 (0xe28f4000)
+
+/* PDM 模块寄存器定义 */
+#define SRE_PDM_BASE_ADDR                       (0x10820000)
+#define SRE_PDM_ENA                             (SRE_PDM_BASE_ADDR + 0x00 )
+#define SRE_PDM_GETPOE_STOP                     (SRE_PDM_BASE_ADDR + 0x04 )
+#define SRE_PDM_NODE_CODE                       (SRE_PDM_BASE_ADDR + 0x08 )
+#define SRE_PDM_CFG_ENDIAN                      (SRE_PDM_BASE_ADDR + 0x0c )
+#define SRE_PDM_CACHE_CFG                       (SRE_PDM_BASE_ADDR + 0x10 )
+#define SRE_PDM_CFG_BUS_CTRL                    (SRE_PDM_BASE_ADDR + 0x14 )
+#define SRE_PDM_CFG_BUS_TIMEOUT_THRSHLD         (SRE_PDM_BASE_ADDR + 0x18 )
+#define SRE_PDM_CFG_STS_TIMEOUT_THRSHLD         (SRE_PDM_BASE_ADDR + 0x1c )
+#define SRE_PDM_REFCNT_CTRL                     (SRE_PDM_BASE_ADDR + 0x20 )
+#define SRE_PDM_ERR_GROUP                       (SRE_PDM_BASE_ADDR + 0x24 )
+#define SRE_PDM_ERR_QOS                         (SRE_PDM_BASE_ADDR + 0x28 )
+#define SRE_PDM_ERR_TT                          (SRE_PDM_BASE_ADDR + 0x2c )
+#define SRE_PDM_ERR_TAG                         (SRE_PDM_BASE_ADDR + 0x30 )
+#define SRE_PDM_NULL_GROUP                      (SRE_PDM_BASE_ADDR + 0x34 )
+#define SRE_PDM_NULL_QOS                        (SRE_PDM_BASE_ADDR + 0x38 )
+#define SRE_PDM_NULL_TT                         (SRE_PDM_BASE_ADDR + 0x3c )
+#define SRE_PDM_NULL_TAG                        (SRE_PDM_BASE_ADDR + 0x40 )
+#define SRE_PDM_BYP_GROUP                       (SRE_PDM_BASE_ADDR + 0x44 )
+#define SRE_PDM_BYP_QOS                         (SRE_PDM_BASE_ADDR + 0x48 )
+#define SRE_PDM_GETPKT_ADDR                     (SRE_PDM_BASE_ADDR + 0x4c )
+#define SRE_PDM_ADDPKT_ADDR                     (SRE_PDM_BASE_ADDR + 0x50 )
+#define SRE_PDM_ADDSPE_BASE_ADDR                (SRE_PDM_BASE_ADDR + 0x54 )
+#define SRE_PDM_BYP_SPACE_TIME                  (SRE_PDM_BASE_ADDR + 0x58 )
+#define SRE_PDM_MACSDU_PROC_TIMEOUT_THRSHLD     (SRE_PDM_BASE_ADDR + 0x5c )
+#define SRE_PDM_BYP_WATERLINE                   (SRE_PDM_BASE_ADDR + 0x60 )
+#define SRE_PDM_GETPOE_CONTFAIL                 (SRE_PDM_BASE_ADDR + 0x64 )
+#define SRE_PDM_ADDPOE_CONTFAIL                 (SRE_PDM_BASE_ADDR + 0x68 )
+#define SRE_PDM_POE_FAIL_WAIT_TIME              (SRE_PDM_BASE_ADDR + 0x6c )
+#define SRE_PDM_POE_OK_WAIT_TIME                (SRE_PDM_BASE_ADDR + 0x70 )
+#define SRE_PDM_BMU_BASE_ADDR                   (SRE_PDM_BASE_ADDR + 0x74 )
+#define SRE_PDM_GETBMU_POOL_VMID                (SRE_PDM_BASE_ADDR + 0x78 )
+#define SRE_PDM_GETBMU_CONTFAIL                 (SRE_PDM_BASE_ADDR + 0x7c )
+#define SRE_PDM_BMU_GETFAIL_WAIT_TIME           (SRE_PDM_BASE_ADDR + 0x80 )
+#define SRE_PDM_MACETT_ADDR                     (SRE_PDM_BASE_ADDR + 0x84 )
+#define SRE_PDM_MACETT_SIZE                     (SRE_PDM_BASE_ADDR + 0x88 )
+#define SRE_PDM_MACETT_ITEM_SIZE                (SRE_PDM_BASE_ADDR + 0x8c )
+#define SRE_PDM_MACETT_OFFSET                   (SRE_PDM_BASE_ADDR + 0x90 )
+#define SRE_PDM_RLCETT_ADDR                     (SRE_PDM_BASE_ADDR + 0x94 )
+#define SRE_PDM_RLCETT_SIZE                     (SRE_PDM_BASE_ADDR + 0x98 )
+#define SRE_PDM_RLCETT_ITEM_SIZE                (SRE_PDM_BASE_ADDR + 0x9c )
+#define SRE_PDM_RLCETT_OFFSET                   (SRE_PDM_BASE_ADDR + 0xa0 )
+#define SRE_PDM_VBD_SKIP_SIZE                   (SRE_PDM_BASE_ADDR + 0xa4 )
+#define SRE_PDM_MAX_MAC_HEAD_SIZE               (SRE_PDM_BASE_ADDR + 0xa8 )
+#define SRE_PDM_MAX_SDU_NUM                     (SRE_PDM_BASE_ADDR + 0xac )
+#define SRE_PDM_LCID_BEGIN_END                  (SRE_PDM_BASE_ADDR + 0xb0 )
+#define SRE_PDM_ACC_VMID                        (SRE_PDM_BASE_ADDR + 0xb4 )
+#define SRE_PDM_HIS_CLR_EN                      (SRE_PDM_BASE_ADDR + 0xb8 )
+#define SRE_PDM_AXI_TRACE_ENA                   (SRE_PDM_BASE_ADDR + 0xbc )
+#define SRE_PDM_AXI_STAT_CLR                    (SRE_PDM_BASE_ADDR + 0xc0 )
+#define SRE_PDM_INTMSK_ERR                      (SRE_PDM_BASE_ADDR + 0xc4 )
+#define SRE_PDM_RINT_ERR                        (SRE_PDM_BASE_ADDR + 0xc8 )
+#define SRE_PDM_INTSTS_ERR                      (SRE_PDM_BASE_ADDR + 0xcc )
+#define SRE_PDM_GET_PKT_OK_CNT                  (SRE_PDM_BASE_ADDR + 0xd0 )
+#define SRE_PDM_GET_PKT_FAIL_CNT                (SRE_PDM_BASE_ADDR + 0xd4 )
+#define SRE_PDM_ADD_PKT_OK_CNT                  (SRE_PDM_BASE_ADDR + 0xd8 )
+#define SRE_PDM_ADD_PKT_FAIL_CNT                (SRE_PDM_BASE_ADDR + 0xdc )
+#define SRE_PDM_ADD_MCE_OK_CNT                  (SRE_PDM_BASE_ADDR + 0xe0 )
+#define SRE_PDM_ADD_MCE_FAIL_CNT                (SRE_PDM_BASE_ADDR + 0xe4 )
+#define SRE_PDM_ADD_BYP_OK_CNT                  (SRE_PDM_BASE_ADDR + 0xe8 )
+#define SRE_PDM_ADD_BYP_FAIL_CNT                (SRE_PDM_BASE_ADDR + 0xec )
+#define SRE_PDM_GET_BUFFOK_CNT                  (SRE_PDM_BASE_ADDR + 0xf0 )
+#define SRE_PDM_GET_BUFFFAIL_CNT                (SRE_PDM_BASE_ADDR + 0xf4 )
+#define SRE_PDM_RDBD_FAIL_CNT                   (SRE_PDM_BASE_ADDR + 0xf8 )
+#define SRE_PDM_MACETT_FAIL_CNT                 (SRE_PDM_BASE_ADDR + 0xfc )
+#define SRE_PDM_RLCETT_FAIL_CNT                 (SRE_PDM_BASE_ADDR + 0x100)
+#define SRE_PDM_MAC_PDU_OK_CNT                  (SRE_PDM_BASE_ADDR + 0x104)
+#define SRE_PDM_MAC_PDU_ERROR_CNT               (SRE_PDM_BASE_ADDR + 0x108)
+#define SRE_PDM_BYP_MACSDU_CNT                  (SRE_PDM_BASE_ADDR + 0x10c)
+#define SRE_PDM_RLC_PDU_ERROR_CNT               (SRE_PDM_BASE_ADDR + 0x110)
+#define SRE_PDM_TM_RLCPDU_CNT                   (SRE_PDM_BASE_ADDR + 0x114)
+#define SRE_PDM_AM_UM_RLCPDU_CNT                (SRE_PDM_BASE_ADDR + 0x118)
+#define SRE_PDM_CTRL_RLCPDU_CNT                 (SRE_PDM_BASE_ADDR + 0x11c)
+#define SRE_PDM_AXI_WR_LATENCY_AVG_STAT         (SRE_PDM_BASE_ADDR + 0x120)
+#define SRE_PDM_AXI_RD_LATENCY_AVG_STAT         (SRE_PDM_BASE_ADDR + 0x124)
+#define SRE_PDM_AXI_WR_LATENCY_MAX_STAT         (SRE_PDM_BASE_ADDR + 0x128)
+#define SRE_PDM_AXI_RD_LATENCY_MAX_STAT         (SRE_PDM_BASE_ADDR + 0x12c)
+#define SRE_PDM_AXI_WR_ACC_STAT                 (SRE_PDM_BASE_ADDR + 0x130)
+#define SRE_PDM_AXI_RD_ACC_STAT                 (SRE_PDM_BASE_ADDR + 0x134)
+#define SRE_PDM_AXI_WCHN0_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x138)
+#define SRE_PDM_AXI_WCHN1_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x13c)
+#define SRE_PDM_AXI_WCHN2_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x140)
+#define SRE_PDM_AXI_WCHN3_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x144)
+#define SRE_PDM_AXI_RCHN0_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x148)
+#define SRE_PDM_AXI_RCHN1_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x14c)
+#define SRE_PDM_AXI_RCHN2_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x150)
+#define SRE_PDM_AXI_RCHN3_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x154)
+#define SRE_PDM_AXI_RCHN4_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x158)
+#define SRE_PDM_AXI_RCHN5_OTSD_CNT              (SRE_PDM_BASE_ADDR + 0x15c)
+#define SRE_PDM_PKT_PRERD_STATE                 (SRE_PDM_BASE_ADDR + 0x160)
+#define SRE_PDM_MAC_PARSE_STATE                 (SRE_PDM_BASE_ADDR + 0x164)
+#define SRE_PDM_RLC_PARSE_STATE                 (SRE_PDM_BASE_ADDR + 0x168)
+#define SRE_PDM_BUS_BUSY                        (SRE_PDM_BASE_ADDR + 0x16c)
+#define SRE_PDM_PKT_FINISH                      (SRE_PDM_BASE_ADDR + 0x170)
+
+
+/* POE 模块寄存器基地址 */
+#if 0         /* z00202052 */
+#define SRE_POE_BASE                               (0x12000000)
+#define SRE_POE_NORMAL_BASE                        (0x1E000000)
+#else
+#define SRE_POE_BASE                               (0xe2000000)
+#define SRE_POE_NORMAL_BASE                        (0xee000000)
+#endif        /* z00202052 */
+
+/******************************************************************************/
+/*                      MC POE 寄存器定义                                     */
+/******************************************************************************/
+#define SRE_POE_PDM_WORD0_SPE_ADD_0_REG            (SRE_POE_BASE + 0x0)             /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD0_SPE_ADD_1_REG            (SRE_POE_BASE + 0x20)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD1_SPE_ADD_0_REG            (SRE_POE_BASE + 0x4)             /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD1_SPE_ADD_1_REG            (SRE_POE_BASE + 0x24)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD2_SPE_ADD_0_REG            (SRE_POE_BASE + 0x8)             /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD2_SPE_ADD_1_REG            (SRE_POE_BASE + 0x28)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD3_SPE_ADD_0_REG            (SRE_POE_BASE + 0xC)             /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD3_SPE_ADD_1_REG            (SRE_POE_BASE + 0x2C)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD4_SPE_ADD_0_REG            (SRE_POE_BASE + 0x10)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD4_SPE_ADD_1_REG            (SRE_POE_BASE + 0x30)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD5_SPE_ADD_0_REG            (SRE_POE_BASE + 0x14)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD5_SPE_ADD_1_REG            (SRE_POE_BASE + 0x34)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD6_SPE_ADD_0_REG            (SRE_POE_BASE + 0x18)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD6_SPE_ADD_1_REG            (SRE_POE_BASE + 0x38)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_PDM_WORD7_SPE_ADD_0_REG            (SRE_POE_BASE + 0x1C)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+ */
+#define SRE_POE_PDM_WORD7_SPE_ADD_1_REG            (SRE_POE_BASE + 0x3C)            /* 加速器PDM指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+ */
+
+#define POE_PROFILE_DEVICE 1      //POE CPU读写命令寄存器 1:0? DEVICE, NORMAL?
+
+#ifdef POE_PROFILE_DEVICE
+#define SRE_POE_VCPU_WORD0_WR_CMD_0_REG            (SRE_POE_BASE + 0x2000)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD0_WR_CMD_1_REG            (SRE_POE_BASE + 0x2020)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD1_WR_CMD_0_REG            (SRE_POE_BASE + 0x2004)          /* 逻辑CPU在POE模块中写命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD1_WR_CMD_1_REG            (SRE_POE_BASE + 0x2024)          /* 逻辑CPU在POE模块中写命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD2_WR_CMD_0_REG            (SRE_POE_BASE + 0x2008)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD2_WR_CMD_1_REG            (SRE_POE_BASE + 0x2028)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD3_WR_CMD_0_REG            (SRE_POE_BASE + 0x200C)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD3_WR_CMD_1_REG            (SRE_POE_BASE + 0x202C)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD4_WR_CMD_0_REG            (SRE_POE_BASE + 0x2010)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD4_WR_CMD_1_REG            (SRE_POE_BASE + 0x2030)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD5_WR_CMD_0_REG            (SRE_POE_BASE + 0x2014)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD5_WR_CMD_1_REG            (SRE_POE_BASE + 0x2034)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD6_WR_CMD_0_REG            (SRE_POE_BASE + 0x2018)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD6_WR_CMD_1_REG            (SRE_POE_BASE + 0x2038)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD7_WR_CMD_0_REG            (SRE_POE_BASE + 0x201C)          /* 逻辑CPU在POE模块中写命令寄存器。 */
+#define SRE_POE_VCPU_WORD7_WR_CMD_1_REG            (SRE_POE_BASE + 0x203C)          /* 逻辑CPU在POE模块中写命令寄存器。 */
+#else
+#define SRE_POE_VCPU_WORD0_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2000)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD0_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2020)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD1_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2004)          /* 逻辑CPU在POE模块中写命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD1_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2024)          /* 逻辑CPU在POE模块中写命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD2_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2008)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD2_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2028)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD3_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x200C)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD3_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x202C)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD4_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2010)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD4_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2030)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD5_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2014)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD5_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2034)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD6_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x2018)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD6_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x2038)          /* 逻辑CPU在POE模块中写命令寄存器 */
+#define SRE_POE_VCPU_WORD7_WR_CMD_0_REG            (SRE_POE_NORMAL_BASE + 0x201C)          /* 逻辑CPU在POE模块中写命令寄存器。 */
+#define SRE_POE_VCPU_WORD7_WR_CMD_1_REG            (SRE_POE_NORMAL_BASE + 0x203C)          /* 逻辑CPU在POE模块中写命令寄存器。 */
+#endif
+
+#define SRE_POE_ACC_WORD0_ADD_REG                  (SRE_POE_BASE + 0x2800)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。域描述以全局数据结构为准。ROHC,SEC,PDM,Tring，AQM，ULHDCP,DLHDCP,IMA加速器添加包任务专用。 */
+#define SRE_POE_ACC_WORD1_ADD_REG                  (SRE_POE_BASE + 0x2804)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。ROHC,SEC,PDM,Tring，AQM，ULHDCP,DLHDCP,IMA加速器添加包任务专用。 */
+#define SRE_POE_ACC_WORD2_ADD_REG                  (SRE_POE_BASE + 0x2808)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。ROHC,SEC,PDM,Tring，AQM，ULHDCP,DLHDCP,IMA加速器添加包任务专用。 */
+#define SRE_POE_ACC_WORD3_ADD_REG                  (SRE_POE_BASE + 0x280C)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。ROHC,SEC,PDM,Tring，AQM，ULHDCP,DLHDCP,IMA加速器添加包任务专用。 */
+#define SRE_POE_TM_SPPE_WORD0_ADD_REG              (SRE_POE_BASE + 0x2820)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。域描述以全局数据结构为准。SPPE，TM，POE,MPE加速器添加包任务专用。 */
+#define SRE_POE_TM_SPPE_WORD1_ADD_REG              (SRE_POE_BASE + 0x2824)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。SPPE，TM，POE,MPE加速器添加包任务专用。 */
+#define SRE_POE_TM_SPPE_WORD2_ADD_REG              (SRE_POE_BASE + 0x2828)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。SPPE，TM，POE,MPE加速器添加包任务专用。 */
+#define SRE_POE_TM_SPPE_WORD3_ADD_REG              (SRE_POE_BASE + 0x282C)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。SPPE，TM，POE,MPE加速器添加包任务专用。 */
+#define SRE_POE_PPE_WORD0_ADD_REG                  (SRE_POE_BASE + 0x2840)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。域描述以全局数据结构为准。PPE加速器添加包任务专用。 */
+#define SRE_POE_PPE_WORD1_ADD_REG                  (SRE_POE_BASE + 0x2844)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。PPE加速器添加包任务专用。 */
+#define SRE_POE_PPE_WORD2_ADD_REG                  (SRE_POE_BASE + 0x2848)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。PPE加速器添加包任务专用。 */
+#define SRE_POE_PPE_WORD3_ADD_REG                  (SRE_POE_BASE + 0x284C)          /* 加速器向POE模块中添加包任务的ADD_PACKET命令寄存器。PPE加速器添加包任务专用。
+下面从2860~3FFC地址保留 */
+
+#ifdef POE_PROFILE_DEVICE
+#define SRE_POE_VCPU_WORD0_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4000)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4020)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6000)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6020)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4004)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4024)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6004)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6024)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4008)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4028)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6008)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6028)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_0_REG           (SRE_POE_BASE + 0x400C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_1_REG           (SRE_POE_BASE + 0x402C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_2_REG           (SRE_POE_BASE + 0x600C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_3_REG           (SRE_POE_BASE + 0x602C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4010)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4030)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6010)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6030)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4014)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4034)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6014)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6034)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_0_REG           (SRE_POE_BASE + 0x4018)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_1_REG           (SRE_POE_BASE + 0x4038)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_2_REG           (SRE_POE_BASE + 0x6018)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_3_REG           (SRE_POE_BASE + 0x6038)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_0_REG           (SRE_POE_BASE + 0x401C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_1_REG           (SRE_POE_BASE + 0x403C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_2_REG           (SRE_POE_BASE + 0x601C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_3_REG           (SRE_POE_BASE + 0x603C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#else
+#define SRE_POE_VCPU_WORD0_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4000)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4020)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6000)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD0_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6020)          /* 逻辑CPU_0指定队列添加核间消息的ADD_SPE_WORK命令寄存器。CPU添加任务是否成功，需读取VCPU_ADD_ST寄存器进行确认。 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4004)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4024)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6004)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD1_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6024)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4008)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4028)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6008)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD2_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6028)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x400C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x402C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x600C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD3_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x602C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4010)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4030)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6010)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD4_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6030)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4014)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4034)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6014)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD5_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6034)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x4018)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x4038)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x6018)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD6_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x6038)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_0_REG           (SRE_POE_NORMAL_BASE + 0x401C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_1_REG           (SRE_POE_NORMAL_BASE + 0x403C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_2_REG           (SRE_POE_NORMAL_BASE + 0x601C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#define SRE_POE_VCPU_WORD7_SPE_ADD_3_REG           (SRE_POE_NORMAL_BASE + 0x603C)          /* 逻辑CPU指定队列添加核间消息的ADD_SPE_WORK命令寄存器
+以下0x84000~0x84ffc地址保留 */
+#endif
+
+#define SRE_POE_SEC_WORD0_GET_REG                  (SRE_POE_BASE + 0x85000)         /* POE模块中SEC的GET_POE命令寄存器。 */
+#define SRE_POE_SEC_WORD1_GET_REG                  (SRE_POE_BASE + 0x85004)         /* POE模块中SEC的GET_POE命令寄存器。 */
+#define SRE_POE_SEC_WORD2_GET_REG                  (SRE_POE_BASE + 0x85008)         /* POE模块中SEC的GET_POE命令寄存器。 */
+#define SRE_POE_SEC_WORD3_GET_REG                  (SRE_POE_BASE + 0x8500C)         /* POE模块中SEC的GET_POE命令寄存器。 */
+#define SRE_POE_SPPE_WORD0_GET_REG                 (SRE_POE_BASE + 0x85020)         /* POE模块中SPPE的GET_POE命令寄存器。 */
+#define SRE_POE_SPPE_WORD1_GET_REG                 (SRE_POE_BASE + 0x85024)         /* POE模块中SPPE的GET_POE命令寄存器。 */
+#define SRE_POE_SPPE_WORD2_GET_REG                 (SRE_POE_BASE + 0x85028)         /* POE模块中SPPE的GET_POE命令寄存器。 */
+#define SRE_POE_SPPE_WORD3_GET_REG                 (SRE_POE_BASE + 0x8502C)         /* POE模块中SPPE的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_ZIP_WORD0_GET_REG             (SRE_POE_BASE + 0x85040)         /* POE模块中ROHC压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_ZIP_WORD1_GET_REG             (SRE_POE_BASE + 0x85044)         /* POE模块中ROHC压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_ZIP_WORD2_GET_REG             (SRE_POE_BASE + 0x85048)         /* POE模块中ROHC压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_ZIP_WORD3_GET_REG             (SRE_POE_BASE + 0x8504C)         /* POE模块中ROHC压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_UZIP_WORD0_GET_REG            (SRE_POE_BASE + 0x85060)         /* POE模块中ROHC解压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_UZIP_WORD1_GET_REG            (SRE_POE_BASE + 0x85064)         /* POE模块中ROHC解压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_UZIP_WORD2_GET_REG            (SRE_POE_BASE + 0x85068)         /* POE模块中ROHC解压缩的GET_POE命令寄存器。 */
+#define SRE_POE_ROHC_UZIP_WORD3_GET_REG            (SRE_POE_BASE + 0x8506C)         /* POE模块中ROHC解压缩的GET_POE命令寄存器。 */
+#define SRE_POE_PDM_WORD0_GET_REG                  (SRE_POE_BASE + 0x85080)         /* POE模块中PDM的GET_POE命令寄存器。 */
+#define SRE_POE_PDM_WORD1_GET_REG                  (SRE_POE_BASE + 0x85084)         /* POE模块中PDM的GET_POE命令寄存器。 */
+#define SRE_POE_PDM_WORD2_GET_REG                  (SRE_POE_BASE + 0x85088)         /* POE模块中PDM的GET_POE命令寄存器。 */
+#define SRE_POE_PDM_WORD3_GET_REG                  (SRE_POE_BASE + 0x8508C)         /* POE模块中PDM的GET_POE命令寄存器。 */
+#define SRE_POE_ULHDCP_WORD0_GET_REG               (SRE_POE_BASE + 0x850A0)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_ULHDCP_WORD1_GET_REG               (SRE_POE_BASE + 0x850A4)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_ULHDCP_WORD2_GET_REG               (SRE_POE_BASE + 0x850A8)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_ULHDCP_WORD3_GET_REG               (SRE_POE_BASE + 0x850AC)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_DLHDCP_WORD0_GET_REG               (SRE_POE_BASE + 0x850C0)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_DLHDCP_WORD1_GET_REG               (SRE_POE_BASE + 0x850C4)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_DLHDCP_WORD2_GET_REG               (SRE_POE_BASE + 0x850C8)         /* POE模块中HDCP的GET_POE命令寄存器。 */
+#define SRE_POE_DLHDCP_WORD3_GET_REG               (SRE_POE_BASE + 0x850CC)         /* POE模块中HDCP的GET_POE命令寄存器。
+ */
+#define SRE_POE_ACC_WORD0_GET_0_REG                (SRE_POE_BASE + 0x850E0)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。0x0FC~0x10BC */
+#define SRE_POE_ACC_WORD0_GET_1_REG                (SRE_POE_BASE + 0x85100)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。0x0FC~0x10BC */
+#define SRE_POE_ACC_WORD1_GET_0_REG                (SRE_POE_BASE + 0x850E4)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。 */
+#define SRE_POE_ACC_WORD1_GET_1_REG                (SRE_POE_BASE + 0x85104)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。 */
+#define SRE_POE_ACC_WORD2_GET_0_REG                (SRE_POE_BASE + 0x850E8)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。 */
+#define SRE_POE_ACC_WORD2_GET_1_REG                (SRE_POE_BASE + 0x85108)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。 */
+#define SRE_POE_ACC_WORD3_GET_0_REG                (SRE_POE_BASE + 0x850EC)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。
+以下0x851a0~0x857fc保留 */
+#define SRE_POE_ACC_WORD3_GET_1_REG                (SRE_POE_BASE + 0x8510C)         /* POE模块中预留加速器ACC_{0~5}的GET_POE命令寄存器。
+以下0x851a0~0x857fc保留 */
+#define SRE_POE_VCPU_WORD0_GET_0_REG               (SRE_POE_BASE + 0x85800)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD0_GET_1_REG               (SRE_POE_BASE + 0x85820)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD1_GET_0_REG               (SRE_POE_BASE + 0x85804)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD1_GET_1_REG               (SRE_POE_BASE + 0x85824)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD2_GET_0_REG               (SRE_POE_BASE + 0x85808)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD2_GET_1_REG               (SRE_POE_BASE + 0x85828)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD3_GET_0_REG               (SRE_POE_BASE + 0x8580C)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD3_GET_1_REG               (SRE_POE_BASE + 0x8582C)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD4_GET_0_REG               (SRE_POE_BASE + 0x85810)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD4_GET_1_REG               (SRE_POE_BASE + 0x85830)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD5_GET_0_REG               (SRE_POE_BASE + 0x85814)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD5_GET_1_REG               (SRE_POE_BASE + 0x85834)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD6_GET_0_REG               (SRE_POE_BASE + 0x85818)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD6_GET_1_REG               (SRE_POE_BASE + 0x85838)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD7_GET_0_REG               (SRE_POE_BASE + 0x8581C)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_WORD7_GET_1_REG               (SRE_POE_BASE + 0x8583C)         /* POE模块中逻辑CPU_{0~63}的GET_POE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD0_GET_0_REG             (SRE_POE_BASE + 0x86000)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD0_GET_1_REG             (SRE_POE_BASE + 0x86020)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD0_GET_2_REG             (SRE_POE_BASE + 0x88000)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD0_GET_3_REG             (SRE_POE_BASE + 0x88020)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD1_GET_0_REG             (SRE_POE_BASE + 0x86004)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD1_GET_1_REG             (SRE_POE_BASE + 0x86024)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD1_GET_2_REG             (SRE_POE_BASE + 0x88004)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD1_GET_3_REG             (SRE_POE_BASE + 0x88024)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD2_GET_0_REG             (SRE_POE_BASE + 0x86008)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD2_GET_1_REG             (SRE_POE_BASE + 0x86028)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD2_GET_2_REG             (SRE_POE_BASE + 0x88008)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD2_GET_3_REG             (SRE_POE_BASE + 0x88028)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD3_GET_0_REG             (SRE_POE_BASE + 0x8600C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD3_GET_1_REG             (SRE_POE_BASE + 0x8602C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD3_GET_2_REG             (SRE_POE_BASE + 0x8800C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD3_GET_3_REG             (SRE_POE_BASE + 0x8802C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD4_GET_0_REG             (SRE_POE_BASE + 0x86010)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD4_GET_1_REG             (SRE_POE_BASE + 0x86030)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD4_GET_2_REG             (SRE_POE_BASE + 0x88010)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD4_GET_3_REG             (SRE_POE_BASE + 0x88030)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD5_GET_0_REG             (SRE_POE_BASE + 0x86014)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD5_GET_1_REG             (SRE_POE_BASE + 0x86034)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD5_GET_2_REG             (SRE_POE_BASE + 0x88014)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD5_GET_3_REG             (SRE_POE_BASE + 0x88034)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD6_GET_0_REG             (SRE_POE_BASE + 0x86018)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD6_GET_1_REG             (SRE_POE_BASE + 0x86038)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD6_GET_2_REG             (SRE_POE_BASE + 0x88018)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD6_GET_3_REG             (SRE_POE_BASE + 0x88038)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD7_GET_0_REG             (SRE_POE_BASE + 0x8601C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD7_GET_1_REG             (SRE_POE_BASE + 0x8603C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD7_GET_2_REG             (SRE_POE_BASE + 0x8801C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_Q_WORD7_GET_3_REG             (SRE_POE_BASE + 0x8803C)         /* POE模块中，CPU指定队列读取任务的GET_QUEUE命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD0_GET_0_REG           (SRE_POE_BASE + 0x106000)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD0_GET_1_REG           (SRE_POE_BASE + 0x106020)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD0_GET_2_REG           (SRE_POE_BASE + 0x106400)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD0_GET_3_REG           (SRE_POE_BASE + 0x106420)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD1_GET_0_REG           (SRE_POE_BASE + 0x106004)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD1_GET_1_REG           (SRE_POE_BASE + 0x106024)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD1_GET_2_REG           (SRE_POE_BASE + 0x106404)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD1_GET_3_REG           (SRE_POE_BASE + 0x106424)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD2_GET_0_REG           (SRE_POE_BASE + 0x106008)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD2_GET_1_REG           (SRE_POE_BASE + 0x106028)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD2_GET_2_REG           (SRE_POE_BASE + 0x106408)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD2_GET_3_REG           (SRE_POE_BASE + 0x106428)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD3_GET_0_REG           (SRE_POE_BASE + 0x10600C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD3_GET_1_REG           (SRE_POE_BASE + 0x10602C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD3_GET_2_REG           (SRE_POE_BASE + 0x10640C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD3_GET_3_REG           (SRE_POE_BASE + 0x10642C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD4_GET_0_REG           (SRE_POE_BASE + 0x106010)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD4_GET_1_REG           (SRE_POE_BASE + 0x106030)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD4_GET_2_REG           (SRE_POE_BASE + 0x106410)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD4_GET_3_REG           (SRE_POE_BASE + 0x106430)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD5_GET_0_REG           (SRE_POE_BASE + 0x106014)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD5_GET_1_REG           (SRE_POE_BASE + 0x106034)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD5_GET_2_REG           (SRE_POE_BASE + 0x106414)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD5_GET_3_REG           (SRE_POE_BASE + 0x106434)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD6_GET_0_REG           (SRE_POE_BASE + 0x106018)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD6_GET_1_REG           (SRE_POE_BASE + 0x106038)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD6_GET_2_REG           (SRE_POE_BASE + 0x106418)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD6_GET_3_REG           (SRE_POE_BASE + 0x106438)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。 */
+#define SRE_POE_VCPU_GRP_WORD7_GET_0_REG           (SRE_POE_BASE + 0x10601C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。
+以下0x116000~0x3ffffc地址保留。以下是配置寄存器 */
+#define SRE_POE_VCPU_GRP_WORD7_GET_1_REG           (SRE_POE_BASE + 0x10603C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。
+以下0x116000~0x3ffffc地址保留。以下是配置寄存器 */
+#define SRE_POE_VCPU_GRP_WORD7_GET_2_REG           (SRE_POE_BASE + 0x10641C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。
+以下0x116000~0x3ffffc地址保留。以下是配置寄存器 */
+#define SRE_POE_VCPU_GRP_WORD7_GET_3_REG           (SRE_POE_BASE + 0x10643C)        /* POE模块中，CPU指定Group读取任务的GET_GROUP命令寄存器。
+以下0x116000~0x3ffffc地址保留。以下是配置寄存器 */
+#define SRE_POE_GRP_VCPU_MASK_0_REG                (SRE_POE_BASE + 0x400000)        /* POE模块逻辑CPU的Group掩码寄存器。 */
+#define SRE_POE_GRP_VCPU_MASK_1_REG                (SRE_POE_BASE + 0x400004)        /* POE模块逻辑CPU的Group掩码寄存器。 */
+#define SRE_POE_GRP_SEC_MASK_REG                   (SRE_POE_BASE + 0x400100)        /* POE模块SEC的Group掩码寄存器。 */
+#define SRE_POE_GRP_ROHCZ_MASK_REG                 (SRE_POE_BASE + 0x400104)        /* POE模块"ROHC中压缩功能"的Group掩码寄存器。 */
+#define SRE_POE_GRP_ROHCUZ_MASK_REG                (SRE_POE_BASE + 0x400108)        /* POE模块"ROHC中解压功能"的Group掩码寄存器。 */
+#define SRE_POE_GRP_SPPE_MASK_REG                  (SRE_POE_BASE + 0x40010C)        /* POE模块SPPE的Group掩码寄存器。 */
+#define SRE_POE_GRP_PDM_MASK_REG                   (SRE_POE_BASE + 0x400110)        /* POE模块PDM的Group掩码寄存器。 */
+#define SRE_POE_GRP_ULHDCP_MASK_REG                (SRE_POE_BASE + 0x40011C)        /* POE模块ULHDCP的Group掩码寄存器。 */
+#define SRE_POE_GRP_DLHDCP_MASK_REG                (SRE_POE_BASE + 0x400120)        /* POE模块DLHDCP的Group掩码寄存器。 */
+#define SRE_POE_GRP_ACC_MASK_0_REG                 (SRE_POE_BASE + 0x400124)        /* POE模块预留6个加速器ACC的Group掩码寄存器。
+以下0x40013C保留 */
+#define SRE_POE_GRP_ACC_MASK_1_REG                 (SRE_POE_BASE + 0x400128)        /* POE模块预留6个加速器ACC的Group掩码寄存器。
+以下0x40013C保留 */
+#define SRE_POE_GRP_BP_TH_0_REG                    (SRE_POE_BASE + 0x400140)        /* POE模块中Group_{0~31}反压水线配置寄存器。Group的包达到这个配置的水线值时反压所有模块，Group中不再接收任务添加。 */
+#define SRE_POE_GRP_BP_TH_1_REG                    (SRE_POE_BASE + 0x400144)        /* POE模块中Group_{0~31}反压水线配置寄存器。Group的包达到这个配置的水线值时反压所有模块，Group中不再接收任务添加。 */
+#define SRE_POE_SCH_SEL_CFG_REG                    (SRE_POE_BASE + 0x4001C0)        /* POE模块调度算法选择配置寄存器。 */
+#define SRE_POE_GRP_SCH_CFG_0_REG                  (SRE_POE_BASE + 0x4001C4)        /* 基带调度算法（先Group后QoS）时，每个Group选择的调度算法配置寄存器0。 */
+#define SRE_POE_GRP_SCH_CFG_1_REG                  (SRE_POE_BASE + 0x4001C8)        /* 基带调度算法（先Group后QoS）时，每个Group选择的调度算法配置寄存器1。 */
+#define SRE_POE_WRR_CFG_0_REG                      (SRE_POE_BASE + 0x4001CC)        /* 基带调度算法（先Group后QoS）时，POE模块对Group{0~31}进行PQ+WRR算法配置寄存器。
+主控调度算法时，POE进行PQ+WRR算法的配置寄存器。
+权重值配置为0时，不参与调度，不会有任务调度出来，
+注意：主控调度算法（先QoS后Group）时，QoS0在调度时，无论选择PQ还是WRR，对应的权重必须配置为非零（WRR_CFG{0}寄存器的q0_weight域配置为非零），QoS0中的任务才能调度出，不然QoS0中的任务无法调度出来。
+以下地址0x4002CC保留 */
+#define SRE_POE_WRR_CFG_1_REG                      (SRE_POE_BASE + 0x4001D0)        /* 基带调度算法（先Group后QoS）时，POE模块对Group{0~31}进行PQ+WRR算法配置寄存器。
+主控调度算法时，POE进行PQ+WRR算法的配置寄存器。
+权重值配置为0时，不参与调度，不会有任务调度出来，
+注意：主控调度算法（先QoS后Group）时，QoS0在调度时，无论选择PQ还是WRR，对应的权重必须配置为非零（WRR_CFG{0}寄存器的q0_weight域配置为非零），QoS0中的任务才能调度出，不然QoS0中的任务无法调度出来。
+以下地址0x4002CC保留 */
+#define SRE_POE_DDR_VMID_CFG_REG                   (SRE_POE_BASE + 0x4002D0)        /* POE的任务溢出到那个VM的配置寄存器
+ */
+#define SRE_POE_TM_VMID_CFG_REG                    (SRE_POE_BASE + 0x4002D4)        /* POE推送任务到TM的VM的配置寄存器，TM在哪个VM的空间
+ */
+#define SRE_POE_TM_ADDR_CFG_REG                    (SRE_POE_BASE + 0x4002D8)        /* POE推送任务到TM的地址配置寄存器，添加到TM的地址
+ */
+#define SRE_POE_AQM_VMID_CFG_REG                   (SRE_POE_BASE + 0x4002DC)        /* POE推送任务到AQM的VM的配置寄存器，AQM在哪个VM的空间
+ */
+#define SRE_POE_AQM_ADDR_CFG_REG                   (SRE_POE_BASE + 0x4002E0)        /* POE推送任务到AQM的地址配置寄存器，添加到AQM的地址
+ */
+#define SRE_POE_MPE_VMID_CFG_REG                   (SRE_POE_BASE + 0x4002E4)        /* POE推送任务到MPE的VM的配置寄存器，MPE在哪个VM的空间
+ */
+#define SRE_POE_MPE_ADDR_CFG_REG                   (SRE_POE_BASE + 0x4002E8)        /* POE推送任务到MPE的地址配置寄存器，添加到MPE的地址
+ */
+#define SRE_POE_POE_VMID_CFG_REG                   (SRE_POE_BASE + 0x4002EC)        /* POE推送任务到POE的VM的配置寄存器，POE在哪个VM的空间
+ */
+#define SRE_POE_POE_ADDR_CFG_REG                   (SRE_POE_BASE + 0x4002F0)        /* POE推送任务到POE的地址配置寄存器，添加到POE的地址
+ */
+#define SRE_POE_SEND_TRY_CNT_REG                   (SRE_POE_BASE + 0x4002F4)        /* POE模块推送任务到TM/AQM/MPE/POE上报中断的最大重试次数 */
+#define SRE_POE_SEND_TRY_INTER_REG                 (SRE_POE_BASE + 0x4002F8)        /* POE模块添加任务到TM/AQM/MPE/POE时，添加失败，再次重试添加的间隔时间，以POE的时钟周期为单位。（时钟周期750M） */
+#define SRE_POE_CPU_EVENT_MODE_CFG_REG             (SRE_POE_BASE + 0x4002FC)        /* POE模块将CPU从睡眠状态唤醒的方式选择。 */
+#define SRE_POE_CPU_CORE_EVENT_CFG_0_REG           (SRE_POE_BASE + 0x400300)        /* POE模块根据CPU配置发送触发信号event将CPU从睡眠状态唤醒。
+ */
+#define SRE_POE_CPU_CORE_EVENT_CFG_1_REG           (SRE_POE_BASE + 0x400304)        /* POE模块根据CPU配置发送触发信号event将CPU从睡眠状态唤醒。
+ */
+#define SRE_POE_SEND_TM_OUT_CNT_CFG_REG            (SRE_POE_BASE + 0x400340)        /* POE模块将推送任务到TM的outstanding个数配置寄存器。最大配置为4 */
+#define SRE_POE_SEND_MPE_OUT_CNT_CFG_REG           (SRE_POE_BASE + 0x400344)        /* POE模块将推送任务到MPE的outstanding个数配置寄存器。最大配置为4 */
+#define SRE_POE_SEND_POE_OUT_CNT_CFG_REG           (SRE_POE_BASE + 0x400348)        /* POE模块将推送任务到POE的outstanding个数配置寄存器。最大配置为4
+以下0x40034C～0x4003D0保留 */
+#define SRE_POE_GRP_INT_CNT_CFG_0_REG              (SRE_POE_BASE + 0x4003D4)        /* POE模块Input-queue中断水线配置寄存器。当group{0~31}中的任务个数达到这个设定值的时候，是加速器处理的Group就置有效逻辑线。是CPU处理的Group就上报中断。 */
+#define SRE_POE_GRP_INT_CNT_CFG_1_REG              (SRE_POE_BASE + 0x4003D8)        /* POE模块Input-queue中断水线配置寄存器。当group{0~31}中的任务个数达到这个设定值的时候，是加速器处理的Group就置有效逻辑线。是CPU处理的Group就上报中断。 */
+#define SRE_POE_INPUT_TMOUT_CFG_REG                (SRE_POE_BASE + 0x400454)        /* POE模块任务缓存队列（input_queue）中，超时配置寄存器，超时上报中断。 */
+#define SRE_POE_INFLIGHT_TMOUT_CFG_REG             (SRE_POE_BASE + 0x400458)        /* POE模块in-flight保序队列超时配置寄存器，超时上报中断。 */
+#define SRE_POE_DESCH_TMOUT_CFG_REG                (SRE_POE_BASE + 0x40045C)        /* POE模块解绑定任务缓存队列超时配置寄存器，超时上报中断。 */
+#define SRE_POE_INIT_RAM_START_REG                 (SRE_POE_BASE + 0x400460)        /* POE模块的初始化寄存器。对POE内部RAM进行初始化 */
+#define SRE_POE_INIT_RAM_DONE_REG                  (SRE_POE_BASE + 0x400464)        /* POE模块的初始化结束状态寄存器。 */
+#define SRE_POE_GRP_ORDER_EN_0_REG                 (SRE_POE_BASE + 0x400468)        /* POE模块Group是否保序配置寄存器。以下0x4004E8~0x400570保留 */
+#define SRE_POE_GRP_ORDER_EN_1_REG                 (SRE_POE_BASE + 0x40046C)        /* POE模块Group是否保序配置寄存器。以下0x4004E8~0x400570保留 */
+#define SRE_POE_Q_BP_TH_ST_0_REG                   (SRE_POE_BASE + 0x400574)        /* POE模块中queue高低水线中断状态寄存器。
+ */
+#define SRE_POE_Q_BP_TH_ST_1_REG                   (SRE_POE_BASE + 0x400578)        /* POE模块中queue高低水线中断状态寄存器。
+ */
+#define SRE_POE_Q_BP_PARI_ERR_Q_REG                (SRE_POE_BASE + 0x400594)        /* POE模块中Q_BP_TH反压水线的RAM出现奇偶校验错误时，记录错误队列号寄存器。
+以下0x400598~0x4006f8保留 */
+#define SRE_POE_CORE_MSG_BIT_REG                   (SRE_POE_BASE + 0x4006FC)        /* CPU操作POE的位宽配置寄存器。以128bit还是以256bit操作，不能混合操作。
+ */
+#define SRE_POE_OVER_BASE_ADDR_GRP_0_REG           (SRE_POE_BASE + 0x400700)        /* POE模块中group溢出基地址配置寄存器。 */
+#define SRE_POE_OVER_BASE_ADDR_GRP_1_REG           (SRE_POE_BASE + 0x400704)        /* POE模块中group溢出基地址配置寄存器。 */
+#define SRE_POE_OVER_LEN_GRP_0_REG                 (SRE_POE_BASE + 0x400780)        /* POE模块中group溢出空间大小配置寄存器。 */
+#define SRE_POE_OVER_LEN_GRP_1_REG                 (SRE_POE_BASE + 0x400784)        /* POE模块中group溢出空间大小配置寄存器。 */
+#define SRE_POE_OVER_DDR_INIT_START_REG            (SRE_POE_BASE + 0x400800)        /* POE模块中group溢出基地址的初始化配置寄存器。 */
+#define SRE_POE_OVER_DDR_INIT_DONE_REG             (SRE_POE_BASE + 0x400804)        /* POE模块中group溢出基地址配置寄存器。
+以下0x400808~4008F4保留 */
+#define SRE_POE_INIT_BP_TH_START_REG               (SRE_POE_BASE + 0x4008F8)        /* POE模块的初始化寄存器。对POE内部Q_BP_TH的RAM进行初始化 */
+#define SRE_POE_INIT_BP_TH_DONE_REG                (SRE_POE_BASE + 0x4008FC)        /* POE模块的初始化结束状态寄存器。查看Q_BP_TH的RAM是否初始化完成 */
+#define SRE_POE_Q_BP_TH_H_0_REG                    (SRE_POE_BASE + 0x400900)        /* POE模块中queue中断高水线。Memory实现。
+此寄存器配置前必须先配置INIT_RAM_START初始化内部RAM。不能同时读写此寄存器，如果出现同时读写，写优先，读数据反馈全零。 */
+#define SRE_POE_Q_BP_TH_H_1_REG                    (SRE_POE_BASE + 0x400904)        /* POE模块中queue中断高水线。Memory实现。
+此寄存器配置前必须先配置INIT_RAM_START初始化内部RAM。不能同时读写此寄存器，如果出现同时读写，写优先，读数据反馈全零。 */
+#define SRE_POE_Q_BP_TH_L_0_REG                    (SRE_POE_BASE + 0x400D00)        /* POE模块中queue中断低水线。Memory实现。
+此寄存器配置前必须先配置INIT_RAM_START初始化内部RAM。不能同时读写此寄存器，如果出现同时读写，写优先，读数据反馈全零。
+ */
+#define SRE_POE_Q_BP_TH_L_1_REG                    (SRE_POE_BASE + 0x400D04)        /* POE模块中queue中断低水线。Memory实现。
+此寄存器配置前必须先配置INIT_RAM_START初始化内部RAM。不能同时读写此寄存器，如果出现同时读写，写优先，读数据反馈全零。
+ */
+#define SRE_POE_MEM_TIMING_CFG_REG                 (SRE_POE_BASE + 0x401100)        /* POE模块中Memory时序调整配置寄存器。
+ */
+#define SRE_POE_CORE_INT_ENABLE_0_REG              (SRE_POE_BASE + 0x401104)        /* POE模块Core{0~15}中断使能寄存器。中断使能后，中断状态才能上报到CPU。 */
+#define SRE_POE_CORE_INT_ENABLE_1_REG              (SRE_POE_BASE + 0x401108)        /* POE模块Core{0~15}中断使能寄存器。中断使能后，中断状态才能上报到CPU。 */
+#define SRE_POE_CORE_INTS_0_REG                    (SRE_POE_BASE + 0x401204)        /* POE模块Core{0~15}中断状态寄存器，中断状态上报给Core */
+#define SRE_POE_CORE_INTS_1_REG                    (SRE_POE_BASE + 0x401208)        /* POE模块Core{0~15}中断状态寄存器，中断状态上报给Core */
+#define SRE_POE_COMMON_INT_ENABLE_REG              (SRE_POE_BASE + 0x401304)        /* POE模块的公共中断使能寄存器。中断使能后，中断状态才能上报CPU。 */
+#define SRE_POE_COMMON_INTS_REG                    (SRE_POE_BASE + 0x401308)        /* POE模块的公共中断状态寄存器。
+ */
+#define SRE_POE_CORE_INTS_INFO_0_REG               (SRE_POE_BASE + 0x40130C)        /* POE模块Core{0~15}中断状态信息寄存器，记录中断对应的状态信息 */
+#define SRE_POE_CORE_INTS_INFO_1_REG               (SRE_POE_BASE + 0x401310)        /* POE模块Core{0~15}中断状态信息寄存器，记录中断对应的状态信息 */
+#define SRE_POE_COMMON_INTS_INFO_1_REG             (SRE_POE_BASE + 0x40140C)        /* POE模块公共中断状态信息寄存器，记录中断对应的状态信息，任务buffer指针。
+ */
+#define SRE_POE_COMMON_INTS_INFO_2_REG             (SRE_POE_BASE + 0x401410)        /* POE模块公共中断状态信息寄存器，记录中断对应的状态信息，任务在保序队列中的信息。
+以下0x401414~41FFFC保留；以下是模块状态寄存器 */
+#define SRE_POE_VCPU_INF0_0_REG                    (SRE_POE_BASE + 0x420000)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器0。 */
+#define SRE_POE_VCPU_INF0_1_REG                    (SRE_POE_BASE + 0x420008)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器0。 */
+#define SRE_POE_VCPU_INF1_0_REG                    (SRE_POE_BASE + 0x420004)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器1。 */
+#define SRE_POE_VCPU_INF1_1_REG                    (SRE_POE_BASE + 0x42000C)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器1。 */
+#define SRE_POE_GROUP_CNT_0_REG                    (SRE_POE_BASE + 0x420200)        /* GROUP_{0~31}中的任务个数（包括8个QoS队列）寄存器 */
+#define SRE_POE_GROUP_CNT_1_REG                    (SRE_POE_BASE + 0x420204)        /* GROUP_{0~31}中的任务个数（包括8个QoS队列）寄存器 */
+#define SRE_POE_RC_EN_CFG_REG                      (SRE_POE_BASE + 0x420280)        /* POE模块中读清寄存器的使能配置寄存器。在使能时，读“读清寄存器”时才清零。 */
+#define SRE_POE_ADD_FAIL_CNT_REG                   (SRE_POE_BASE + 0x420284)        /* POE模块中在ADD操作添加失败统计寄存器。 */
+#define SRE_POE_ADD_OK_CNT_REG                     (SRE_POE_BASE + 0x420288)        /* POE模块中在ADD操作添加成功统计寄存器。 */
+#define SRE_POE_INFLIGHT_FREE_ST_REG               (SRE_POE_BASE + 0x42028C)        /* POE模块中in-flight中的状态寄存器。512个Entry还有多少个没使用，512个保序队列还有多少个没使用。 */
+#define SRE_POE_VCPU_ADD_ST_0_REG                  (SRE_POE_BASE + 0x420290)        /* 64个逻辑CPU向POE添加任务的成功/失败状态寄存器
+ */
+#define SRE_POE_VCPU_ADD_ST_1_REG                  (SRE_POE_BASE + 0x420294)        /* 64个逻辑CPU向POE添加任务的成功/失败状态寄存器
+ */
+#define SRE_POE_INPUT_Q_GRP_EMP_REG                (SRE_POE_BASE + 0x420390)        /* POE模块中INPUT_Q模块中group的空信号。 */
+#define SRE_POE_DES_FIFO_GRP_EMP_REG               (SRE_POE_BASE + 0x420394)        /* POE模块中DESCHEDULE FIFO模块中group的空信号。 */
+#define SRE_POE_OV_Q_GRP_EMP_REG                   (SRE_POE_BASE + 0x420398)        /* POE模块中OV_Qbuffer中group的空信号。 */
+#define SRE_POE_DDR_GRP_EMP_REG                    (SRE_POE_BASE + 0x42039C)        /* POE模块中DDR溢出空间模块中group的空信号。 */
+#define SRE_POE_VCPU_INF2_0_REG                    (SRE_POE_BASE + 0x4203A0)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器2，buffer地址信息。
+以下0x4204A0~0x440000保留 */
+#define SRE_POE_VCPU_INF2_1_REG                    (SRE_POE_BASE + 0x4203A4)        /* POE模块中逻辑CPU_{0~63}的当前绑定信息寄存器2，buffer地址信息。
+以下0x4204A0~0x440000保留 */
+#define SRE_POE_DEBUG_CMD_FIFO_CNT_REG             (SRE_POE_BASE + 0x440000)        /* POE模块的CMD_FIFO中中还有多少个保序命令未执行。 */
+#define SRE_POE_DEBUG_SEND_TM_REG                  (SRE_POE_BASE + 0x440004)        /* POE模块的推送任务到TM的debug寄存器。 */
+#define SRE_POE_DEBUG_SEND_AQM_REG                 (SRE_POE_BASE + 0x440008)        /* POE模块的推送任务到AQM的debug寄存器。 */
+#define SRE_POE_DEBUG_SEND_MPE_REG                 (SRE_POE_BASE + 0x44000C)        /* POE模块的推送任务到MPE的debug寄存器。 */
+#define SRE_POE_DEBUG_SEND_POE_REG                 (SRE_POE_BASE + 0x440010)        /* POE模块的推送任务到POE的debug寄存器。 */
+#define SRE_POE_DEBUG_SLAVE_ERR_EN_REG             (SRE_POE_BASE + 0x440014)        /* POE模块的slave支持加速器写outstanding反馈机制的使能信号。 */
+#define SRE_POE_DEBUG_SLAVE_ERR_SIG_REG            (SRE_POE_BASE + 0x440018)        /* POE模块的slave支持加速器写outstanding反馈机制的观测信号信号。 */
+#define SRE_POE_DEBUG_MST_RD_EN_REG                (SRE_POE_BASE + 0x44001C)        /* POE模块的master读通道统计延时、计数的使能寄存器。共8个通道，各通道单独使能。 */
+#define SRE_POE_DEBUG_MST_RD_LAY_AVG_REG           (SRE_POE_BASE + 0x440020)        /* POE模块的master读通道的平均延时寄存器 */
+#define SRE_POE_DEBUG_MST_RD_LAY_MAX_REG           (SRE_POE_BASE + 0x440024)        /* POE模块的master读通道的最大延时统计寄存器 */
+#define SRE_POE_DEBUG_MST_RD_LAY_CLR_REG           (SRE_POE_BASE + 0x440028)        /* POE模块的master读通道延时清零寄存器，清除DEBUG_MST_WR_LAY_AVG和DEBUG_MST_WR_LAY_MAX寄存器值 */
+#define SRE_POE_DEBUG_MST_RD_ACC_CNT_REG           (SRE_POE_BASE + 0x44002C)        /* POE模块的master读通道读操作统计寄存器 */
+#define SRE_POE_DEBUG_MST_RD_ACC_CLR_REG           (SRE_POE_BASE + 0x440030)        /* POE模块的master读通道操作清零寄存器，清除DEBUG_MST_WR_ACC_CNT寄存器 */
+#define SRE_POE_DEBUG_MST_RD_OTD_1_REG             (SRE_POE_BASE + 0x440034)        /* POE模块的master读通道当前发出去的outstanding个数统计寄存器，低32bit */
+#define SRE_POE_DEBUG_MST_RD_OTD_2_REG             (SRE_POE_BASE + 0x440038)        /* POE模块的master读通道当前发出去的outstanding个数统计寄存器，高32bit */
+#define SRE_POE_DEBUG_MST_WR_EN_REG                (SRE_POE_BASE + 0x44003C)        /* POE模块的master写通道统计延时、计数的使能寄存器。共8个通道，各通道单独使能。 */
+#define SRE_POE_DEBUG_MST_WR_LAY_AVG_REG           (SRE_POE_BASE + 0x440040)        /* POE模块的master写通道的平均延时寄存器 */
+#define SRE_POE_DEBUG_MST_WR_LAY_MAX_REG           (SRE_POE_BASE + 0x440044)        /* POE模块的master写通道的最大延时统计寄存器 */
+#define SRE_POE_DEBUG_MST_WR_LAY_CLR_REG           (SRE_POE_BASE + 0x440048)        /* POE模块的master写通道延时清零寄存器，清除DEBUG_MST_WR_LAY_AVG和DEBUG_MST_WR_LAY_MAX寄存器值 */
+#define SRE_POE_DEBUG_MST_WR_ACC_CNT_REG           (SRE_POE_BASE + 0x44004C)        /* POE模块的master写通道写操作统计寄存器 */
+#define SRE_POE_DEBUG_MST_WR_ACC_CLR_REG           (SRE_POE_BASE + 0x440050)        /* POE模块的master写通道操作清零寄存器，清除DEBUG_MST_WR_ACC_CNT寄存器 */
+#define SRE_POE_DEBUG_MST_WR_OTD_1_REG             (SRE_POE_BASE + 0x440054)        /* POE模块的master写通道当前发出去的outstanding个数统计寄存器，低32bit */
+#define SRE_POE_DEBUG_MST_WR_OTD_2_REG             (SRE_POE_BASE + 0x440058)        /* POE模块的master写通道当前发出去的outstanding个数统计寄存器，高32bit */
+#define SRE_POE_DEBUG_INFLI_ST_REG                 (SRE_POE_BASE + 0x44005C)        /* POE模块的保序模块处理状态，表示保序模块中有命令处理时间超过20个POE周期 */
+#define SRE_POE_DEBUG_INFLI_ST_CNT_REG             (SRE_POE_BASE + 0x440060)        /* POE模块的保序模块处理状态，表示保序模块中处理时间超过20个POE周期的保序命令个数 */
+#define SRE_POE_DEBUG_ADD_CNT_REG                  (SRE_POE_BASE + 0x440064)        /* 添加任务到POE的个数 */
+#define SRE_POE_DEBUG_GET_CNT_REG                  (SRE_POE_BASE + 0x440068)        /* 从POE模块读取任务的个数 */
+#define SRE_POE_DEBUG_OVFL_OUT_CNT_REG             (SRE_POE_BASE + 0x44006C)        /* 溢出到DDR的outstanding个数，一个操作128bit的burst4，只能配置2/3/4 */
+#define SRE_POE_DEBUG_RDBK_OUT_CNT_REG             (SRE_POE_BASE + 0x440070)        /* 从DDR或OV_FIFO回读的outstanding个数，一个操作128bit的burst4，只能配置2/3/4 */
+#define SRE_POE_SUHAI_RSV_1_REG                    (SRE_POE_BASE + 0x440074)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_2_REG                    (SRE_POE_BASE + 0x440078)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_3_REG                    (SRE_POE_BASE + 0x44007C)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_4_REG                    (SRE_POE_BASE + 0x440080)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_5_REG                    (SRE_POE_BASE + 0x440084)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_6_REG                    (SRE_POE_BASE + 0x440088)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_7_REG                    (SRE_POE_BASE + 0x44008C)        /* 预留寄存器 */
+#define SRE_POE_SUHAI_RSV_8_REG                    (SRE_POE_BASE + 0x440090)        /* 预留寄存器 */
+
+/* pou 模块寄存器基地址 */
+#define MC_POU_BASE                     (0x100d0000 + 0x80000000)
+
+/******************************************************************************/
+/*                      PhosphorV600 pou 寄存器定义                           */
+/******************************************************************************/
+#define MC_POU_GLOBAL_REG           (MC_POU_BASE + 0x0)   /* POU全局相关寄存器。 */
+#define MC_POU_INT_STATUS_REG       (MC_POU_BASE + 0x8)   /* POU中断状态寄存器。 */
+#define MC_POU_INT_ENA_REG          (MC_POU_BASE + 0xC)   /* POU中断使能寄存器。 */
+#define MC_POU_INT_MASK_REG         (MC_POU_BASE + 0x10)  /* POU中断清除寄存器。 */
+#define MC_POU_QOV_ID_REG           (MC_POU_BASE + 0x20)  /* POU输出队列溢出ID。 */
+#define MC_POU_QERR_ID_REG          (MC_POU_BASE + 0x24)  /* POU总线数据访问错误输出队列寄存器。 */
+#define MC_POU_ATOMIC_REG           (MC_POU_BASE + 0x30)  /* POU原子操作寄存器。 */
+#define MC_POU_OQ_EN0_REG           (MC_POU_BASE + 0x40)  /* POU输出队列使能寄存器0。 */
+#define MC_POU_OQ_EN1_REG           (MC_POU_BASE + 0x44)  /* POU输出队列使能寄存器1。 */
+#define MC_POU_TP_DIS_STAT_REG      (MC_POU_BASE + 0x48)  /* POU 端口禁止状态寄存器*/
+#define MC_POU_TP_DIS_STAT_CLR_REG  (MC_POU_BASE + 0x4C)  /* POU 端口禁止状清除寄存器*/
+#define MC_POU_GMAC0_ADDR_REG       (MC_POU_BASE + 0x50)  /* POU向GMAC0写地址寄存器。 */
+#define MC_POU_GMAC1_ADDR_REG       (MC_POU_BASE + 0x54)  /* POU向GMAC1写地址寄存器。 */
+#define MC_POU_GMAC2_ADDR_REG       (MC_POU_BASE + 0x58)  /* POU向GMAC2写地址寄存器。 */
+#define MC_POU_GMAC3_ADDR_REG       (MC_POU_BASE + 0x5C)  /* POU向GMAC3写地址寄存器。 */
+#define MC_POU_GMAC4_ADDR_REG       (MC_POU_BASE + 0x60)  /* POU向GMAC4写地址寄存器。 */
+#define MC_POU_GMAC5_ADDR_REG       (MC_POU_BASE + 0x64)  /* POU向GMAC5写地址寄存器。 */
+#define MC_POU_GMAC6_ADDR_REG       (MC_POU_BASE + 0x68)  /* POU向GMAC6写地址寄存器。 */
+#define MC_POU_GMAC7_ADDR_REG       (MC_POU_BASE + 0x6C)  /* POU向GMAC7写地址寄存器。 */
+#define MC_POU_TP_SHAPING_EN_REG    (MC_POU_BASE + 0x80)  /* POU物理端口流量整形使能寄存器。 */
+#define MC_POU_DEBUG0_REG           (MC_POU_BASE + 0x90)  /* POU调试寄存器0。 */
+#define MC_POU_DEBUG1_REG           (MC_POU_BASE + 0x94)  /* POU调试寄存器1。 */
+#define MC_POU_DEBUG2_REG           (MC_POU_BASE + 0x98)  /* POU调试寄存器2。 */
+#define MC_POU_DEBUG3_REG           (MC_POU_BASE + 0x9C)  /* POU调试寄存器3。 */
+#define MC_POU_TP_ST_REG            (MC_POU_BASE + 0xA0)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_0_REG        (MC_POU_BASE + 0xB0)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_1_REG        (MC_POU_BASE + 0xB8)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_2_REG        (MC_POU_BASE + 0xC0)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_3_REG        (MC_POU_BASE + 0xC8)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_4_REG        (MC_POU_BASE + 0xD0)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_5_REG        (MC_POU_BASE + 0xD8)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_6_REG        (MC_POU_BASE + 0xE0)  /* POU调试寄存器3。 */
+#define MC_POU_TP_DEEP_7_REG        (MC_POU_BASE + 0xE8)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_0_REG         (MC_POU_BASE + 0xB4)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_1_REG         (MC_POU_BASE + 0xBC)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_2_REG         (MC_POU_BASE + 0xC4)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_3_REG         (MC_POU_BASE + 0xCC)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_4_REG         (MC_POU_BASE + 0xD4)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_5_REG         (MC_POU_BASE + 0xDC)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_6_REG         (MC_POU_BASE + 0xE4)  /* POU调试寄存器3。 */
+#define MC_POU_TP_CNT_7_REG         (MC_POU_BASE + 0xEC)  /* POU调试寄存器3。 */
+#define MC_POU_TP_RATE0_0_REG  (MC_POU_BASE + 0x100)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_1_REG  (MC_POU_BASE + 0x110)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_2_REG  (MC_POU_BASE + 0x120)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_3_REG  (MC_POU_BASE + 0x130)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_4_REG  (MC_POU_BASE + 0x140)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_5_REG  (MC_POU_BASE + 0x150)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_6_REG  (MC_POU_BASE + 0x160)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE0_7_REG  (MC_POU_BASE + 0x170)  /* POU物理端口的速度配置寄存器0。 */
+#define MC_POU_TP_RATE1_0_REG  (MC_POU_BASE + 0x104)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_1_REG  (MC_POU_BASE + 0x114)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_2_REG  (MC_POU_BASE + 0x124)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_3_REG  (MC_POU_BASE + 0x134)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_4_REG  (MC_POU_BASE + 0x144)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_5_REG  (MC_POU_BASE + 0x154)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_6_REG  (MC_POU_BASE + 0x164)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_RATE1_7_REG  (MC_POU_BASE + 0x174)  /* POU物理端口的速度配置寄存器1。 */
+#define MC_POU_TP_LIMIT_0_REG  (MC_POU_BASE + 0x108)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_1_REG  (MC_POU_BASE + 0x118)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_2_REG  (MC_POU_BASE + 0x128)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_3_REG  (MC_POU_BASE + 0x138)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_4_REG  (MC_POU_BASE + 0x148)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_5_REG  (MC_POU_BASE + 0x158)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_6_REG  (MC_POU_BASE + 0x168)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_TP_LIMIT_7_REG  (MC_POU_BASE + 0x178)  /* POU物理端口的速度限制寄存器1。 */
+#define MC_POU_OQ_SET_0_REG  (MC_POU_BASE + 0x200)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_1_REG  (MC_POU_BASE + 0x204)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_2_REG  (MC_POU_BASE + 0x208)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_3_REG  (MC_POU_BASE + 0x20C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_4_REG  (MC_POU_BASE + 0x210)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_5_REG  (MC_POU_BASE + 0x214)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_6_REG  (MC_POU_BASE + 0x218)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_7_REG  (MC_POU_BASE + 0x21C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_8_REG  (MC_POU_BASE + 0x220)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_9_REG  (MC_POU_BASE + 0x224)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_10_REG  (MC_POU_BASE + 0x228)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_11_REG  (MC_POU_BASE + 0x22C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_12_REG  (MC_POU_BASE + 0x230)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_13_REG  (MC_POU_BASE + 0x234)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_14_REG  (MC_POU_BASE + 0x238)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_15_REG  (MC_POU_BASE + 0x23C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_16_REG  (MC_POU_BASE + 0x240)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_17_REG  (MC_POU_BASE + 0x244)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_18_REG  (MC_POU_BASE + 0x248)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_19_REG  (MC_POU_BASE + 0x24C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_20_REG  (MC_POU_BASE + 0x250)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_21_REG  (MC_POU_BASE + 0x254)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_22_REG  (MC_POU_BASE + 0x258)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_23_REG  (MC_POU_BASE + 0x25C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_24_REG  (MC_POU_BASE + 0x260)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_25_REG  (MC_POU_BASE + 0x264)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_26_REG  (MC_POU_BASE + 0x268)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_27_REG  (MC_POU_BASE + 0x26C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_28_REG  (MC_POU_BASE + 0x270)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_29_REG  (MC_POU_BASE + 0x274)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_30_REG  (MC_POU_BASE + 0x278)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_31_REG  (MC_POU_BASE + 0x27C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_32_REG  (MC_POU_BASE + 0x280)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_33_REG  (MC_POU_BASE + 0x284)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_34_REG  (MC_POU_BASE + 0x288)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_35_REG  (MC_POU_BASE + 0x28C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_36_REG  (MC_POU_BASE + 0x290)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_37_REG  (MC_POU_BASE + 0x294)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_38_REG  (MC_POU_BASE + 0x298)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_39_REG  (MC_POU_BASE + 0x29C)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_40_REG  (MC_POU_BASE + 0x2A0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_41_REG  (MC_POU_BASE + 0x2A4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_42_REG  (MC_POU_BASE + 0x2A8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_43_REG  (MC_POU_BASE + 0x2AC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_44_REG  (MC_POU_BASE + 0x2B0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_45_REG  (MC_POU_BASE + 0x2B4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_46_REG  (MC_POU_BASE + 0x2B8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_47_REG  (MC_POU_BASE + 0x2BC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_48_REG  (MC_POU_BASE + 0x2C0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_49_REG  (MC_POU_BASE + 0x2C4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_50_REG  (MC_POU_BASE + 0x2C8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_51_REG  (MC_POU_BASE + 0x2CC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_52_REG  (MC_POU_BASE + 0x2D0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_53_REG  (MC_POU_BASE + 0x2D4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_54_REG  (MC_POU_BASE + 0x2D8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_55_REG  (MC_POU_BASE + 0x2DC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_56_REG  (MC_POU_BASE + 0x2E0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_57_REG  (MC_POU_BASE + 0x2E4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_58_REG  (MC_POU_BASE + 0x2E8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_59_REG  (MC_POU_BASE + 0x2EC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_60_REG  (MC_POU_BASE + 0x2F0)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_61_REG  (MC_POU_BASE + 0x2F4)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_62_REG  (MC_POU_BASE + 0x2F8)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_SET_63_REG  (MC_POU_BASE + 0x2FC)  /* POU输出队列基本设置寄存器。 */
+#define MC_POU_OQ_BASE_0_REG  (MC_POU_BASE + 0x300)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_1_REG  (MC_POU_BASE + 0x304)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_2_REG  (MC_POU_BASE + 0x308)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_3_REG  (MC_POU_BASE + 0x30C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_4_REG  (MC_POU_BASE + 0x310)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_5_REG  (MC_POU_BASE + 0x314)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_6_REG  (MC_POU_BASE + 0x318)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_7_REG  (MC_POU_BASE + 0x31C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_8_REG  (MC_POU_BASE + 0x320)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_9_REG  (MC_POU_BASE + 0x324)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_10_REG  (MC_POU_BASE + 0x328)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_11_REG  (MC_POU_BASE + 0x32C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_12_REG  (MC_POU_BASE + 0x330)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_13_REG  (MC_POU_BASE + 0x334)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_14_REG  (MC_POU_BASE + 0x338)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_15_REG  (MC_POU_BASE + 0x33C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_16_REG  (MC_POU_BASE + 0x340)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_17_REG  (MC_POU_BASE + 0x344)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_18_REG  (MC_POU_BASE + 0x348)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_19_REG  (MC_POU_BASE + 0x34C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_20_REG  (MC_POU_BASE + 0x350)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_21_REG  (MC_POU_BASE + 0x354)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_22_REG  (MC_POU_BASE + 0x358)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_23_REG  (MC_POU_BASE + 0x35C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_24_REG  (MC_POU_BASE + 0x360)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_25_REG  (MC_POU_BASE + 0x364)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_26_REG  (MC_POU_BASE + 0x368)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_27_REG  (MC_POU_BASE + 0x36C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_28_REG  (MC_POU_BASE + 0x370)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_29_REG  (MC_POU_BASE + 0x374)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_30_REG  (MC_POU_BASE + 0x378)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_31_REG  (MC_POU_BASE + 0x37C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_32_REG  (MC_POU_BASE + 0x380)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_33_REG  (MC_POU_BASE + 0x384)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_34_REG  (MC_POU_BASE + 0x388)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_35_REG  (MC_POU_BASE + 0x38C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_36_REG  (MC_POU_BASE + 0x390)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_37_REG  (MC_POU_BASE + 0x394)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_38_REG  (MC_POU_BASE + 0x398)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_39_REG  (MC_POU_BASE + 0x39C)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_40_REG  (MC_POU_BASE + 0x3A0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_41_REG  (MC_POU_BASE + 0x3A4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_42_REG  (MC_POU_BASE + 0x3A8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_43_REG  (MC_POU_BASE + 0x3AC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_44_REG  (MC_POU_BASE + 0x3B0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_45_REG  (MC_POU_BASE + 0x3B4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_46_REG  (MC_POU_BASE + 0x3B8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_47_REG  (MC_POU_BASE + 0x3BC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_48_REG  (MC_POU_BASE + 0x3C0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_49_REG  (MC_POU_BASE + 0x3C4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_50_REG  (MC_POU_BASE + 0x3C8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_51_REG  (MC_POU_BASE + 0x3CC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_52_REG  (MC_POU_BASE + 0x3D0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_53_REG  (MC_POU_BASE + 0x3D4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_54_REG  (MC_POU_BASE + 0x3D8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_55_REG  (MC_POU_BASE + 0x3DC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_56_REG  (MC_POU_BASE + 0x3E0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_57_REG  (MC_POU_BASE + 0x3E4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_58_REG  (MC_POU_BASE + 0x3E8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_59_REG  (MC_POU_BASE + 0x3EC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_60_REG  (MC_POU_BASE + 0x3F0)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_61_REG  (MC_POU_BASE + 0x3F4)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_62_REG  (MC_POU_BASE + 0x3F8)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_BASE_63_REG  (MC_POU_BASE + 0x3FC)  /* POU输出队列地址寄存器。 */
+#define MC_POU_OQ_DEEP_0_REG  (MC_POU_BASE + 0x400)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_1_REG  (MC_POU_BASE + 0x404)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_2_REG  (MC_POU_BASE + 0x408)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_3_REG  (MC_POU_BASE + 0x40C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_4_REG  (MC_POU_BASE + 0x410)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_5_REG  (MC_POU_BASE + 0x414)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_6_REG  (MC_POU_BASE + 0x418)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_7_REG  (MC_POU_BASE + 0x41C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_8_REG  (MC_POU_BASE + 0x420)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_9_REG  (MC_POU_BASE + 0x424)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_10_REG  (MC_POU_BASE + 0x428)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_11_REG  (MC_POU_BASE + 0x42C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_12_REG  (MC_POU_BASE + 0x430)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_13_REG  (MC_POU_BASE + 0x434)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_14_REG  (MC_POU_BASE + 0x438)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_15_REG  (MC_POU_BASE + 0x43C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_16_REG  (MC_POU_BASE + 0x440)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_17_REG  (MC_POU_BASE + 0x444)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_18_REG  (MC_POU_BASE + 0x448)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_19_REG  (MC_POU_BASE + 0x44C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_20_REG  (MC_POU_BASE + 0x450)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_21_REG  (MC_POU_BASE + 0x454)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_22_REG  (MC_POU_BASE + 0x458)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_23_REG  (MC_POU_BASE + 0x45C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_24_REG  (MC_POU_BASE + 0x460)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_25_REG  (MC_POU_BASE + 0x464)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_26_REG  (MC_POU_BASE + 0x468)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_27_REG  (MC_POU_BASE + 0x46C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_28_REG  (MC_POU_BASE + 0x470)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_29_REG  (MC_POU_BASE + 0x474)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_30_REG  (MC_POU_BASE + 0x478)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_31_REG  (MC_POU_BASE + 0x47C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_32_REG  (MC_POU_BASE + 0x480)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_33_REG  (MC_POU_BASE + 0x484)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_34_REG  (MC_POU_BASE + 0x488)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_35_REG  (MC_POU_BASE + 0x48C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_36_REG  (MC_POU_BASE + 0x490)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_37_REG  (MC_POU_BASE + 0x494)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_38_REG  (MC_POU_BASE + 0x498)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_39_REG  (MC_POU_BASE + 0x49C)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_40_REG  (MC_POU_BASE + 0x4A0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_41_REG  (MC_POU_BASE + 0x4A4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_42_REG  (MC_POU_BASE + 0x4A8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_43_REG  (MC_POU_BASE + 0x4AC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_44_REG  (MC_POU_BASE + 0x4B0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_45_REG  (MC_POU_BASE + 0x4B4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_46_REG  (MC_POU_BASE + 0x4B8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_47_REG  (MC_POU_BASE + 0x4BC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_48_REG  (MC_POU_BASE + 0x4C0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_49_REG  (MC_POU_BASE + 0x4C4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_50_REG  (MC_POU_BASE + 0x4C8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_51_REG  (MC_POU_BASE + 0x4CC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_52_REG  (MC_POU_BASE + 0x4D0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_53_REG  (MC_POU_BASE + 0x4D4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_54_REG  (MC_POU_BASE + 0x4D8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_55_REG  (MC_POU_BASE + 0x4DC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_56_REG  (MC_POU_BASE + 0x4E0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_57_REG  (MC_POU_BASE + 0x4E4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_58_REG  (MC_POU_BASE + 0x4E8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_59_REG  (MC_POU_BASE + 0x4EC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_60_REG  (MC_POU_BASE + 0x4F0)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_61_REG  (MC_POU_BASE + 0x4F4)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_62_REG  (MC_POU_BASE + 0x4F8)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_DEEP_63_REG  (MC_POU_BASE + 0x4FC)  /* POU输出队列DEEP设置寄存器。 */
+#define MC_POU_OQ_CNT_0_REG  (MC_POU_BASE + 0x500)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_1_REG  (MC_POU_BASE + 0x510)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_2_REG  (MC_POU_BASE + 0x520)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_3_REG  (MC_POU_BASE + 0x530)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_4_REG  (MC_POU_BASE + 0x540)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_5_REG  (MC_POU_BASE + 0x550)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_6_REG  (MC_POU_BASE + 0x560)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_7_REG  (MC_POU_BASE + 0x570)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_8_REG  (MC_POU_BASE + 0x580)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_9_REG  (MC_POU_BASE + 0x590)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_10_REG  (MC_POU_BASE + 0x5A0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_11_REG  (MC_POU_BASE + 0x5B0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_12_REG  (MC_POU_BASE + 0x5C0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_13_REG  (MC_POU_BASE + 0x5D0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_14_REG  (MC_POU_BASE + 0x5E0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_15_REG  (MC_POU_BASE + 0x5F0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_16_REG  (MC_POU_BASE + 0x600)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_17_REG  (MC_POU_BASE + 0x610)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_18_REG  (MC_POU_BASE + 0x620)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_19_REG  (MC_POU_BASE + 0x630)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_20_REG  (MC_POU_BASE + 0x640)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_21_REG  (MC_POU_BASE + 0x650)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_22_REG  (MC_POU_BASE + 0x660)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_23_REG  (MC_POU_BASE + 0x670)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_24_REG  (MC_POU_BASE + 0x680)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_25_REG  (MC_POU_BASE + 0x690)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_26_REG  (MC_POU_BASE + 0x6A0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_27_REG  (MC_POU_BASE + 0x6B0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_28_REG  (MC_POU_BASE + 0x6C0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_29_REG  (MC_POU_BASE + 0x6D0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_30_REG  (MC_POU_BASE + 0x6E0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_31_REG  (MC_POU_BASE + 0x6F0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_32_REG  (MC_POU_BASE + 0x700)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_33_REG  (MC_POU_BASE + 0x710)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_34_REG  (MC_POU_BASE + 0x720)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_35_REG  (MC_POU_BASE + 0x730)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_36_REG  (MC_POU_BASE + 0x740)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_37_REG  (MC_POU_BASE + 0x750)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_38_REG  (MC_POU_BASE + 0x760)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_39_REG  (MC_POU_BASE + 0x770)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_40_REG  (MC_POU_BASE + 0x780)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_41_REG  (MC_POU_BASE + 0x790)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_42_REG  (MC_POU_BASE + 0x7A0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_43_REG  (MC_POU_BASE + 0x7B0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_44_REG  (MC_POU_BASE + 0x7C0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_45_REG  (MC_POU_BASE + 0x7D0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_46_REG  (MC_POU_BASE + 0x7E0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_47_REG  (MC_POU_BASE + 0x7F0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_48_REG  (MC_POU_BASE + 0x800)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_49_REG  (MC_POU_BASE + 0x810)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_50_REG  (MC_POU_BASE + 0x820)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_51_REG  (MC_POU_BASE + 0x830)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_52_REG  (MC_POU_BASE + 0x840)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_53_REG  (MC_POU_BASE + 0x850)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_54_REG  (MC_POU_BASE + 0x860)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_55_REG  (MC_POU_BASE + 0x870)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_56_REG  (MC_POU_BASE + 0x880)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_57_REG  (MC_POU_BASE + 0x890)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_58_REG  (MC_POU_BASE + 0x8A0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_59_REG  (MC_POU_BASE + 0x8B0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_60_REG  (MC_POU_BASE + 0x8C0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_61_REG  (MC_POU_BASE + 0x8D0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_62_REG  (MC_POU_BASE + 0x8E0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT_63_REG  (MC_POU_BASE + 0x8F0)  /* POU输出队列COUNTER设置寄存器。 */
+#define MC_POU_OQ_CNT0_0_REG  (MC_POU_BASE + 0x504)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_1_REG  (MC_POU_BASE + 0x514)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_2_REG  (MC_POU_BASE + 0x524)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_3_REG  (MC_POU_BASE + 0x534)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_4_REG  (MC_POU_BASE + 0x544)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_5_REG  (MC_POU_BASE + 0x554)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_6_REG  (MC_POU_BASE + 0x564)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_7_REG  (MC_POU_BASE + 0x574)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_8_REG  (MC_POU_BASE + 0x584)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_9_REG  (MC_POU_BASE + 0x594)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_10_REG  (MC_POU_BASE + 0x5A4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_11_REG  (MC_POU_BASE + 0x5B4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_12_REG  (MC_POU_BASE + 0x5C4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_13_REG  (MC_POU_BASE + 0x5D4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_14_REG  (MC_POU_BASE + 0x5E4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_15_REG  (MC_POU_BASE + 0x5F4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_16_REG  (MC_POU_BASE + 0x604)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_17_REG  (MC_POU_BASE + 0x614)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_18_REG  (MC_POU_BASE + 0x624)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_19_REG  (MC_POU_BASE + 0x634)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_20_REG  (MC_POU_BASE + 0x644)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_21_REG  (MC_POU_BASE + 0x654)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_22_REG  (MC_POU_BASE + 0x664)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_23_REG  (MC_POU_BASE + 0x674)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_24_REG  (MC_POU_BASE + 0x684)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_25_REG  (MC_POU_BASE + 0x694)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_26_REG  (MC_POU_BASE + 0x6A4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_27_REG  (MC_POU_BASE + 0x6B4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_28_REG  (MC_POU_BASE + 0x6C4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_29_REG  (MC_POU_BASE + 0x6D4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_30_REG  (MC_POU_BASE + 0x6E4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_31_REG  (MC_POU_BASE + 0x6F4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_32_REG  (MC_POU_BASE + 0x704)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_33_REG  (MC_POU_BASE + 0x714)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_34_REG  (MC_POU_BASE + 0x724)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_35_REG  (MC_POU_BASE + 0x734)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_36_REG  (MC_POU_BASE + 0x744)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_37_REG  (MC_POU_BASE + 0x754)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_38_REG  (MC_POU_BASE + 0x764)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_39_REG  (MC_POU_BASE + 0x774)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_40_REG  (MC_POU_BASE + 0x784)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_41_REG  (MC_POU_BASE + 0x794)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_42_REG  (MC_POU_BASE + 0x7A4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_43_REG  (MC_POU_BASE + 0x7B4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_44_REG  (MC_POU_BASE + 0x7C4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_45_REG  (MC_POU_BASE + 0x7D4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_46_REG  (MC_POU_BASE + 0x7E4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_47_REG  (MC_POU_BASE + 0x7F4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_48_REG  (MC_POU_BASE + 0x804)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_49_REG  (MC_POU_BASE + 0x814)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_50_REG  (MC_POU_BASE + 0x824)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_51_REG  (MC_POU_BASE + 0x834)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_52_REG  (MC_POU_BASE + 0x844)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_53_REG  (MC_POU_BASE + 0x854)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_54_REG  (MC_POU_BASE + 0x864)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_55_REG  (MC_POU_BASE + 0x874)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_56_REG  (MC_POU_BASE + 0x884)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_57_REG  (MC_POU_BASE + 0x894)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_58_REG  (MC_POU_BASE + 0x8A4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_59_REG  (MC_POU_BASE + 0x8B4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_60_REG  (MC_POU_BASE + 0x8C4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_61_REG  (MC_POU_BASE + 0x8D4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_62_REG  (MC_POU_BASE + 0x8E4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT0_63_REG  (MC_POU_BASE + 0x8F4)  /* POU输出队列的发送数据包个数寄存器0。 */
+#define MC_POU_OQ_CNT1_0_REG  (MC_POU_BASE + 0x508)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_1_REG  (MC_POU_BASE + 0x518)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_2_REG  (MC_POU_BASE + 0x528)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_3_REG  (MC_POU_BASE + 0x538)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_4_REG  (MC_POU_BASE + 0x548)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_5_REG  (MC_POU_BASE + 0x558)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_6_REG  (MC_POU_BASE + 0x568)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_7_REG  (MC_POU_BASE + 0x578)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_8_REG  (MC_POU_BASE + 0x588)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_9_REG  (MC_POU_BASE + 0x598)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_10_REG  (MC_POU_BASE + 0x5A8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_11_REG  (MC_POU_BASE + 0x5B8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_12_REG  (MC_POU_BASE + 0x5C8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_13_REG  (MC_POU_BASE + 0x5D8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_14_REG  (MC_POU_BASE + 0x5E8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_15_REG  (MC_POU_BASE + 0x5F8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_16_REG  (MC_POU_BASE + 0x608)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_17_REG  (MC_POU_BASE + 0x618)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_18_REG  (MC_POU_BASE + 0x628)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_19_REG  (MC_POU_BASE + 0x638)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_20_REG  (MC_POU_BASE + 0x648)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_21_REG  (MC_POU_BASE + 0x658)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_22_REG  (MC_POU_BASE + 0x668)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_23_REG  (MC_POU_BASE + 0x678)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_24_REG  (MC_POU_BASE + 0x688)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_25_REG  (MC_POU_BASE + 0x698)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_26_REG  (MC_POU_BASE + 0x6A8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_27_REG  (MC_POU_BASE + 0x6B8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_28_REG  (MC_POU_BASE + 0x6C8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_29_REG  (MC_POU_BASE + 0x6D8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_30_REG  (MC_POU_BASE + 0x6E8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_31_REG  (MC_POU_BASE + 0x6F8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_32_REG  (MC_POU_BASE + 0x708)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_33_REG  (MC_POU_BASE + 0x718)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_34_REG  (MC_POU_BASE + 0x728)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_35_REG  (MC_POU_BASE + 0x738)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_36_REG  (MC_POU_BASE + 0x748)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_37_REG  (MC_POU_BASE + 0x758)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_38_REG  (MC_POU_BASE + 0x768)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_39_REG  (MC_POU_BASE + 0x778)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_40_REG  (MC_POU_BASE + 0x788)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_41_REG  (MC_POU_BASE + 0x798)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_42_REG  (MC_POU_BASE + 0x7A8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_43_REG  (MC_POU_BASE + 0x7B8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_44_REG  (MC_POU_BASE + 0x7C8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_45_REG  (MC_POU_BASE + 0x7D8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_46_REG  (MC_POU_BASE + 0x7E8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_47_REG  (MC_POU_BASE + 0x7F8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_48_REG  (MC_POU_BASE + 0x808)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_49_REG  (MC_POU_BASE + 0x818)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_50_REG  (MC_POU_BASE + 0x828)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_51_REG  (MC_POU_BASE + 0x838)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_52_REG  (MC_POU_BASE + 0x848)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_53_REG  (MC_POU_BASE + 0x858)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_54_REG  (MC_POU_BASE + 0x868)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_55_REG  (MC_POU_BASE + 0x878)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_56_REG  (MC_POU_BASE + 0x888)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_57_REG  (MC_POU_BASE + 0x898)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_58_REG  (MC_POU_BASE + 0x8A8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_59_REG  (MC_POU_BASE + 0x8B8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_60_REG  (MC_POU_BASE + 0x8C8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_61_REG  (MC_POU_BASE + 0x8D8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_62_REG  (MC_POU_BASE + 0x8E8)  /* POU输出队列的发送数据包个数寄存器1。 */
+#define MC_POU_OQ_CNT1_63_REG  (MC_POU_BASE + 0x8F8)  /* POU输出队列的发送数据包个数寄存器1。 */
+
+/* CRC 模块寄存器基地址 */
+#define SRE_CRC_BASE          				(SRE_SEC_REG_BASE + 0x50000)
+
+/******************************************************************************/
+/*                      P650 CRC 寄存器定义                                 */
+/******************************************************************************/
+#define SRE_CRC_VERSION_REG                (0x0)         /* CRC 版本寄存器。 */
+#define SRE_CRC_CFG_REG                    (0x4)         /* CRC全局配置寄存器。 */
+#define SRE_CRC_INT_EN_REG                 (0x8)         /* 中断使能寄存器 */
+#define SRE_CRC_INT_STS_REG                (0xC)         /* 中断状态寄存器 */
+#define SRE_CRC_PATTERN0_REG               (0x10)        /* CRC多项式向量配置0 */
+#define SRE_CRC_PATTERN1_REG               (0x14)        /* CRC多项式向量配置1 */
+#define SRE_CRC_PATTERN2_REG               (0x18)        /* CRC多项式向量配置2 */
+#define SRE_CRC_PATTERN3_REG               (0x1C)        /* CRC多项式向量配置3 */
+#define SRE_CRC_PATTERN4_REG               (0x20)        /* CRC多项式向量配置4 */
+#define SRE_CRC_PATTERN5_REG               (0x24)        /* CRC多项式向量配置5 */
+#define SRE_CRC_PATTERN6_REG               (0x28)        /* CRC多项式向量配置6 */
+#define SRE_CRC_PATTERN7_REG               (0x2C)        /* CRC多项式向量配置7 */
+#define SRE_CRC_INIT_VAL0_REG              (0x30)        /* CRC计算的初始值配置寄存器0 */
+#define SRE_CRC_INIT_VAL1_REG              (0x34)        /* CRC计算的初始值配置寄存器1 */
+#define SRE_CRC_INIT_VAL2_REG              (0x38)        /* CRC计算的初始值配置寄存器2 */
+#define SRE_CRC_INIT_VAL3_REG              (0x3C)        /* CRC计算的初始值配置寄存器3 */
+#define SRE_CRC_INIT_VAL4_REG              (0x40)        /* CRC计算的初始值配置寄存器4 */
+#define SRE_CRC_INIT_VAL5_REG              (0x44)        /* CRC计算的初始值配置寄存器5 */
+#define SRE_CRC_INIT_VAL6_REG              (0x48)        /* CRC计算的初始值配置寄存器6 */
+#define SRE_CRC_INIT_VAL7_REG              (0x4C)        /* CRC计算的初始值配置寄存器7 */
+#define SRE_CRC_START_ADDR0_REG            (0x50)        /* CRC计算的数据起始地址寄存器0 */
+#define SRE_CRC_START_ADDR1_REG            (0x54)        /* CRC计算的数据起始地址寄存器1 */
+#define SRE_CRC_START_ADDR2_REG            (0x58)        /* CRC计算的数据起始地址寄存器2 */
+#define SRE_CRC_START_ADDR3_REG            (0x5C)        /* CRC计算的数据起始地址寄存器3 */
+#define SRE_CRC_START_ADDR4_REG            (0x60)        /* CRC计算的数据起始地址寄存器4 */
+#define SRE_CRC_START_ADDR5_REG            (0x64)        /* CRC计算的数据起始地址寄存器5 */
+#define SRE_CRC_START_ADDR6_REG            (0x68)        /* CRC计算的数据起始地址寄存器6 */
+#define SRE_CRC_START_ADDR7_REG            (0x6C)        /* CRC计算的数据起始地址寄存器7 */
+#define SRE_CRC_START_LEN0_REG             (0x70)        /* CRC计算的数据长度寄存器0 */
+#define SRE_CRC_START_LEN1_REG             (0x74)        /* CRC计算的数据长度寄存器1 */
+#define SRE_CRC_START_LEN2_REG             (0x78)        /* CRC计算的数据长度寄存器2 */
+#define SRE_CRC_START_LEN3_REG             (0x7C)        /* CRC计算的数据长度寄存器3 */
+#define SRE_CRC_START_LEN4_REG             (0x80)        /* CRC计算的数据长度寄存器4 */
+#define SRE_CRC_START_LEN5_REG             (0x84)        /* CRC计算的数据长度寄存器5 */
+#define SRE_CRC_START_LEN6_REG             (0x88)        /* CRC计算的数据长度寄存器6 */
+#define SRE_CRC_START_LEN7_REG             (0x8C)        /* CRC计算的数据长度寄存器7 */
+#define SRE_CRC_RESULT0_REG                (0x90)        /* CRC计算结果寄存器0 */
+#define SRE_CRC_RESULT1_REG                (0x94)        /* CRC计算结果寄存器1 */
+#define SRE_CRC_RESULT2_REG                (0x98)        /* CRC计算结果寄存器2 */
+#define SRE_CRC_RESULT3_REG                (0x9C)        /* CRC计算结果寄存器3 */
+#define SRE_CRC_RESULT4_REG                (0xA0)        /* CRC计算结果寄存器4 */
+#define SRE_CRC_RESULT5_REG                (0xA4)        /* CRC计算结果寄存器5 */
+#define SRE_CRC_RESULT6_REG                (0xA8)        /* CRC计算结果寄存器6 */
+#define SRE_CRC_RESULT7_REG                (0xAC)        /* CRC计算结果寄存器7 */
+#define SRE_CRC_RES_LEN0_REG               (0xB0)        /* CRC该次计算总共计算长度统计寄存器0 */
+#define SRE_CRC_RES_LEN1_REG               (0xB4)        /* CRC该次计算总共计算长度统计寄存器1 */
+#define SRE_CRC_RES_LEN2_REG               (0xB8)        /* CRC该次计算总共计算长度统计寄存器2 */
+#define SRE_CRC_RES_LEN3_REG               (0xBC)        /* CRC该次计算总共计算长度统计寄存器3 */
+#define SRE_CRC_RES_LEN4_REG               (0xC0)        /* CRC该次计算总共计算长度统计寄存器4 */
+#define SRE_CRC_RES_LEN5_REG               (0xC4)        /* CRC该次计算总共计算长度统计寄存器5 */
+#define SRE_CRC_RES_LEN6_REG               (0xC8)        /* CRC该次计算总共计算长度统计寄存器6 */
+#define SRE_CRC_RES_LEN7_REG               (0xCC)        /* CRC该次计算总共计算长度统计寄存器7 */
+#define SRE_CRC_START_REG                  (0xD0)        /* CRC启动寄存器 */
+#define SRE_CRC_STS_REG                    (0xD4)        /* CRC状态寄存器 */
+#define SRE_CRC_DATA_MODE0_REG             (0xD8)        /* CRC数据接口模式寄存器0 */
+#define SRE_CRC_DATA_MODE1_REG             (0xDC)        /* CRC数据接口模式寄存器1 */
+#define SRE_CRC_DATA_MODE2_REG             (0xE0)        /* CRC数据接口模式寄存器2 */
+#define SRE_CRC_DATA_MODE3_REG             (0xE4)        /* CRC数据接口模式寄存器3 */
+#define SRE_CRC_DATA_MODE4_REG             (0xE8)        /* CRC数据接口模式寄存器4 */
+#define SRE_CRC_DATA_MODE5_REG             (0xEC)        /* CRC数据接口模式寄存器5 */
+#define SRE_CRC_DATA_MODE6_REG             (0xF0)        /* CRC数据接口模式寄存器6 */
+#define SRE_CRC_DATA_MODE7_REG             (0xF4)        /* CRC数据接口模式寄存器7 */
+#define SRE_CRC_AHBM_ADDRH_CH0_REG         (0x100)       /* CRC AHB Master接口channel0高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH1_REG         (0x104)       /* CRC AHB Master接口channel1高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH2_REG         (0x108)       /* CRC AHB Master接口channel2高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH3_REG         (0x10C)       /* CRC AHB Master接口channel3高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH4_REG         (0x110)       /* CRC AHB Master接口channel4高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH5_REG         (0x114)       /* CRC AHB Master接口channel5高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH6_REG         (0x118)       /* CRC AHB Master接口channel6高2位地址 */
+#define SRE_CRC_AHBM_ADDRH_CH7_REG         (0x11C)       /* CRC AHB Master接口channel7高2位地址 */
+#define SRE_CRC_WR_ADDR0_REG               (0x2000)      /* CRC Slave模式数据接口寄存器0 */
+#define SRE_CRC_WR_ADDR1_REG               (0x2400)      /* CRC Slave模式数据接口寄存器1 */
+#define SRE_CRC_WR_ADDR2_REG               (0x2800)      /* CRC Slave模式数据接口寄存器2 */
+#define SRE_CRC_WR_ADDR3_REG               (0x2C00)      /* CRC Slave模式数据接口寄存器3 */
+#define SRE_CRC_WR_ADDR4_REG               (0x3000)      /* CRC Slave模式数据接口寄存器4 */
+#define SRE_CRC_WR_ADDR5_REG               (0x3400)      /* CRC Slave模式数据接口寄存器5 */
+#define SRE_CRC_WR_ADDR6_REG               (0x3800)      /* CRC Slave模式数据接口寄存器6 */
+#define SRE_CRC_WR_ADDR7_REG               (0x3C00)      /* CRC Slave模式数据接口寄存器7 */
+
+
+/* DMAC 模块寄存器基地址 */
+#define SRE_DMAC_BASE_ADDR          (0xf00d2000)
+
+/******************************************************************************/
+/*                      Phosphor DMAC 寄存器定义                              */
+/******************************************************************************/
+#define SRE_DMAC_INT_1_REG                   (0x0)      	/* DMAC_INT_1为DMAC屏蔽后的中断状态寄存器1。 */
+#define SRE_DMAC_ITC_MASK_INT_1_REG          (0x4)      	/* DMAC_ITC_MASK_INT_1为DMAC传输完成中断屏蔽寄存器1。 */
+#define SRE_DMAC_IE_MASK_INT_1_REG           (0x8)      	/* DMAC_IE_MASK_INT_1为DMAC传输错误中断屏蔽寄存器1。 */
+#define SRE_DMAC_INT_TC_1_REG                (0xC)      	/* DMAC_INT_TC_1为DMAC传输完成中断状态寄存器1。 */
+#define SRE_DMAC_INT_ERR_1_REG               (0x10)     	/* DMAC_INT_ERR_1为DMAC传输错误中断状态寄存器1。 */
+#define SRE_DMAC_INT_2_REG                   (0x14)     	/* DMAC_INT_2为DMAC屏蔽后的中断状态寄存器2。 */
+#define SRE_DMAC_ITC_MASK_INT_2_REG          (0x18)     	/* DMAC_ITC_MASK_INT_2为DMAC传输完成中断屏蔽寄存器2。 */
+#define SRE_DMAC_IE_MASK_INT_2_REG           (0x1C)     	/* DMAC_IE_MASK_INT_2为DMAC传输错误中断屏蔽寄存器2。 */
+#define SRE_DMAC_INT_TC_2_REG                (0x20)     	/* DMAC_INT_TC_2为DMAC传输完成中断状态寄存器2。 */
+#define SRE_DMAC_INT_ERR_2_REG               (0x24)     	/* DMAC_INT_ERR_2为DMAC传输错误中断状态寄存器2。 */
+#define SRE_DMAC_INT_3_REG                   (0x28)     	/* DMAC_INT_3为DMAC屏蔽后的中断状态寄存器3。 */
+#define SRE_DMAC_ITC_MASK_INT_3_REG          (0x2C)     	/* DMAC_ITC_MASK_INT_3为DMAC传输完成中断屏蔽寄存器3。 */
+#define SRE_DMAC_IE_MASK_INT_3_REG           (0x30)     	/* DMAC_IE_MASK_INT_3为DMAC传输错误中断屏蔽寄存器3。 */
+#define SRE_DMAC_INT_TC_3_REG                (0x34)     	/* DMAC_INT_TC为DMAC传输完成中断状态寄存器3。 */
+#define SRE_DMAC_INT_ERR_3_REG               (0x38)     	/* DMAC_INT_ERR为DMAC传输错误中断状态寄存器3。 */
+#define SRE_DMAC_INT_TC_CLR_REG              (0x3C)     	/* DMAC_INT_TC_CLR为DMAC传输完成中断清除寄存器。 */
+#define SRE_DMAC_INT_ERR_CLR_REG             (0x40)     	/* DMAC_INT_ERR_CLR为DMAC传输错误中断清除寄存器。 */
+#define SRE_DMAC_INT_TC_RAW_REG              (0x44)     	/* DMAC_INT_TC_RAW为DMAC传输完成原始中断状态寄存器。 */
+#define SRE_DMAC_INT_ERR_RAW_REG             (0x48)     	/* DMAC_INT_ERR_RAW为DMAC传输错误原始中断状态寄存器。 */
+#define SRE_DMAC_EN_CH_STATUS_REG            (0x4C)     	/* DMAC_EN_CH_STATUS为DMAC通道使能状态寄存器。 */
+#define SRE_DMAC_BREQ_1_REG                  (0x50)     	/* DMAC_BREQ_1为DMAC通道突发传输请求寄存器1。 */
+#define SRE_DMAC_BREQ_2_REG                  (0x54)    	/* DMAC_BREQ_2为DMAC通道突发传输请求寄存器2。 */
+#define SRE_DMAC_SREQ_1_REG                  (0x58)     	/* DMAC_SREQ_1为DMAC通道单次传输请求寄存器1。 */
+#define SRE_DMAC_SREQ_2_REG                  (0x5C)     	/* DMAC_SREQ_2为DMAC通道单次传输请求寄存器2。 */
+#define SRE_DMAC_LBREQ_1_REG                 (0x60)     	/* DMAC_LBREQ_1为DMAC通道末次突发传输请求寄存器1。 */
+#define SRE_DMAC_LBREQ_2_REG                 (0x64)     	/* DMAC_LBREQ_2为DMAC通道末次突发传输请求寄存器2。 */
+#define SRE_DMAC_LSREQ_1_REG                 (0x68)     	/* DMAC_LSREQ_1为DMAC通道末次单次传输请求寄存器1。 */
+#define SRE_DMAC_LSREQ_2_REG                 (0x6C)     	/* DMAC_LSREQ_2为DMAC通道末次单次传输请求寄存器2。 */
+#define SRE_DMAC_SECURIRY_READ_REG           (0x70)     	/* DMAC_SECURIRY_READ为DMAC通道安全读访问控制寄存器。 */
+#define SRE_SECURIRY_WRITE_REG               (0x74)     	/* SECURIRY_WRITE为DMAC通道安全写访问控制寄存器。 */
+#define SRE_DMAC_G_EN_REG                    (0x78)     	/* DMAC_G_EN为DMAC控制寄存器。 */
+#define SRE_DMAC_AUDIO_JP_SIZE_REG      		(0x7C)     	/* DMAC_AUDIO_JP_SIZE为音频跳跃搬移寄存器。 */
+#define SRE_DMAC_STRID_CH_SIZE_REG      		(0x80)     	/* DMAC_STRID_CH_SIZE为重排序通道的步长设置寄存器。高16位用于某个读通道，低16位用于某个写通道。 */
+#define SRE_DMAC_VIDEO_LN_SIZE_REG      		(0x84)     	/* 重排序通道的源或者目的数据块大小设置寄存器。用于设置每搬移多大的数据块之后源或者目的地址增加一个步长。 */
+#define SRE_DMAC_CMSRCADDR_0_REG        		(0x100)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_1_REG        		(0x110)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_2_REG        		(0x120)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_3_REG        		(0x130)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_4_REG        		(0x140)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_5_REG        		(0x150) 	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_6_REG        		(0x160)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_7_REG        		(0x170)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_8_REG        		(0x180)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_9_REG        		(0x190) 	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_10_REG       		(0x1A0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_11_REG       		(0x1B0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_12_REG       		(0x1C0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_13_REG       		(0x1D0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_14_REG       		(0x1E0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMSRCADDR_15_REG       		(0x1F0)  	/* 通道m的源地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_0_REG       		(0x104)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_1_REG       		(0x114)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_2_REG       		(0x124)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_3_REG       		(0x134)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_4_REG       		(0x144)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_5_REG       		(0x154)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_6_REG       		(0x164)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_7_REG       		(0x174)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_8_REG       		(0x184)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_9_REG       		(0x194)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_10_REG      		(0x1A4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_11_REG      		(0x1B4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_12_REG      		(0x1C4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_13_REG      		(0x1D4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_14_REG      		(0x1E4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMDESTADDR_15_REG      		(0x1F4)  	/* 通道m的目标地址寄存器。 */
+#define SRE_DMAC_CMLLI_0_REG            		(0x108)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_1_REG            		(0x118)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_2_REG            		(0x128)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_3_REG            		(0x138)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_4_REG            		(0x148)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_5_REG            		(0x158)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_6_REG            		(0x168)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_7_REG            		(0x178)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_8_REG            		(0x188)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_9_REG           		(0x198)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_10_REG           		(0x1A8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_11_REG           		(0x1B8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_12_REG           		(0x1C8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_13_REG           		(0x1D8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_14_REG           		(0x1E8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMLLI_15_REG           		(0x1F8)  	/* 通道m的链表项寄存器。 */
+#define SRE_DMAC_CMCONTROL_0_REG        		(0x10C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_1_REG        		(0x11C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_2_REG        		(0x12C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_3_REG        		(0x13C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_4_REG        		(0x14C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_5_REG        		(0x15C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_6_REG        		(0x16C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_7_REG        		(0x17C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_8_REG        		(0x18C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_9_REG        		(0x19C)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_10_REG       		(0x1AC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_11_REG       		(0x1BC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_12_REG       		(0x1CC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_13_REG       		(0x1DC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_14_REG       		(0x1EC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONTROL_15_REG       		(0x1FC)  	/* 通道m的控制寄存器。 */
+#define SRE_DMAC_CMCONFIG_0_REG         		(0x300)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_1_REG         		(0x304)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_2_REG         		(0x308)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_3_REG         		(0x30C)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_4_REG         		(0x310)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_5_REG         		(0x314)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_6_REG         		(0x318)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_7_REG         		(0x31C)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_8_REG         		(0x320)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_9_REG         		(0x324)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_10_REG        		(0x328)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_11_REG        		(0x32C)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_12_REG        		(0x330)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_13_REG        		(0x334)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_14_REG        		(0x338)  	/* 通道m的配置寄存器。 */
+#define SRE_DMAC_CMCONFIG_15_REG        		(0x33C)  	/* 通道m的配置寄存器。 */
+
+/******************************************************************************/
+/*                      PhosphorV650 SEC_COMMON 寄存器定义                    */
+/******************************************************************************/
+#define SRE_SEC_REG_BASE                               (0xe0800000)
+#define SRE_SEC_COM_SEC_CLK_EN_REG                     (SRE_SEC_REG_BASE + 0x0)             /* SEC时钟使能控制 */
+#define SRE_SEC_COM_SEC_GET_POE_ADDR_REG               (SRE_SEC_REG_BASE + 0x4)             /* GET POE地址寄存器。 */
+#define SRE_SEC_COM_SEC_ADD_POE_ADDR_REG               (SRE_SEC_REG_BASE + 0x8)             /* ADD POE地址寄存器 */
+#define SRE_SEC_COM_SEC_BD_OFFSET_REG                  (SRE_SEC_REG_BASE + 0xC)             /* SEC BD偏移地址配置寄存器 */
+#define SRE_SEC_COM_POE_FAIL_WAIT_TIME_REG             (SRE_SEC_REG_BASE + 0x10)            /* ADD或GET POE失败等待时间寄存器 */
+#define SRE_SEC_COM_POE_SUC_WAIT_TIME_REG              (SRE_SEC_REG_BASE + 0x14)            /* ADD或GET POE成功等待时间寄存器 */
+#define SRE_SEC_COM_SEC_CONTROL_REG                    (SRE_SEC_REG_BASE + 0x18)            /* SEC全局配置寄存器 */
+#define SRE_SEC_COM_POE_ADD_FAIL_CNT_REG               (SRE_SEC_REG_BASE + 0x1C)            /* ADD POE PACKET 失败次数的统计状态寄存器 */
+#define SRE_SEC_COM_POE_ADD_SUC_CNT_REG                (SRE_SEC_REG_BASE + 0x20)            /* ADD POE PACKET 成功次数的统计状态寄存器 */
+#define SRE_SEC_COM_POE_GET_FAIL_CNT_REG               (SRE_SEC_REG_BASE + 0x24)            /* GET POE PACKET 失败次数的统计状态寄存器 */
+#define SRE_SEC_COM_POE_GET_SUC_CNT_REG                (SRE_SEC_REG_BASE + 0x28)            /* GET POE PACKET 成功次数的统计状态寄存器 */
+#define SRE_SEC_COM_SEC_BUS_TIMEOUT_THLD_REG           (SRE_SEC_REG_BASE + 0x2C)            /* SEC总线超时门限寄存器 */
+#define SRE_SEC_COM_COMMON_RC_EN_CTRL_REG              (SRE_SEC_REG_BASE + 0x30)            /* 读清寄存器读清除使能 */
+#define SRE_SEC_COM_SEC_GET_FAIL_THLD_REG              (SRE_SEC_REG_BASE + 0x34)            /* SEC GET POE失败次数门限寄存器 */
+#define SRE_SEC_COM_SEC_ADD_FAIL_THLD_REG              (SRE_SEC_REG_BASE + 0x38)            /* SEC ADD POE失败次数门限寄存器 */
+#define SRE_SEC_COM_SEC_BD_FIFO_DATA_REG               (SRE_SEC_REG_BASE + 0x3C)            /* BD FIFO模式任务添加寄存器 */
+#define SRE_SEC_COM_SEC_TASKIN_FIFO_STATUS_REG         (SRE_SEC_REG_BASE + 0x40)            /* TASK IN FIFO状态寄存器 */
+#define SRE_SEC_COM_SEC_ST_SRC_INT_REG                 (SRE_SEC_REG_BASE + 0x44)            /* SEC全局源中断寄存器 */
+#define SRE_SEC_COM_SEC_ST_INT_MASK_REG                (SRE_SEC_REG_BASE + 0x48)            /* SEC全局中断屏蔽寄存器 */
+#define SRE_SEC_COM_SEC_ST_INT_STATUS_REG              (SRE_SEC_REG_BASE + 0x4C)            /* SEC全局中断状态寄存器 */
+#define SRE_SEC_COM_SEC_BD_SRC_INT_REG                 (SRE_SEC_REG_BASE + 0x50)            /* SEC BD解析源中断寄存器 */
+#define SRE_SEC_COM_SEC_BD_INT_MASK_REG                (SRE_SEC_REG_BASE + 0x54)            /* SEC BD解析中断屏蔽寄存器 */
+#define SRE_SEC_COM_SEC_BD_INT_STATUS_REG              (SRE_SEC_REG_BASE + 0x58)            /* SEC BD解析中断状态寄存器 */
+#define SRE_SEC_COM_IPV4_MASK_TABLE_REG                (SRE_SEC_REG_BASE + 0x60)            /* IPV4 MASK表配置寄存器 */
+#define SRE_SEC_COM_IPV6_MASK_TABLE_LSB_REG            (SRE_SEC_REG_BASE + 0x64)            /* IPV6 MASK表低32位配置寄存器 */
+#define SRE_SEC_COM_IPV6_MASK_TABLE_MSB_REG            (SRE_SEC_REG_BASE + 0x68)            /* IPV6 MASK表高8位配置寄存器 */
+#define SRE_SEC_COM_SEC_STOP_REQUST_AND_STATUS_REG     (SRE_SEC_REG_BASE + 0x6C)            /* SEC 停止请求和停止状态寄存器 */
+#define SRE_SEC_COM_SEC_STOP_TIMEOUT_THLD_REG          (SRE_SEC_REG_BASE + 0x70)            /* SEC停止超时寄存器 */
+#define SRE_SEC_COM_SEC_CONTROL_2_REG                  (SRE_SEC_REG_BASE + 0x74)            /* SEC全局配置寄存器 */
+#define SRE_SEC_COM_SEC_SECURE_CONTROL_REG             (SRE_SEC_REG_BASE + 0x80)            /* 系统安全控制寄存器 */
+#define SRE_SEC_COM_SEC_SECURE_SRAM_START_ADDR_REG     (SRE_SEC_REG_BASE + 0x84)            /* 安全SRAM起始地址 */
+#define SRE_SEC_COM_SEC_SECURE_SRAM_MEM_LEN_REG        (SRE_SEC_REG_BASE + 0x8C)            /* 安全SRAM长度 */
+#define SRE_SEC_COM_BD_NUM_CNT_IN_FIFO_REG             (SRE_SEC_REG_BASE + 0x400)           /* 保序模块内FIFO中任务总个数状态寄存器 */
+#define SRE_SEC_COM_BD_NUM_CNT_IN_SEC_REG              (SRE_SEC_REG_BASE + 0x404)           /* SEC模块内部BD总个数状态寄存器 */
+#define SRE_SEC_COM_SEC_ORDER_FSM_STATUS_REG           (SRE_SEC_REG_BASE + 0x408)           /* 保序模块内状态机状态寄存器 */
+#define SRE_SEC_COM_SEC_BD_AXI_DFX_CTRL_REG            (SRE_SEC_REG_BASE + 0x40C)           /* BD AXI端口DFX控制寄存器 */
+#define SRE_SEC_COM_SEC_BD_AXI_DFX_LAT_AVG_REG         (SRE_SEC_REG_BASE + 0x410)           /* BD AXI端口读写平均延迟 */
+#define SRE_SEC_COM_SEC_BD_AXI_DFX_LAT_MAX_REG         (SRE_SEC_REG_BASE + 0x414)           /* BD AXI端口读写最大延迟 */
+#define SRE_SEC_COM_SEC_BD_AXI_WR_ACC_REG              (SRE_SEC_REG_BASE + 0x418)           /* BD AXI端口写累计计数器 */
+#define SRE_SEC_COM_SEC_BD_AXI_RD_ACC_REG              (SRE_SEC_REG_BASE + 0x41C)           /* BD AXI端口读累计计数器 */
+#define SRE_SEC_COM_SEC_BD_AXI_WR_OTD_1_REG            (SRE_SEC_REG_BASE + 0x420)           /* BD AXI端口写outstanding计数器1 */
+#define SRE_SEC_COM_SEC_BD_AXI_WR_OTD_2_REG            (SRE_SEC_REG_BASE + 0x424)           /* BD AXI端口写outstanding计数器2 */
+#define SRE_SEC_COM_SEC_BD_AXI_WR_OTD_3_REG            (SRE_SEC_REG_BASE + 0x428)           /* BD AXI端口写outstanding计数器3 */
+#define SRE_SEC_COM_SEC_BD_AXI_RD_OTD_1_REG            (SRE_SEC_REG_BASE + 0x42C)           /* BD AXI端口读outstanding计数器1 */
+#define SRE_SEC_COM_SEC_BD_AXI_RD_OTD_2_REG            (SRE_SEC_REG_BASE + 0x430)           /* BD AXI端口读outstanding计数器2 */
+#define SRE_SEC_COM_SEC_BD_AXI_RD_OTD_3_REG            (SRE_SEC_REG_BASE + 0x434)           /* BD AXI端口读outstanding计数器3 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_DFX_CTRL_REG         (SRE_SEC_REG_BASE + 0x438)           /* DATA AXI端口1 DFX控制寄存器 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_DFX_LAT_AVG_REG      (SRE_SEC_REG_BASE + 0x43C)           /* DATA AXI端口1读写平均延迟 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_DFX_LAT_MAX_REG      (SRE_SEC_REG_BASE + 0x440)           /* DATA AXI端口1读写最大延迟 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_WR_ACC_REG           (SRE_SEC_REG_BASE + 0x444)           /* DATA AXI端口1写累计计数器 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_RD_ACC_REG           (SRE_SEC_REG_BASE + 0x448)           /* DATA AXI端口1读累计计数器 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_WR_OTD_1_REG         (SRE_SEC_REG_BASE + 0x44C)           /* DATA AXI端口1写outstanding计数器1 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_WR_OTD_2_REG         (SRE_SEC_REG_BASE + 0x450)           /* DATA AXI端口1写outstanding计数器2 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_RD_OTD_1_REG         (SRE_SEC_REG_BASE + 0x454)           /* DATA AXI端口1读outstanding计数器1 */
+#define SRE_SEC_COM_SEC_DATA_AXI1_RD_OTD_2_REG         (SRE_SEC_REG_BASE + 0x458)           /* DATA AXI端口1读outstanding计数器2 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_DFX_CTRL_REG         (SRE_SEC_REG_BASE + 0x45C)           /* DATA AXI端口2 DFX控制寄存器 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_DFX_LAT_AVG_REG      (SRE_SEC_REG_BASE + 0x460)           /* DATA AXI端口2读写平均延迟 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_DFX_LAT_MAX_REG      (SRE_SEC_REG_BASE + 0x464)           /* DATA AXI端口2读写最大延迟 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_WR_ACC_REG           (SRE_SEC_REG_BASE + 0x468)           /* DATA AXI端口2写累计计数器 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_RD_ACC_REG           (SRE_SEC_REG_BASE + 0x46C)           /* DATA AXI端口2读累计计数器 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_WR_OTD_1_REG         (SRE_SEC_REG_BASE + 0x470)           /* DATA AXI端口2写outstanding计数器1 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_WR_OTD_2_REG         (SRE_SEC_REG_BASE + 0x474)           /* DATA AXI端口2写outstanding计数器2 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_RD_OTD_1_REG         (SRE_SEC_REG_BASE + 0x478)           /* DATA AXI端口2读outstanding计数器1 */
+#define SRE_SEC_COM_SEC_DATA_AXI2_RD_OTD_2_REG         (SRE_SEC_REG_BASE + 0x47C)           /* DATA AXI端口2读outstanding计数器2 */
+#define SRE_SEC_COM_SEC_BD_AXI_TIMEOUT_1_REG           (SRE_SEC_REG_BASE + 0x480)           /* BD AXI端口超时标志寄存器1 */
+#define SRE_SEC_COM_SEC_BD_AXI_TIMEOUT_2_REG           (SRE_SEC_REG_BASE + 0x484)           /* BD AXI端口超时标志寄存器2 */
+#define SRE_SEC_COM_SEC_DATA_AXI_TIMEOUT_REG           (SRE_SEC_REG_BASE + 0x488)           /* DATA AXI端口超时标志寄存器 */
+#define SRE_SEC_COM_SEC_STAT_CLR_REG                   (SRE_SEC_REG_BASE + 0x48C)           /* SEC统计寄存器清零寄存器 */
+#define SRE_SEC_COM_SEC_SAA0_ACC_REG                   (SRE_SEC_REG_BASE + 0x490)           /* SAA0累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA1_ACC_REG                   (SRE_SEC_REG_BASE + 0x494)           /* SAA1累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA2_ACC_REG                   (SRE_SEC_REG_BASE + 0x498)           /* SAA2累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA3_ACC_REG                   (SRE_SEC_REG_BASE + 0x49C)           /* SAA3累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA4_ACC_REG                   (SRE_SEC_REG_BASE + 0x4A0)           /* SAA4累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA5_ACC_REG                   (SRE_SEC_REG_BASE + 0x4A4)           /* SAA5累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA6_ACC_REG                   (SRE_SEC_REG_BASE + 0x4A8)           /* SAA6累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_SAA7_ACC_REG                   (SRE_SEC_REG_BASE + 0x4AC)           /* SAA7累计处理包数寄存器 */
+#define SRE_SEC_COM_SEC_PKT_LATENCY_REG                (SRE_SEC_REG_BASE + 0x4B0)           /* 单包延迟统计寄存器 */
+#define SRE_SEC_COM_RSV_DFX_CONFIG_1_REG               (SRE_SEC_REG_BASE + 0x500)           /* 保留DFX配置寄存器 */
+#define SRE_SEC_COM_RSV_DFX_CONFIG_2_REG               (SRE_SEC_REG_BASE + 0x504)           /* 保留DFX配置寄存器 */
+#define SRE_SEC_COM_RSV_DFX_CONFIG_3_REG               (SRE_SEC_REG_BASE + 0x508)           /* 保留DFX配置寄存器 */
+#define SRE_SEC_COM_RSV_DFX_STATUS_1_REG               (SRE_SEC_REG_BASE + 0x50C)           /* 保留DFX状态寄存器 */
+#define SRE_SEC_COM_RSV_DFX_STATUS_2_REG               (SRE_SEC_REG_BASE + 0x510)           /* 保留DFX状态寄存器 */
+#define SRE_SEC_COM_RSV_DFX_STATUS_3_REG               (SRE_SEC_REG_BASE + 0x514)           /* 保留DFX状态寄存器 */
+
+
+#define SRE_SEC_SAA_REG_BASE                        (SRE_SEC_REG_BASE + 0x1000)
+#define SRE_SEC_CHANNEL_CURR_BD_REG  	       		(SRE_SEC_SAA_REG_BASE + 0x0)  /* CHANNEL_CURR_BD为SAA的Channel当前使用的BD信息寄存器。 */
+#define SRE_SEC_SHADOW_CURR_BD_REG  	            (SRE_SEC_SAA_REG_BASE + 0x200)  /* SHADOW_CURR_BD为SAA的SHADOW状态机当前使用的BD信息寄存器。 */
+#define SRE_SEC_CIPHER_IVIN_REG    	                (SRE_SEC_SAA_REG_BASE + 0x400)  /* SAA SHADOW状态机当前使用的CIPHER IVIN值信息寄存器。 */
+#define SRE_SEC_CIPHER_KEY_REG     	                (SRE_SEC_SAA_REG_BASE + 0x500)  /* SAA SHADOW状态机当前使用的CIPHER KEY值信息寄存器。 */
+#define SRE_SEC_HASH_IVIN_REG      	                (SRE_SEC_SAA_REG_BASE + 0x600)  /* SAA SHADOW状态机当前使用的HASH IVIN值信息寄存器。 */
+#define SRE_SEC_HASH_KEY_REG       	                (SRE_SEC_SAA_REG_BASE + 0x700)  /* SAA SHADOW状态机当前使用的HMAC KEY值信息寄存器。 */
+#define SRE_SEC_HASH_IVOUT_REG     	                (SRE_SEC_SAA_REG_BASE + 0x800)  /* SAA当前输出的HASH IV OUT值信息寄存器。 */
+#define SRE_SEC_CHANNEL_STATUS_REG   	            (SRE_SEC_SAA_REG_BASE + 0x908)  /* CHANNEL_STATUS为Channel状态寄存器。 */
+#define SRE_SEC_CHANNEL_TIME_OUT_CNT_REG       		(SRE_SEC_SAA_REG_BASE + 0x90C)  /* CHANNEL状态机智能心跳计数值寄存器 */
+#define SRE_SEC_CHANNEL_MAX_CNT_REG  	        	(SRE_SEC_SAA_REG_BASE + 0x910)  /* CHANNEL状态机智能心跳计数上限值配置寄存器 */
+#define SRE_SEC_SHADOW_TIME_OUT_CNT_REG        		(SRE_SEC_SAA_REG_BASE + 0x914)  /* SHADOW状态机智能心跳计数值寄存器 */
+#define SRE_SEC_SHADOW_MAX_CNT_REG   	        	(SRE_SEC_SAA_REG_BASE + 0x918)  /* SHADOW状态机智能心跳计数上限值配置寄存器 */
+#define SRE_SEC_SEC_BD_ERR_ADDR_REG  	            (SRE_SEC_SAA_REG_BASE + 0x91C)  /* 最近一次错误BD地址查询寄存器 */
+#define SRE_SEC_SEC_BD_ERR_CNT_REG   	            (SRE_SEC_SAA_REG_BASE + 0x920)  /* SEC BD错误统计寄存器 */
+#define SRE_SEC_SAA_GET2ADD_WAIT_TIME_REG    		(SRE_SEC_SAA_REG_BASE + 0x924)  /* 在可以ADD BD时，获取BD的最长等待时间配置寄存器。 */
+#define SRE_SEC_SAA_RC_EN_CTRL_REG   	            (SRE_SEC_SAA_REG_BASE + 0x928)  /* 读清寄存器读清除使能 */
+#define SRE_SEC_SAA_ADD_DATA_1_REG                  (SRE_SEC_SAA_REG_BASE + 0xD00)  /* 当前SAA ADD DATA总线数据 */
+#define SRE_SEC_SAA_ADD_DATA_2_REG                  (SRE_SEC_SAA_REG_BASE + 0xD04)  /* 当前SAA ADD DATA总线数据 */
+#define SRE_SEC_SAA_ADD_DATA_3_REG                  (SRE_SEC_SAA_REG_BASE + 0xD08)  /* 当前SAA ADD DATA总线数据 */
+#define SRE_SEC_DFX_CONFIG_SEL_REG                  (SRE_SEC_SAA_REG_BASE + 0xD0C)  /* DFX配置寄存器 */
+#define SRE_SEC_RSV_DFX_CONFIG_1_REG                (SRE_SEC_SAA_REG_BASE + 0xE00)  /* 保留DFX配置寄存器 */
+#define SRE_SEC_RSV_DFX_CONFIG_2_REG                (SRE_SEC_SAA_REG_BASE + 0xE04)  /* 保留DFX配置寄存器 */
+#define SRE_SEC_RSV_DFX_CONFIG_3_REG                (SRE_SEC_SAA_REG_BASE + 0xE08)  /* 保留DFX配置寄存器 */
+#define SRE_SEC_RSV_DFX_STATUS_1_REG                (SRE_SEC_SAA_REG_BASE + 0xE0C)  /* 保留DFX状态寄存器 */
+#define SRE_SEC_RSV_DFX_STATUS_2_REG                (SRE_SEC_SAA_REG_BASE + 0xE10)  /* 保留DFX状态寄存器 */
+#define SRE_SEC_RSV_DFX_STATUS_3_REG                (SRE_SEC_SAA_REG_BASE + 0xE14)  /* 保留DFX状态寄存器 */
+
+
+/******************************************************************************/
+/*                      PhosphorV650 rohc Engine 寄存器定义               */
+/******************************************************************************/
+/* rohc_config 模块寄存器基地址 */
+#define SRE_ROHC_CONFIG_BASE                     (0x10810000)
+
+/******************************************************************************/
+/*                      MC rohc_config 寄存器定义                   */
+/******************************************************************************/
+#define SRE_ROHC_CONFIG_ROHC_ENABLE_REG                              (SRE_ROHC_CONFIG_BASE + 0x0)  /* ROHC全局使能控制寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_CONTROL_REG                          (SRE_ROHC_CONFIG_BASE + 0x4)  /* ROHC全局配置寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_COMP_GET_POE_ADDR_REG  (SRE_ROHC_CONFIG_BASE + 0x8)  /* 压缩端GET POE地址寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_COMP_ADD_POE_ADDR_REG  (SRE_ROHC_CONFIG_BASE + 0xC)  /* 压缩端ADD POE地址寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DECOMP_GET_POE_ADDR_REG  (SRE_ROHC_CONFIG_BASE + 0x10)  /* 解压端GET POE地址寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DECOMP_ADD_POE_ADDR_REG  (SRE_ROHC_CONFIG_BASE + 0x14)  /* 解压端ADD POE地址寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_PDCP_ADDR_REG                           (SRE_ROHC_CONFIG_BASE + 0x18)  /* PDCP实体地址寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_CRCOPT_PKT_NUM_REG        (SRE_ROHC_CONFIG_BASE + 0x24)  /* 判断报文数量配置寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_FDBACK_PKT_NUM_REG         (SRE_ROHC_CONFIG_BASE + 0x28)  /* 反馈包数量配置寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_POE_FAIL_WAIT_TIME_REG  (SRE_ROHC_CONFIG_BASE + 0x2C)  /* POE GET或ADD任务失败等待寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_POE_OK_WAIT_TIME_REG     (SRE_ROHC_CONFIG_BASE + 0x30)  /* POE GET或ADD任务成功等待寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_BACK2IRFO_TIME_REG  (SRE_ROHC_CONFIG_BASE + 0x34)  /* 定时回迁寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_IPID_MAX_DELTA_REG  (SRE_ROHC_CONFIG_BASE + 0x38)  /* IPID变化范围寄存器。 */
+#define SRE_ROHC_CONFIG_PRF0_STATE_THLD_REG            (SRE_ROHC_CONFIG_BASE + 0x3c)  /* profile0跃迁、回迁门限 */
+#define SRE_ROHC_CONFIG_ROHC_FC2SC_N1_REG                (SRE_ROHC_CONFIG_BASE + 0x40)  /* 解压端状态跳转连续解压的总包数配置寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_CTXLIST_ADDR_REG      (SRE_ROHC_CONFIG_BASE + 0x44)  /* ROHC上下文表起始地址配置寄存器。(压缩、解压缩配置寄存器合并） */
+#define SRE_ROHC_CONFIG_ROHC_CTX_ADDR_REG              (SRE_ROHC_CONFIG_BASE + 0x48)  /* 上下文空间起始地址配置寄存器。(压缩、解压缩配置寄存器合并） */
+#define SRE_ROHC_CONFIG_ROHC_PDCP_ID_OFST_REG      (SRE_ROHC_CONFIG_BASE + 0x4C)  /* PDCP实体ID偏移配置寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_SEC_BD_OFST_REG        (SRE_ROHC_CONFIG_BASE + 0x50)  /* SEC BD在报文缓冲区的偏移。 */
+#define SRE_ROHC_CONFIG_SN_WRAP_AROUND_THLD_REG     (SRE_ROHC_CONFIG_BASE + 0x54)  /* 判断SN卷绕门限 */
+#define SRE_ROHC_CONFIG_BMU_RELEASE_BASE_ADDR_REG   (SRE_ROHC_CONFIG_BASE + 0x58)  /* 写BMU释放缓存基地址寄存器 */
+#define SRE_ROHC_CONFIG_BMU_REQ_ADDR_REG                       (SRE_ROHC_CONFIG_BASE + 0x5C)  /* 读BMU申请缓存地址寄存器 */
+#define SRE_ROHC_CONFIG_BMU_WR_FAIL_WATI_TIME_REG   (SRE_ROHC_CONFIG_BASE + 0x60)  /* 写BUM释放缓存失败延迟寄存器 */
+#define SRE_ROHC_CONFIG_BMU_RD_FAIL_WAIT_TIME_REG    (SRE_ROHC_CONFIG_BASE + 0x64)  /* 读BUM申请缓存失败延迟寄存器 */
+#define SRE_ROHC_CONFIG_BMU_BUF_ADDR0_REG                      (SRE_ROHC_CONFIG_BASE + 0x68)  /* ROHC内部拥有的BMU缓存地址0 */
+#define SRE_ROHC_CONFIG_BMU_BUF_ADDR1_REG                      (SRE_ROHC_CONFIG_BASE + 0x6C)  /* ROHC内部拥有的BMU缓存地址1 */
+#define SRE_ROHC_CONFIG_BMU_REQ_BUF_CNT_REG                 (SRE_ROHC_CONFIG_BASE + 0x70)  /* 读申请BMU缓存个数统计寄存器 */
+#define SRE_ROHC_CONFIG_BMU_RELEASE_BUF_CNT_REG         (SRE_ROHC_CONFIG_BASE + 0x74)  /* 写释放BMU缓存个数统计寄存器 */
+#define SRE_ROHC_CONFIG_BMU_REQ_BUF_FAIL_CNT_REG       (SRE_ROHC_CONFIG_BASE + 0x78)  /* 读BMU申请缓存连续失败个数统计计数器 */
+#define SRE_ROHC_CONFIG_BMU_RELEASE_BUF_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x7C)  /* 写BMU释放缓存连续失败个数统计计数器 */
+#define SRE_ROHC_CONFIG_BMU_REQ_BUFFER_REG                       (SRE_ROHC_CONFIG_BASE + 0x80)  /* 反馈包相关 */
+#define SRE_ROHC_CONFIG_FBK_GROUP_TT_QOS_REG                  (SRE_ROHC_CONFIG_BASE + 0x84)  /* 反馈包相关*/
+#define SRE_ROHC_CONFIG_HBEAT_THLD_REG                                 (SRE_ROHC_CONFIG_BASE + 0x88)  /* 只能心跳阈值*/
+#define SRE_ROHC_CONFIG_BMU_INT_THLD_REG                            (SRE_ROHC_CONFIG_BASE + 0x8C)  /* BMU连续失败中断阈值寄存器 */
+#define SRE_ROHC_CONFIG_BUT_MAX_TIMEOUT_THLD_REG         (SRE_ROHC_CONFIG_BASE + 0x90)  /* 总线最大延时超时门限 */
+#define SRE_ROHC_CONFIG_POE_INT_THLD_REG                             (SRE_ROHC_CONFIG_BASE + 0x94)  /* POE连续失败中断阈值寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_SRC_INT_REG                            (SRE_ROHC_CONFIG_BASE + 0x98)  /* ROHC源中断寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_INT_MASK_REG                         (SRE_ROHC_CONFIG_BASE + 0x9C)  /* ROHC中断屏蔽寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_INTSTS_REG                               (SRE_ROHC_CONFIG_BASE + 0x100)  /* 超时中断状态寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_C_GET_POE_SUC_CNT_REG    (SRE_ROHC_CONFIG_BASE + 0x110)  /* 压缩器GET POE成功次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_C_ADD_POE_SUC_CNT_REG    (SRE_ROHC_CONFIG_BASE + 0x114)  /* 压缩器ADD POE成功次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_C_GET_POE_FAIL_CNT_REG    (SRE_ROHC_CONFIG_BASE + 0x118)  /* 压缩器GET POE失败次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_C_ADD_POE_FAIL_CNT_REG    (SRE_ROHC_CONFIG_BASE + 0x11C)  /* 压缩器ADD POE失败次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_D_GET_POE_SUC_CNT_REG     (SRE_ROHC_CONFIG_BASE + 0x120)  /* 解压器GET POE成功次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_D_ADD_POE_SUC_CNT_REG     (SRE_ROHC_CONFIG_BASE + 0x124)  /* 解压器ADD POE成功次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_D_GET_POE_FAIL_CNT_REG     (SRE_ROHC_CONFIG_BASE + 0x128)  /* 解压器GET POE失败次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_D_ADD_POE_FAIL_CNT_REG     (SRE_ROHC_CONFIG_BASE + 0x12C)  /* 解压器ADD POE失败次数统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_C_GET_CONTINUE_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x130)  /* 压缩器GET POE连续失败次数统计寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_C_ADD_CONTINUE_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x134)  /* 压缩器ADD POE连续失败次数统计寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_D_GET_CONTINUE_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x138)  /* 解压器GET POE连续失败次数统计寄存器 */
+#define SRE_ROHC_CONFIG_ROHC_D_ADD_CONTINUE_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x13C)  /* 解压器ADD POE连续失败次数统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_RD_LATENCY_AVG_REG                         (SRE_ROHC_CONFIG_BASE + 0x140)  /* 总线读操作平均延时统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_WR_LATENCY_AVG_REG                        (SRE_ROHC_CONFIG_BASE + 0x144)  /* 总线读操作平均延时统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_RD_LATENCY_MAX_REG                        (SRE_ROHC_CONFIG_BASE + 0x148)  /* 总线读操作最大延时统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_WR_LATENCY_MAX_REG                       (SRE_ROHC_CONFIG_BASE + 0x14C)  /* 总线读操作最大延时统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_RD_ACC_REG                      (SRE_ROHC_CONFIG_BASE + 0x150)  /* 总线读访问次数统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_WR_ACC_REG                     (SRE_ROHC_CONFIG_BASE + 0x154)  /* 总线写访问次数统计寄存器 */
+#define SRE_ROHC_CONFIG_CNT_RD_OTD_MSB_REG            (SRE_ROHC_CONFIG_BASE + 0x158)  /* 总线读outstanding个数统计高32bit */
+#define SRE_ROHC_CONFIG_CNT_RD_OTD_LSB_REG             (SRE_ROHC_CONFIG_BASE + 0x15C)  /* 总线读outstanding个数统计低32bit */
+#define SRE_ROHC_CONFIG_CNT_WR_OTD_MSB_REG           (SRE_ROHC_CONFIG_BASE + 0x160)  /* 总线写outstanding个数统计高32bit */
+#define SRE_ROHC_CONFIG_CNT_WR_OTD_LSB_REG            (SRE_ROHC_CONFIG_BASE + 0x164)  /* 总线写outstanding个数统计低32bit */
+#define SRE_ROHC_CONFIG_ROHC_HOLD_PKT_NUM_REG    (SRE_ROHC_CONFIG_BASE + 0x168)  /* rohc当前hold住的buffer*/
+#define SRE_ROHC_CONFIG_ROHC_UL_DECOMP_PKT_CNT_REG   (SRE_ROHC_CONFIG_BASE + 0x200)  /* 上行收到压缩包的数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_DECOMP_FAIL_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x204)  /* 上行解压失败统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_DECOMP_OK_CNT_REG     (SRE_ROHC_CONFIG_BASE + 0x208)  /* 上行解压成功统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_CRC_ERR_CNT_REG           (SRE_ROHC_CONFIG_BASE + 0x20C)  /* 上行解压缩CRC校验错误报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_CRC_OK_CNT_REG             (SRE_ROHC_CONFIG_BASE + 0x210)  /* 上行解压缩CRC校验成功报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PKTTYP_ERR_CNT_REG    (SRE_ROHC_CONFIG_BASE + 0x214)  /* 上行解压缩压缩包类型错误数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_COMP_PKT_CNT_REG        (SRE_ROHC_CONFIG_BASE + 0x218)  /* 下行压缩使能报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_COMP_ERR_CNT_REG        (SRE_ROHC_CONFIG_BASE + 0x21C)  /* 下行压缩失败报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_COMP_OK_CNT_REG          (SRE_ROHC_CONFIG_BASE + 0x220)  /* 下行压缩成功报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF0_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x234)  /* 下行选择Profile0压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF1_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x238)  /* 下行选择Profile1压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF2_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x23C)  /* 下行选择Profile2压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF3_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x240)  /* 下行选择Profile3压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF4_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x244)  /* 下行选择Profile4压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_PROF6_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x248)  /* 下行选择Profile6压缩报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF0_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x24C)  /* 上行选择Profile0解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF1_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x250)  /* 上行选择Profile1解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF2_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x254)  /* 上行选择Profile2解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF3_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x258)  /* 上行选择Profile3解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF4_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x25C)  /* 上行选择Profile4解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_PROF6_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x260)  /* 上行选择Profile6解压报文数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_IR_CNT_REG          (SRE_ROHC_CONFIG_BASE + 0x264)  /* 下行压缩采用IR包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_IRDYN_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x268)  /* 下行压缩采用IRDYN包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_EX3_CNT_REG        (SRE_ROHC_CONFIG_BASE + 0x278)  /* 下行压缩采用扩展3类型包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_IR_CNT_REG           (SRE_ROHC_CONFIG_BASE + 0x27C)  /* 上行解压收到IR包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_IRDYN_CNT_REG   (SRE_ROHC_CONFIG_BASE + 0x280)  /* 上行解压收到IRDYN包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_TYP0_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x284)  /* 上行解压收到0型包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_TYP1_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x288)  /* 上行解压收到1型包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_TYP2_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x28C)  /* 上行解压收到2型包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_EX3_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x290)  /* 上行解压收到扩展3类型包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_DL_FBK_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x294)  /* 下行压缩器收到反馈包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_ROHC_UL_FBK_CNT_REG  (SRE_ROHC_CONFIG_BASE + 0x298)  /* 上行解压器产生反馈包数量统计寄存器。 */
+#define SRE_ROHC_CONFIG_CNT_CLR_EN_REG0_REG  (SRE_ROHC_CONFIG_BASE + 0x300)  /* 统计计数器清0使能寄存器0。 */
+#define SRE_ROHC_CONFIG_CNT_CLR_EN_REG1_REG  (SRE_ROHC_CONFIG_BASE + 0x304)  /* 统计计数器清0使能寄存器1。 */
+#define SRE_ROHC_CONFIG_READ_CLR_EN_REG           (SRE_ROHC_CONFIG_BASE + 0x308)  /* 读清使能控制寄存器 */
+#define SRE_ROHC_CONFIG_C_CTX_RD_CTRL_REG      (SRE_ROHC_CONFIG_BASE + 0x400)  /* 压缩器上下文读取控制寄存器 */
+#define SRE_ROHC_CONFIG_C_CTX_WORD0_REG  (SRE_ROHC_CONFIG_BASE + 0x404)  /* 压缩器上下文数据寄存器0 */
+#define SRE_ROHC_CONFIG_C_CTX_WORD1_REG  (SRE_ROHC_CONFIG_BASE + 0x408)  /* 压缩器上下文数据寄存器1 */
+#define SRE_ROHC_CONFIG_C_CTX_WORD2_REG  (SRE_ROHC_CONFIG_BASE + 0x40C)  /* 压缩器上下文数据寄存器2 */
+#define SRE_ROHC_CONFIG_C_CTX_WORD3_REG  (SRE_ROHC_CONFIG_BASE + 0x410)  /* 压缩器上下文数据寄存器3 */
+#define SRE_ROHC_CONFIG_D_CTX_WORD0_REG  (SRE_ROHC_CONFIG_BASE + 0x414)  /* 解压器上下文数据寄存器0 */
+#define SRE_ROHC_CONFIG_D_CTX_WORD1_REG  (SRE_ROHC_CONFIG_BASE + 0x418)  /* 解压器上下文数据寄存器1 */
+#define SRE_ROHC_CONFIG_D_CTX_WORD2_REG  (SRE_ROHC_CONFIG_BASE + 0x41C)  /* 解压器上下文数据寄存器2 */
+#define SRE_ROHC_CONFIG_D_CTX_WORD3_REG  (SRE_ROHC_CONFIG_BASE + 0x420)  /* 解压器上下文数据寄存器3 */
+#define SRE_ROHC_CONFIG_PE_INDEX_REG                (SRE_ROHC_CONFIG_BASE + 0x424)  /* 流水线指针状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE1_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x500)  /* 压缩器第一级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE1_PDCP_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x504)  /* 压缩器第一级PDCP读取状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE1_CID_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x508)  /* 压缩器第一级CID状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE1_CTX_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x50C)  /* 压缩器第一级上下文读取状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE2_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x510)  /* 压缩器第二级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE2_PPS_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x514)  /* 压缩器第二级包解析状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE2_CRC_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x518)  /* 压缩器第二级CRC状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE2_ASM_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x51C)  /* 压缩器第二级组包状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE3_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x520)  /* 压缩器第三级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE3_PDCP_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x524)  /* 压缩器第三级PDCP回写状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_C_PE3_CTX_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x528)  /* 压缩器第三级上下文回写状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE1_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x530)  /* 解压器第一级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE1_PDCP_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x534)  /* 解压器第一级PDCP读取状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE1_FBK_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x538)  /* 解压器第一级反馈状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE1_CTX_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x53C)  /* 解压器第一级上下文读取状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE2_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x540)  /* 解压器第二级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE2_EX3_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x544)  /* 解压器第二级EX3状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE2_CRC_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x548)  /* 解压器第二级CRC状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE2_STA_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x54C)  /* 解压器第二级STA状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE2_DYN_FSM_REG    (SRE_ROHC_CONFIG_BASE + 0x550)  /* 解压器第二级DYN状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE3_MAIN_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x554)  /* 解压器第三级主状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE3_PDCP_FSM_REG  (SRE_ROHC_CONFIG_BASE + 0x558)  /* 解压器第三级PDCP回写状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_D_PE3_CTX_FSM_REG     (SRE_ROHC_CONFIG_BASE + 0x55C)  /* 解压器第三级上下文回写状态机状态寄存器 */
+#define SRE_ROHC_CONFIG_DFX_CONFIG_REG0		(SRE_ROHC_CONFIG_BASE + 0x0600)	/* DFX配置寄存器0                    */
+#define SRE_ROHC_CONFIG_DFX_CONFIG_REG1		(SRE_ROHC_CONFIG_BASE + 0x0604)	/* DFX配置寄存器1                    */
+#define SRE_ROHC_CONFIG_DFX_CONFIG_REG2		(SRE_ROHC_CONFIG_BASE + 0x0608)	/* DFX配置寄存器2                    */
+#define SRE_ROHC_CONFIG_DFX_STATUE_REG0		(SRE_ROHC_CONFIG_BASE + 0x060C)	/* DFX状态寄存器0                    */
+#define SRE_ROHC_CONFIG_DFX_STATUE_REG1		(SRE_ROHC_CONFIG_BASE + 0x0610)	/* DFX状态寄存器1                    */
+#define SRE_ROHC_CONFIG_DFX_STATUE_REG2		(SRE_ROHC_CONFIG_BASE + 0x0614)	/* DFX状态寄存器2                    */
+#define SRE_ROHC_CONFIG_C_POE_DATA_31_0		(SRE_ROHC_CONFIG_BASE + 0x0620)	/* 压缩器获取POE任务数据Word0寄存器  */
+#define SRE_ROHC_CONFIG_C_POE_DATA_63_32	(SRE_ROHC_CONFIG_BASE + 0x0624)	/* 压缩器获取POE任务数据Word1寄存器  */
+#define SRE_ROHC_CONFIG_C_POE_DATA_95_64	(SRE_ROHC_CONFIG_BASE + 0x0628)	/* 压缩器获取POE任务数据Word2寄存器  */
+#define SRE_ROHC_CONFIG_C_POE_DATA_127_96	(SRE_ROHC_CONFIG_BASE + 0x062C)	/* 压缩器获取POE任务数据Word3寄存器  */
+#define SRE_ROHC_CONFIG_D_POE_DATA_31_0		(SRE_ROHC_CONFIG_BASE + 0x0630)	/* 解压器获取POE任务数据Word0寄存器  */
+#define SRE_ROHC_CONFIG_D_POE_DATA_63_32	(SRE_ROHC_CONFIG_BASE + 0x0634)	/* 解压器获取POE任务数据Word1寄存器  */
+#define SRE_ROHC_CONFIG_D_POE_DATA_95_64	(SRE_ROHC_CONFIG_BASE + 0x0638)	/* 解压器获取POE任务数据Word2寄存器  */
+#define SRE_ROHC_CONFIG_D_POE_DATA_127_96	(SRE_ROHC_CONFIG_BASE + 0x063C)	/* 解压器获取POE任务数据Word3寄存器  */
+#define SRE_ROHC_CONFIG_C_BD_WORD_12		(SRE_ROHC_CONFIG_BASE + 0x0640)	/* 压缩器获取BD Word12寄存器	     */
+#define SRE_ROHC_CONFIG_C_BD_WORD_13		(SRE_ROHC_CONFIG_BASE + 0x0644)	/* 压缩器获取BD Word12寄存器	     */
+#define SRE_ROHC_CONFIG_C_BD_WORD_14		(SRE_ROHC_CONFIG_BASE + 0x0648)	/* 压缩器获取BD Word14寄存器	     */
+#define SRE_ROHC_CONFIG_C_DFX_PAYLOAD		(SRE_ROHC_CONFIG_BASE + 0x064C)	/* 压缩器关键标志位状态寄存器        */
+#define SRE_ROHC_CONFIG_D_BD_WORD_12		(SRE_ROHC_CONFIG_BASE + 0x0650)	/* 解压器获取BD Word12寄存器	     */
+#define SRE_ROHC_CONFIG_D_BD_WORD_13		(SRE_ROHC_CONFIG_BASE + 0x0654)	/* 解压器获取BD Word12寄存器	     */
+#define SRE_ROHC_CONFIG_D_BD_WORD_14		(SRE_ROHC_CONFIG_BASE + 0x0658)	/* 解压器获取BD Word14寄存器	     */
+#define SRE_ROHC_CONFIG_D_DFX_PAYLOAD		(SRE_ROHC_CONFIG_BASE + 0x065C)	/* 解压器关键标志位状态寄存器        */
+#define SRE_ROHC_CONFIG_CTX_LOCK_DFX_REG	(SRE_ROHC_CONFIG_BASE + 0x0660)	/* 上下文锁状态寄存器		     */
+#define SRE_ROHC_CONFIG_C_BD_EEROR_ADDR		(SRE_ROHC_CONFIG_BASE + 0x0664)	/* 压缩器BD错误缓存地址寄存器	     */
+#define SRE_ROHC_CONFIG_D_BD_EEROR_ADDR		(SRE_ROHC_CONFIG_BASE + 0x0668)	/* 解压器BD错误缓存地址寄存器	     */
+#define SRE_ROHC_CONFIG_C_PDCP_EEROR_ID		(SRE_ROHC_CONFIG_BASE + 0x066C)	/* 压缩器PDCP错误ID寄存器*/
+#define SRE_ROHC_CONFIG_D_PDCP_EEROR_ID		(SRE_ROHC_CONFIG_BASE + 0x0670)	/* 解压器PDCP错误ID寄存器*/
+#define SRE_ROHC_CONFIG_C_DFX_CTRL_REG		(SRE_ROHC_CONFIG_BASE + 0x0700)	/* 压缩器DFX控制寄存器		     */
+#define SRE_ROHC_CONFIG_D_DFX_CTRL_REG		(SRE_ROHC_CONFIG_BASE + 0x0704)	/* 解压器DFX控制寄存器		     */
+
+/* SCH 模块寄存器基地址 */
+#define SRE_SCH_BASE                                 (0xe1000000UL)
+/******************************************************************************/
+/*                      MC SCH 寄存器定义                                     */
+/******************************************************************************/
+#define SRE_SCH_VMIMO0_CTRL_STOP_REG         (SRE_SCH_BASE + 0x0)       /* cell0 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO0_CTRL_START_REG        (SRE_SCH_BASE + 0x4)       /* cell0 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO0_ANT_NUM_REG           (SRE_SCH_BASE + 0x8)       /* cell0 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO0_USRU_NUM_REG          (SRE_SCH_BASE + 0xC)       /* cell0 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO0_USRV_NUM_REG          (SRE_SCH_BASE + 0x10)      /* cell0 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO0_NPWR_NUM_REG          (SRE_SCH_BASE + 0x14)      /* cell0 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO0_NPWR_ADDR_REG         (SRE_SCH_BASE + 0x18)      /* cell0 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO0_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0x1C)      /* cell0 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO0_SINR_ADDR_REG         (SRE_SCH_BASE + 0x24)      /* cell0 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO0_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0x28)      /* cell0 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO0_RND_MD_REG            (SRE_SCH_BASE + 0x2C)      /* cell0 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO0_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0x30)      /* cell0 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO0_SINR_MINIFY_REG       (SRE_SCH_BASE + 0x34)      /* cell0 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO0_ENDIAN_MD_REG         (SRE_SCH_BASE + 0x38)      /* cell0 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO0_STAT_EN_REG           (SRE_SCH_BASE + 0x3C)      /* cell0 VMIMO运算引擎内部状态统计使能控制 */
+#define SRE_SCH_VMIMO1_CTRL_STOP_REG         (SRE_SCH_BASE + 0x50)      /* cell1 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO1_CTRL_START_REG        (SRE_SCH_BASE + 0x54)      /* cell1 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO1_ANT_NUM_REG           (SRE_SCH_BASE + 0x58)      /* cell1 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO1_USRU_NUM_REG          (SRE_SCH_BASE + 0x5C)      /* cell1 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO1_USRV_NUM_REG          (SRE_SCH_BASE + 0x60)      /* cell1 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO1_NPWR_NUM_REG          (SRE_SCH_BASE + 0x64)      /* cell1 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO1_NPWR_ADDR_REG         (SRE_SCH_BASE + 0x68)      /* cell1 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO1_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0x6C)      /* cell1 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO1_SINR_ADDR_REG         (SRE_SCH_BASE + 0x74)      /* cell1 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO1_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0x78)      /* cell1 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO1_RND_MD_REG            (SRE_SCH_BASE + 0x7C)      /* cell1 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO1_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0x80)      /* cell1 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO1_SINR_MINIFY_REG       (SRE_SCH_BASE + 0x84)      /* cell1 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO1_ENDIAN_MD_REG         (SRE_SCH_BASE + 0x88)      /* cell1 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO1_STAT_EN_REG           (SRE_SCH_BASE + 0x8C)      /* cell1 VMIM运算引擎内部状态统计使能控制 */
+#define SRE_SCH_VMIMO2_CTRL_STOP_REG         (SRE_SCH_BASE + 0xA0)      /* cell2 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO2_CTRL_START_REG        (SRE_SCH_BASE + 0xA4)      /* cell2 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO2_ANT_NUM_REG           (SRE_SCH_BASE + 0xA8)      /* cell2 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO2_USRU_NUM_REG          (SRE_SCH_BASE + 0xAC)      /* cell2 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO2_USRV_NUM_REG          (SRE_SCH_BASE + 0xB0)      /* cell2 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO2_NPWR_NUM_REG          (SRE_SCH_BASE + 0xB4)      /* cell2 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO2_NPWR_ADDR_REG         (SRE_SCH_BASE + 0xB8)      /* cell2 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO2_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0xBC)      /* cell2 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO2_SINR_ADDR_REG         (SRE_SCH_BASE + 0xC4)      /* cell2 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO2_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0xC8)      /* cell2 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO2_RND_MD_REG            (SRE_SCH_BASE + 0xCC)      /* cell2 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO2_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0xD0)      /* cell2 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO2_SINR_MINIFY_REG       (SRE_SCH_BASE + 0xD4)      /* cell2 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO2_ENDIAN_MD_REG         (SRE_SCH_BASE + 0xD8)      /* cell2 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO2_STAT_EN_REG           (SRE_SCH_BASE + 0xDC)      /* cell2 VMIM运算引擎内部状态统计使能控制 */
+#define SRE_SCH_VMIMO3_CTRL_STOP_REG         (SRE_SCH_BASE + 0xF0)      /* cell3 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO3_CTRL_START_REG        (SRE_SCH_BASE + 0xF4)      /* cell3 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO3_ANT_NUM_REG           (SRE_SCH_BASE + 0xF8)      /* cell3 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO3_USRU_NUM_REG          (SRE_SCH_BASE + 0xFC)      /* cell3 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO3_USRV_NUM_REG          (SRE_SCH_BASE + 0x100)     /* cell3 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO3_NPWR_NUM_REG          (SRE_SCH_BASE + 0x104)     /* cell3 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO3_NPWR_ADDR_REG         (SRE_SCH_BASE + 0x108)     /* cell3 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO3_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0x10C)     /* cell3 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO3_SINR_ADDR_REG         (SRE_SCH_BASE + 0x114)     /* cell3 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO3_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0x118)     /* cell3 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO3_RND_MD_REG            (SRE_SCH_BASE + 0x11C)     /* cell3 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO3_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0x120)     /* cell3 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO3_SINR_MINIFY_REG       (SRE_SCH_BASE + 0x124)     /* cell3 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO3_ENDIAN_MD_REG         (SRE_SCH_BASE + 0x128)     /* cell3 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO3_STAT_EN_REG           (SRE_SCH_BASE + 0x12C)     /* cell3 VMIMO运算引擎内部状态统计使能控制 */
+#define SRE_SCH_VMIMO4_CTRL_STOP_REG         (SRE_SCH_BASE + 0x140)     /* cell4 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO4_CTRL_START_REG        (SRE_SCH_BASE + 0x144)     /* cell4 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO4_ANT_NUM_REG           (SRE_SCH_BASE + 0x148)     /* cell4 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO4_USRU_NUM_REG          (SRE_SCH_BASE + 0x14C)     /* cell4 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO4_USRV_NUM_REG          (SRE_SCH_BASE + 0x150)     /* cell4 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO4_NPWR_NUM_REG          (SRE_SCH_BASE + 0x154)     /* cell4 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO4_NPWR_ADDR_REG         (SRE_SCH_BASE + 0x158)     /* cell4 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO4_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0x15C)     /* cell4 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO4_SINR_ADDR_REG         (SRE_SCH_BASE + 0x164)     /* cell4 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO4_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0x168)     /* cell4 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO4_RND_MD_REG            (SRE_SCH_BASE + 0x16C)     /* cell4 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO4_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0x170)     /* cell4 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO4_SINR_MINIFY_REG       (SRE_SCH_BASE + 0x174)     /* cell4 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO4_ENDIAN_MD_REG         (SRE_SCH_BASE + 0x178)     /* cell4 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO4_STAT_EN_REG           (SRE_SCH_BASE + 0x17C)     /* cell4 VMIMO运算引擎内部状态统计使能控制 */
+#define SRE_SCH_VMIMO5_CTRL_STOP_REG         (SRE_SCH_BASE + 0x190)     /* cell5 VMIMO运算终止控制寄存器。 */
+#define SRE_SCH_VMIMO5_CTRL_START_REG        (SRE_SCH_BASE + 0x194)     /* cell5 VMIMO运算启动控制寄存器。 */
+#define SRE_SCH_VMIMO5_ANT_NUM_REG           (SRE_SCH_BASE + 0x198)     /* cell5 VMIMO信道响应矩阵的天线数寄存器。 */
+#define SRE_SCH_VMIMO5_USRU_NUM_REG          (SRE_SCH_BASE + 0x19C)     /* cell5 VMIMO运算实际U用户数寄存器。 */
+#define SRE_SCH_VMIMO5_USRV_NUM_REG          (SRE_SCH_BASE + 0x1A0)     /* cell5 VMIMO运算实际V用户数寄存器。 */
+#define SRE_SCH_VMIMO5_NPWR_NUM_REG          (SRE_SCH_BASE + 0x1A4)     /* cell5 VMIMO运算噪声功率个数寄存器。 */
+#define SRE_SCH_VMIMO5_NPWR_ADDR_REG         (SRE_SCH_BASE + 0x1A8)     /* cell5 VMIMO运算噪声功率在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO5_USRINFO_ADDR_REG      (SRE_SCH_BASE + 0x1AC)     /* cell5 VMIMO用户信息在DDR中的首地址寄存器。 */
+#define SRE_SCH_VMIMO5_SINR_ADDR_REG         (SRE_SCH_BASE + 0x1B4)     /* cell5 VMIMO将SINR修正值写入DDR的首地址。 */
+#define SRE_SCH_VMIMO5_USRPAIR_NUM_REG       (SRE_SCH_BASE + 0x1B8)     /* cell5 VMIMO UV用户对数 */
+#define SRE_SCH_VMIMO5_RND_MD_REG            (SRE_SCH_BASE + 0x1BC)     /* cell5 VMIMO运算结果舍入模式选择控制器 */
+#define SRE_SCH_VMIMO5_SINR_AMPLFY_REG       (SRE_SCH_BASE + 0x1C0)     /* cell5 VMIMO SINR计算结果放大倍数的浮点数 */
+#define SRE_SCH_VMIMO5_SINR_MINIFY_REG       (SRE_SCH_BASE + 0x1C4)     /* cell5 VMIMO SINR计算输入数据缩小倍数的倒数的浮点数 */
+#define SRE_SCH_VMIMO5_ENDIAN_MD_REG         (SRE_SCH_BASE + 0x1C8)     /* cell5 VMIMO访问DDR大小端模式控制寄存器 */
+#define SRE_SCH_VMIMO5_STAT_EN_REG           (SRE_SCH_BASE + 0x1CC)     /* cell5 VMIMO运算引擎内部状态统计使能控制 */
+#define SRE_SCH_SCH_AXI_TRACE_ENA_REG        (SRE_SCH_BASE + 0x1E0)     /* SCH AXI性能统计使能控制 */
+#define SRE_SCH_SCH_VMID_REG                 (SRE_SCH_BASE + 0x1E4)     /* SCH VMID配置寄存器 */
+#define SRE_SCH_SCH_ARUSR_M_CTRL_REG         (SRE_SCH_BASE + 0x1E8)     /* SCH AXI读接口USER信息配置寄存器 */
+#define SRE_SCH_SCH_AWUSR_M_CTRL_REG         (SRE_SCH_BASE + 0x1EC)     /* SCH AXI写接口USER信息配置寄存器 */
+#define SRE_SCH_SCH_DYN_CLK_GT_MSK_REG       (SRE_SCH_BASE + 0x1F0)     /* SCH动态时钟门控屏蔽寄存器 */
+#define SRE_SCH_SCH_AXI_STAT_CLR_REG         (SRE_SCH_BASE + 0x1F4)     /* SCH AXI性能统计清零控制寄存器 */
+#define SRE_SCH_SCH_RFS_SP_CFG_REG           (SRE_SCH_BASE + 0x1F8)     /* SCH内部Artisan Memory时序调整控制寄存器 */
+#define SRE_SCH_VMIMO0_INTMSK_REG            (SRE_SCH_BASE + 0x200)     /* cell0 VMIMO 中断屏蔽态寄存器。 */
+#define SRE_SCH_VMIMO0_RINT_REG              (SRE_SCH_BASE + 0x204)     /* cell0 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO0_INTSTS_REG            (SRE_SCH_BASE + 0x208)     /* cell0 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO1_INTMSK_REG            (SRE_SCH_BASE + 0x210)     /* cell1 VMIMO 中断屏蔽寄存器。 */
+#define SRE_SCH_VMIMO1_RINT_REG              (SRE_SCH_BASE + 0x214)     /* cell1 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO1_INTSTS_REG            (SRE_SCH_BASE + 0x218)     /* cell1 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO2_INTMSK_REG            (SRE_SCH_BASE + 0x220)     /* cell2 VMIMO 中屏蔽态寄存器。 */
+#define SRE_SCH_VMIMO2_RINT_REG              (SRE_SCH_BASE + 0x224)     /* cell2 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO2_INTSTS_REG            (SRE_SCH_BASE + 0x228)     /* cell2 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO3_INTMSK_REG            (SRE_SCH_BASE + 0x230)     /* cell3 VMIMO 中断屏蔽态寄存器。 */
+#define SRE_SCH_VMIMO3_RINT_REG              (SRE_SCH_BASE + 0x234)     /* cell3 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO3_INTSTS_REG            (SRE_SCH_BASE + 0x238)     /* cell3 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO4_INTMSK_REG            (SRE_SCH_BASE + 0x240)     /* cell4 VMIMO 中断屏蔽态寄存器。 */
+#define SRE_SCH_VMIMO4_RINT_REG              (SRE_SCH_BASE + 0x244)     /* cell4 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO4_INTSTS_REG            (SRE_SCH_BASE + 0x248)     /* cell4 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO5_INTMSK_REG            (SRE_SCH_BASE + 0x250)     /* cell5 VMIMO 中断屏蔽态寄存器。 */
+#define SRE_SCH_VMIMO5_RINT_REG              (SRE_SCH_BASE + 0x254)     /* cell5 VMIMO 原始中断寄存器。 */
+#define SRE_SCH_VMIMO5_INTSTS_REG            (SRE_SCH_BASE + 0x258)     /* cell5 VMIMO 中断状态寄存器。 */
+#define SRE_SCH_VMIMO0_STS_REG               (SRE_SCH_BASE + 0x300)     /* cell0 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO0_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x304)     /* cell0 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO0_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x308)     /* cell0 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO0_ARFSM_STS_REG         (SRE_SCH_BASE + 0x30C)     /* cell0 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO0_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x310)     /* cell0 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO0_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x314)     /* cell0 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO0_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x318)     /* cell0 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO0_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x31C)     /* cell0 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO0_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x320)     /* cell0 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO0_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x32C)     /* cell0 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO0_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x330)     /* cell0 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO0_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x334)     /* cell0 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO0_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x338)     /* cell0 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO0_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x33C)     /* cell0 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO0_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x340)     /* cell0 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO0_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x344)     /* cell0 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO0_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x348)     /* cell0 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO0_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x34C)     /* cell0 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO0_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x350)     /* cell0 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO0_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x354)     /* cell0 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO0_CAL_FAIL_REG          (SRE_SCH_BASE + 0x358)     /* cell0 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO0_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x35C)     /* cell0 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO0_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x360)     /* cell0 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO0_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x364)     /* cell0 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO0_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x368)     /* cell0 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO1_STS_REG               (SRE_SCH_BASE + 0x380)     /* cell1 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO1_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x384)     /* cell1 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO1_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x388)     /* cell1 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO1_ARFSM_STS_REG         (SRE_SCH_BASE + 0x38C)     /* cell1 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO1_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x390)     /* cell1 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO1_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x394)     /* cell1 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO1_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x398)     /* cell1 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO1_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x39C)     /* cell1 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO1_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x3A0)     /* cell1 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO1_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x3AC)     /* cell1 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO1_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x3B0)     /* cell1 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO1_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x3B4)     /* cell1 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO1_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x3B8)     /* cell1 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO1_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x3BC)     /* cell1 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO1_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x3C0)     /* cell1 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO1_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x3C4)     /* cell1 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO1_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x3C8)     /* cell1 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO1_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x3CC)     /* cell1 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO1_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x3D0)     /* cell1 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO1_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x3D4)     /* cell1 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO1_CAL_FAIL_REG          (SRE_SCH_BASE + 0x3D8)     /* cell1 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO1_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x3DC)     /* cell1 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO1_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x3E0)     /* cell1 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO1_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x3E4)     /* cell1 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO1_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x3E8)     /* cell1 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO2_STS_REG               (SRE_SCH_BASE + 0x400)     /* cell2 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO2_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x404)     /* cell2 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO2_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x408)     /* cell2 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO2_ARFSM_STS_REG         (SRE_SCH_BASE + 0x40C)     /* cell2 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO2_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x410)     /* cell2 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO2_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x414)     /* cell2 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO2_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x418)     /* cell2 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO2_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x41C)     /* cell2 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO2_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x420)     /* cell2 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO2_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x42C)     /* cell2 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO2_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x430)     /* cell2 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO2_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x434)     /* cell2 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO2_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x438)     /* cell2 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO2_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x43C)     /* cell2 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO2_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x440)     /* cell2 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO2_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x444)     /* cell2 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO2_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x448)     /* cell2 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO2_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x44C)     /* cell2 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO2_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x450)     /* cell2 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO2_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x454)     /* cell2 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO2_CAL_FAIL_REG          (SRE_SCH_BASE + 0x458)     /* cell2 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO2_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x45C)     /* cell2 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO2_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x460)     /* cell2 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO2_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x464)     /* cell2 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO2_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x468)     /* cell2 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO3_STS_REG               (SRE_SCH_BASE + 0x480)     /* cell3 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO3_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x484)     /* cell3 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO3_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x488)     /* cell3 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO3_ARFSM_STS_REG         (SRE_SCH_BASE + 0x48C)     /* cell3 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO3_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x490)     /* cell3 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO3_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x494)     /* cell3 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO3_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x498)     /* cell3 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO3_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x49C)     /* cell3 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO3_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x4A0)     /* cell3 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO3_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x4AC)     /* cell3 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO3_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x4B0)     /* cell3 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO3_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x4B4)     /* cell3 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO3_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x4B8)     /* cell3 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO3_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x4BC)     /* cell3 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO3_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x4C0)     /* cell3 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO3_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x4C4)     /* cell3 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO3_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x4C8)     /* cell3 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO3_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x4CC)     /* cell3 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO3_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x4D0)     /* cell3 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO3_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x4D4)     /* cell3 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO3_CAL_FAIL_REG          (SRE_SCH_BASE + 0x4D8)     /* cell3 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO3_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x4DC)     /* cell3 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO3_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x4E0)     /* cell3 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO3_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x4E4)     /* cell3 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO3_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x4E8)     /* cell3 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO4_STS_REG               (SRE_SCH_BASE + 0x500)     /* cell4 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO4_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x504)     /* cell4 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO4_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x508)     /* cell4 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO4_ARFSM_STS_REG         (SRE_SCH_BASE + 0x50C)     /* cell4 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO4_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x510)     /* cell4 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO4_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x514)     /* cell4 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO4_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x518)     /* cell4 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO4_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x51C)     /* cell4 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO4_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x520)     /* cell4 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO4_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x52C)     /* cell4 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO4_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x530)     /* cell4 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO4_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x534)     /* cell4 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO4_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x538)     /* cell4 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO4_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x53C)     /* cell4 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO4_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x540)     /* cell4 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO4_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x544)     /* cell4 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO4_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x548)     /* cell4 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO4_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x54C)     /* cell4 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO4_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x550)     /* cell4 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO4_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x554)     /* cell4 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO4_CAL_FAIL_REG          (SRE_SCH_BASE + 0x558)     /* cell4 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO4_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x55C)     /* cell4 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO4_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x560)     /* cell4 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO4_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x564)     /* cell4 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO4_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x568)     /* cell4 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO5_STS_REG               (SRE_SCH_BASE + 0x580)     /* cell5 VMIMO运算的状态寄存器。 */
+#define SRE_SCH_VMIMO5_RUNTIME_CNT_REG       (SRE_SCH_BASE + 0x584)     /* cell5 VMIMO运行时钟统计 */
+#define SRE_SCH_VMIMO5_ACTIVE_CNT_REG        (SRE_SCH_BASE + 0x588)     /* cell5 VMIMO进行有效计算的时钟统计 */
+#define SRE_SCH_VMIMO5_ARFSM_STS_REG         (SRE_SCH_BASE + 0x58C)     /* cell5 VMIMO产生读DDR的AR的状态机的状态输出 */
+#define SRE_SCH_VMIMO5_ARFSM_CNT_REG         (SRE_SCH_BASE + 0x590)     /* cell5 VMIMO产生读DDR的AR的状态机跳转最大延时统计 */
+#define SRE_SCH_VMIMO5_FNSHED_RB_CNT_REG     (SRE_SCH_BASE + 0x594)     /* cell5 VMIMO计算完成的RB数目统计 */
+#define SRE_SCH_VMIMO5_FNSHED_USRPAIR_CNT_REG  (SRE_SCH_BASE + 0x598)     /* cell5 VMIMO计算完成的用户对数目统计 */
+#define SRE_SCH_VMIMO5_FNSHED_USRU_CNT_REG   (SRE_SCH_BASE + 0x59C)     /* cell5 VMIMO计算完成的U用户数目统计 */
+#define SRE_SCH_VMIMO5_FNSHED_USRV_CNT_REG   (SRE_SCH_BASE + 0x5A0)     /* cell5 VMIMO计算完成的V用户数目统计 */
+#define SRE_SCH_VMIMO5_ERR_ARADDR_REG        (SRE_SCH_BASE + 0x5AC)     /* cell5 VMIMO产生ERROR响应的读地址请求中读地址 */
+#define SRE_SCH_VMIMO5_ERR_AWADDR_REG        (SRE_SCH_BASE + 0x5B0)     /* cell5 VMIMO产生ERROR响应的写地址请求中写地址 */
+#define SRE_SCH_VMIMO5_CURR_USRU_ID_REG      (SRE_SCH_BASE + 0x5B4)     /* cell5 VMIMO当前运行的U用户ID */
+#define SRE_SCH_VMIMO5_CURR_USRV_ID_REG      (SRE_SCH_BASE + 0x5B8)     /* cell5 VMIMO当前运行的V用户ID */
+#define SRE_SCH_VMIMO5_CURR_ERR_RBINFO_REG   (SRE_SCH_BASE + 0x5BC)     /* cell5 VMIMO当前运行的发生RB配置错误的U用户的RB信息 */
+#define SRE_SCH_VMIMO5_UNALIGNED_CHDADDR_CNT_REG  (SRE_SCH_BASE + 0x5C0)     /* cell5 VMIMO中信道响应矩阵的DDR首地址非cacheline对齐的个数统计 */
+#define SRE_SCH_VMIMO5_UINFO_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x5C4)     /* cell5 VMIMO中U_INFO_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO5_NPWR_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x5C8)     /* cell5 VMIMO中NPWR_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO5_VCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x5CC)     /* cell5 VMIMO中V_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO5_UCHD_SRAM_ERR_CNT_REG  (SRE_SCH_BASE + 0x5D0)     /* cell5 VMIMO中U_CHDT_SRAM奇偶校验错误个数统计 */
+#define SRE_SCH_VMIMO5_CURR_RBERR_U_ID_REG   (SRE_SCH_BASE + 0x5D4)     /* cell5 VMIMO当前运行的发生RB配置错误的U用户ID */
+#define SRE_SCH_VMIMO5_CAL_FAIL_REG          (SRE_SCH_BASE + 0x5D8)     /* cell5 VMIMO计算失败指示 */
+#define SRE_SCH_VMIMO5_UINFO_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x5DC)     /* cell5 VMIMO中U_INFO_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO5_NPWR_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x5E0)     /* cell5 VMIMO中NPWR_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO5_VCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x5E4)     /* cell5 VMIMO中V_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_VMIMO5_UCHD_SRAM_ERR_ADDR_REG  (SRE_SCH_BASE + 0x5E8)     /* cell5 VMIMO中U_CHDT_SRAM第一次奇偶校验错误的地址 */
+#define SRE_SCH_SCH_AXI_WR_LATENCY_AVG_STAT_REG  (SRE_SCH_BASE + 0x600)     /* SCH AXI总线写通道平均时延统计 */
+#define SRE_SCH_SCH_AXI_RD_LATENCY_AVG_STAT_REG  (SRE_SCH_BASE + 0x604)     /* SCH AXI总线读通道平均时延统计 */
+#define SRE_SCH_SCH_AXI_WR_LATENCY_MAX_STAT_REG  (SRE_SCH_BASE + 0x608)     /* SCH AXI总线写通道最大时延统计 */
+#define SRE_SCH_SCH_AXI_RD_LATENCY_MAX_STAT_REG  (SRE_SCH_BASE + 0x60C)     /* SCH AXI总线读通道最大时延统计 */
+#define SRE_SCH_SCH_AXI_WR_ACC_STAT_REG      (SRE_SCH_BASE + 0x610)     /* SCH AXI总线写通道发出的写命令次数统计 */
+#define SRE_SCH_SCH_AXI_RD_ACC_STAT_REG      (SRE_SCH_BASE + 0x614)     /* SCH AXI总线读通道发出的读命令次数统计 */
+#define SRE_SCH_SCH_AXI_RCHN0_OTSD_CNT_REG   (SRE_SCH_BASE + 0x618)     /* SCH AXI 读通道0 outstanding统计 */
+#define SRE_SCH_SCH_AXI_RCHN1_OTSD_CNT_REG   (SRE_SCH_BASE + 0x61C)     /* SCH AXI 读通道1 outstanding统计 */
+#define SRE_SCH_SCH_AXI_RCHN2_OTSD_CNT_REG   (SRE_SCH_BASE + 0x620)     /* SCH AXI 读通道2 outstanding统计 */
+#define SRE_SCH_SCH_AXI_RCHN3_OTSD_CNT_REG   (SRE_SCH_BASE + 0x624)     /* SCH AXI 读通道3 outstanding统计 */
+#define SRE_SCH_SCH_AXI_RCHN4_OTSD_CNT_REG   (SRE_SCH_BASE + 0x628)     /* SCH AXI 读通道4 outstanding统计 */
+#define SRE_SCH_SCH_AXI_RCHN5_OTSD_CNT_REG   (SRE_SCH_BASE + 0x62C)     /* SCH AXI 读通道5 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN0_OTSD_CNT_REG   (SRE_SCH_BASE + 0x630)     /* SCH AXI 写通道0 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN1_OTSD_CNT_REG   (SRE_SCH_BASE + 0x634)     /* SCH AXI 写通道1 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN2_OTSD_CNT_REG   (SRE_SCH_BASE + 0x638)     /* SCH AXI 写通道2 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN3_OTSD_CNT_REG   (SRE_SCH_BASE + 0x63C)     /* SCH AXI 写通道3 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN4_OTSD_CNT_REG   (SRE_SCH_BASE + 0x640)     /* SCH AXI 写通道4 outstanding统计 */
+#define SRE_SCH_SCH_AXI_WCHN5_OTSD_CNT_REG   (SRE_SCH_BASE + 0x644)     /* SCH AXI 写通道5 outstanding统计 */
+#define SRE_SCH_SCH_CFG_RSV0_REG             (SRE_SCH_BASE + 0x700)     /* SCH 配置保留寄存器0 */
+#define SRE_SCH_SCH_CFG_RSV1_REG             (SRE_SCH_BASE + 0x704)     /* SCH 配置保留寄存器1 */
+#define SRE_SCH_SCH_CFG_RSV2_REG             (SRE_SCH_BASE + 0x708)     /* SCH 配置保留寄存器2 */
+#define SRE_SCH_SCH_STS_RSV0_REG             (SRE_SCH_BASE + 0x720)     /* SCH 状态保留寄存器0 */
+#define SRE_SCH_SCH_STS_RSV1_REG             (SRE_SCH_BASE + 0x724)     /* SCH 状态保留寄存器1 */
+#define SRE_SCH_SCH_STS_RSV2_REG             (SRE_SCH_BASE + 0x728)     /* SCH 状态保留寄存器2 */
+
+
+
+/******************************************************************************/
+/*                      PhosphorV600 SYSCTRL nManager 寄存器定义              */
+/******************************************************************************/
+#if 0         /* z00202052 */
+#define SRE_SYS_REG_BASEADDR         (0x13e00000) /* SYSCTRL nManager的寄存器基地址 */
+#else
+#define SRE_SYS_REG_BASEADDR         (0xe3e00000) /* SYSCTRL nManager的寄存器基地址 */
+#endif        /* z00202052 */
+#define SRE_SYS_REG_A9_0_1_INT       (SRE_SYS_REG_BASEADDR + 0x0500) /* A9_0发送到A9_1的中断地址 */
+
+#define SRE_SYS_PERCTRL6_REG         (SRE_SYS_REG_BASEADDR + 0x44)   /*外设控制寄存器6*/
+#define SRE_SYS_PERCTRL7_REG         (SRE_SYS_REG_BASEADDR + 0x48)   /*外设控制寄存器7*/
+#define SRE_SYS_PERCTRL8_REG         (SRE_SYS_REG_BASEADDR + 0x4C)   /*外设控制寄存器8*/
+#define SRE_SYS_PERCTRL9_REG         (SRE_SYS_REG_BASEADDR + 0x50)   /*外设控制寄存器9*/
+#define SRE_SYS_PERCTRL10_REG        (SRE_SYS_REG_BASEADDR + 0x54)   /*外设控制寄存器10*/
+#define SRE_SYS_PERCTRL15_REG        (SRE_SYS_REG_BASEADDR + 0x68)   /*外设控制寄存器10*/
+
+#define SRE_SYS_PERCTRL33_REG        (SRE_SYS_REG_BASEADDR + 0xB0)   /* 外设控制寄存器 33 */
+#define SRE_SYS_PERCTRL34_REG        (SRE_SYS_REG_BASEADDR + 0xB4)   /* 外设控制寄存器 34 */
+#define SRE_SYS_PERCTRL37_REG        (SRE_SYS_REG_BASEADDR + 0xC0)   /* 外设控制寄存器 37 */
+#define SRE_SYS_PERCTRL38_REG        (SRE_SYS_REG_BASEADDR + 0xC4)   /* 外设控制寄存器 38 */
+#define SRE_SYS_PERCTRL41_REG        (SRE_SYS_REG_BASEADDR + 0xD0)   /* 外设控制寄存器 41 */
+#define SRE_SYS_PERCTRL42_REG        (SRE_SYS_REG_BASEADDR + 0xD4)   /* 外设控制寄存器 42 */
+#define SRE_SYS_PERCTRL45_REG        (SRE_SYS_REG_BASEADDR + 0xE0)   /* 外设控制寄存器 45 */
+#define SRE_SYS_PERCTRL46_REG        (SRE_SYS_REG_BASEADDR + 0xE4)   /* 外设控制寄存器 46 */
+
+#define SRE_SYS_PERCTRL50_REG        (SRE_SYS_REG_BASEADDR + 0xF4)   /* 外设控制寄存器 50 */
+#define SRE_SYS_PERCTRL51_REG        (SRE_SYS_REG_BASEADDR + 0xF8)   /* 外设控制寄存器 51 */
+#define SRE_SYS_PERCTRL52_REG        (SRE_SYS_REG_BASEADDR + 0xFC)   /* 外设控制寄存器 52 */
+#define SRE_SYS_PERCTRL69_REG        (SRE_SYS_REG_BASEADDR + 0x140)   /* 外设控制寄存器 69 */
+#define SRE_SYS_EXTSTATUS1_REG       (SRE_SYS_REG_BASEADDR + 0x40C)   /* 扩展状态寄存器1 */
+#define SRE_SYS_EXTSTATUS2_REG       (SRE_SYS_REG_BASEADDR + 0x410)   /* 扩展状态寄存器2 */
+#define SRE_SYS_EXTSTATUS3_REG       (SRE_SYS_REG_BASEADDR + 0x414)   /* 扩展状态寄存器3 */
+
+#define SRE_SYSSTAT6_REG             (SRE_SYS_REG_BASEADDR + 0x420)   /* 扩展系统状态寄存器6，SerDes 0 bist状态 */
+#define SRE_SYSSTAT7_REG             (SRE_SYS_REG_BASEADDR + 0x424)   /* 扩展系统状态寄存器6，SerDes 1 bist状态 */
+
+#define SRE_SYS_EXTSTATUS17_REG      (SRE_SYS_REG_BASEADDR + 0x44C)   /* 扩展状态寄存器17 */
+#define SRE_SYS_DBGREQ_REG           (SRE_SYS_REG_BASEADDR + 0x5E0)   /* A0 DBG寄存器 */
+
+#define SRE_SYS_SEC_RESET_REQ_REG    (SRE_SYS_REG_BASEADDR + 0x0708)  /* SEC软复位请求控制寄存器  */
+#define SRE_SYS_SEC_RESET_DREQ_REG   (SRE_SYS_REG_BASEADDR + 0x070C)  /* SEC软复位去请求控制寄存器 */
+
+#define SRE_SYS_HDCP_RESET_REQ_REG   (SRE_SYS_REG_BASEADDR + 0x0748)  /* hdcp软复位请求控制寄存器  */
+#define SRE_SYS_HDCP_RESET_DREQ_REG  (SRE_SYS_REG_BASEADDR + 0x074C)  /* hdcp软复位去请求控制寄存器 */
+
+
+/* BEGIN: Added by h00176630, 2012/6/9 */
+#define SRE_SC_CTRL_REG                  (SRE_SYS_REG_BASEADDR + 0x0)       /* SC_CTRL为系统控制寄存器。 */
+#define SRE_SC_SYSRST_REG                (SRE_SYS_REG_BASEADDR + 0x4)       /* SC_SYSSTAT为系统软复位寄存器。 */
+#define SRE_SC_IMCTRL_REG                (SRE_SYS_REG_BASEADDR + 0x8)       /* SC_IMCTRL为中断模式控制寄存器（保留）。 */
+#define SRE_SC_IMSTAT_REG                (SRE_SYS_REG_BASEADDR + 0xC)       /* SC_IMSTAT为中断模式状态寄存器（保留）。 */
+#define SRE_SC_XTALCTRL_REG              (SRE_SYS_REG_BASEADDR + 0x10)      /* SC_XTALCTRL为晶振控制寄存器。 */
+#define SRE_SC_PLLCTRL_REG               (SRE_SYS_REG_BASEADDR + 0x14)      /* SC_PLLCTRL为PLL控制寄存器。 */
+#define SRE_SC_DBG_AUTH_CTRL_REG         (SRE_SYS_REG_BASEADDR + 0x20)      /* 调试模式安全等级授权控制。（注意：1，此寄存器空间必须是安全访问才能成功；2，默认均是打开调试模式，有漏洞，在正常工作时请初始化关闭调试功能） */
+#define SRE_SC_PLLFCTRL0_REG             (SRE_SYS_REG_BASEADDR + 0x100)     /* SC_PLLFCTRL0为PLL0控制寄存器0。 */
+#define SRE_SC_PLLFCTRL1_REG             (SRE_SYS_REG_BASEADDR + 0x104)     /* SC_PLLFCTRL1为PLL0控制寄存器1。 */
+#define SRE_SC_PLLFCTRL2_REG             (SRE_SYS_REG_BASEADDR + 0x108)     /* SC_PLLFCTRL2为PLL1控制寄存器0。 */
+#define SRE_SC_PLLFCTRL3_REG             (SRE_SYS_REG_BASEADDR + 0x10C)     /* SC_PLLFCTRL3为PLL1控制寄存器1。 */
+#define SRE_SC_PLLFCTRL4_REG             (SRE_SYS_REG_BASEADDR + 0x110)     /* SC_PLLFCTRL4为PLL2控制寄存器0。 */
+#define SRE_SC_PLLFCTRL5_REG             (SRE_SYS_REG_BASEADDR + 0x114)     /* SC_PLLFCTRL5为PLL2控制寄存器1。 */
+#define SRE_SC_PLLFCTRL6_REG             (SRE_SYS_REG_BASEADDR + 0x118)     /* SC_PLLFCTRL6为PLL3控制寄存器0。 */
+#define SRE_SC_PLLFCTRL7_REG             (SRE_SYS_REG_BASEADDR + 0x11C)     /* SC_PLLFCTRL7为PLL3控制寄存器1。 */
+#define SRE_SC_PLLFCTRL8_REG             (SRE_SYS_REG_BASEADDR + 0x120)     /* SC_PLLFCTRL8为PLL4控制寄存器0。 */
+#define SRE_SC_PLLFCTRL9_REG             (SRE_SYS_REG_BASEADDR + 0x124)     /* SC_PLLFCTRL9为PLL4控制寄存器1。 */
+#define SRE_SC_PLL_CLK_BYPASS_REG        (SRE_SYS_REG_BASEADDR + 0x180)     /* PLL相关工作时钟选择 */
+#define SRE_SC_CLK_SEL0_REG              (SRE_SYS_REG_BASEADDR + 0x188)     /* 处理器和系统互联时钟频率选择 */
+#define SRE_SC_CLK_SEL1_REG              (SRE_SYS_REG_BASEADDR + 0x18C)     /* 网口MAC时钟频率选择 */
+#define SRE_SC_CLK_SEL2_REG              (SRE_SYS_REG_BASEADDR + 0x190)     /* 硬件加速器工作时钟频率选择 */
+#define SRE_SC_CLK_SEL3_REG              (SRE_SYS_REG_BASEADDR + 0x194)     /* 低速外设接口工作时钟选择 */
+#define SRE_SC_TOP_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x200)     /* 顶层全局时钟使能控制 */
+#define SRE_SC_TOP_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x204)     /* 顶层全局时钟关闭控制 */
+#define SRE_SC_CPU_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x220)     /* 保留 */
+#define SRE_SC_CPU_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x224)     /* 保留 */
+#define SRE_SC_SERDES_CLK_EN_REG         (SRE_SYS_REG_BASEADDR + 0x280)     /* 保留 */
+#define SRE_SC_SERDES_CLK_DIS_REG        (SRE_SYS_REG_BASEADDR + 0x284)     /* 保留 */
+#define SRE_SC_GE_CLK_EN_REG             (SRE_SYS_REG_BASEADDR + 0x2A0)     /* GE时钟使能寄存器 */
+#define SRE_SC_GE_CLK_DIS_REG            (SRE_SYS_REG_BASEADDR + 0x2A4)     /* GE时钟禁止寄存器 */
+#define SRE_SC_XGE_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x2B0)     /* XGE时钟使能寄存器 */
+#define SRE_SC_XGE_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x2B4)     /* XGE时钟禁止寄存器 */
+#define SRE_SC_PCIE_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x2E0)     /* PCIE时钟使能寄存器 */
+#define SRE_SC_PCIE_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x2E4)     /* PCIE时钟禁止寄存器 */
+#define SRE_SC_SRIO_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x2F0)     /* SRIO时钟使能寄存器 */
+#define SRE_SC_SRIO_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x2F4)     /* SRIO时钟禁止寄存器 */
+#define SRE_SC_USB_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x300)     /* USB时钟使能寄存器 */
+#define SRE_SC_USB_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x304)     /* USB时钟禁止寄存器 */
+#define SRE_SC_SATA_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x310)     /* SATA时钟使能寄存器 */
+#define SRE_SC_SATA_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x314)     /* SATA时钟禁止寄存器 */
+#define SRE_SC_DDR_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x320)     /* DDR时钟使能寄存器 */
+#define SRE_SC_DDR_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x324)     /* DDR时钟禁止寄存器 */
+#define SRE_SC_MMC_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x330)     /* MMC时钟使能寄存器 */
+#define SRE_SC_MMC_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x334)     /* MMC时钟禁止寄存器 */
+#define SRE_SC_SFC_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x338)     /* SFC时钟使能寄存器 */
+#define SRE_SC_SFC_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x33C)     /* SFC时钟禁止寄存器 */
+#define SRE_SC_NANDC_CLK_EN_REG          (SRE_SYS_REG_BASEADDR + 0x340)     /* NANDC时钟使能寄存器 */
+#define SRE_SC_NANDC_CLK_DIS_REG         (SRE_SYS_REG_BASEADDR + 0x344)     /* NANDC时钟禁止寄存器 */
+#define SRE_SC_LOCALBUS_CLK_EN_REG       (SRE_SYS_REG_BASEADDR + 0x350)     /* LOCALBUS时钟使能寄存器 */
+#define SRE_SC_LOCALBUS_CLK_DIS_REG      (SRE_SYS_REG_BASEADDR + 0x354)     /* LOCALBUS时钟禁止寄存器 */
+#define SRE_SC_UART_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x380)     /* UART时钟使能寄存器 */
+#define SRE_SC_UART_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x384)     /* UART时钟禁止寄存器 */
+#define SRE_SC_I2C_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x388)     /* I2C时钟使能寄存器 */
+#define SRE_SC_I2C_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x38C)     /* I2C时钟禁止寄存器 */
+#define SRE_SC_MDIO_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x390)     /* MDIO时钟使能寄存器 */
+#define SRE_SC_MDIO_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x394)     /* MDIO时钟禁止寄存器 */
+#define SRE_SC_SPI_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x398)     /* SPI时钟使能寄存器 */
+#define SRE_SC_SPI_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x39C)     /* SPI时钟禁止寄存器 */
+#define SRE_SC_GPIO_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x3A0)     /* GPIO时钟使能寄存器 */
+#define SRE_SC_GPIO_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x3A4)     /* GPIO时钟禁止寄存器 */
+#define SRE_SC_TDM_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x3C0)     /* TDM时钟使能寄存器 */
+#define SRE_SC_TDM_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x3C4)     /* TDM时钟禁止寄存器 */
+#define SRE_SC_HDLC_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x3C8)     /* HDLC时钟使能寄存器 */
+#define SRE_SC_HDLC_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x3CC)     /* HDLC时钟禁止寄存器 */
+#define SRE_SC_BOOTROM_CLK_EN_REG        (SRE_SYS_REG_BASEADDR + 0x400)     /* BOOTROM时钟使能寄存器 */
+#define SRE_SC_BOOTROM_CLK_DIS_REG       (SRE_SYS_REG_BASEADDR + 0x404)     /* BOOTROM时钟禁止寄存器 */
+#define SRE_SC_SEC_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x408)     /* SEC时钟使能寄存器 */
+#define SRE_SC_SEC_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x40C)     /* SEC时钟禁止寄存器 */
+#define SRE_SC_POE_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x410)     /* POE时钟使能寄存器 */
+#define SRE_SC_POE_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x414)     /* POE时钟禁止寄存器 */
+#define SRE_SC_BMU_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x418)     /* BMU时钟使能寄存器 */
+#define SRE_SC_BMU_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x41C)     /* BMU时钟禁止寄存器 */
+#define SRE_SC_PPE_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x420)     /* PPE时钟使能寄存器 */
+#define SRE_SC_PPE_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x424)     /* PPE时钟禁止寄存器 */
+#define SRE_SC_NP_CLK_EN_REG             (SRE_SYS_REG_BASEADDR + 0x428)     /* SPPE时钟使能寄存器 */
+#define SRE_SC_NP_CLK_DIS_REG            (SRE_SYS_REG_BASEADDR + 0x42C)     /* SPPE时钟禁止寄存器 */
+#define SRE_SC_CRC_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x430)     /* CRC时钟使能寄存器 */
+#define SRE_SC_CRC_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x434)     /* CRC时钟禁止寄存器 */
+#define SRE_SC_DMAC_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x438)     /* DMAC时钟使能寄存器 */
+#define SRE_SC_DMAC_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x43C)     /* DMAC时钟禁止寄存器 */
+#define SRE_SC_ROHC_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x440)     /* ROHC时钟使能寄存器 */
+#define SRE_SC_ROHC_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x444)     /* ROHC时钟禁止寄存器 */
+#define SRE_SC_HDCP_CLK_EN_REG           (SRE_SYS_REG_BASEADDR + 0x448)     /* HDCP时钟使能寄存器 */
+#define SRE_SC_HDCP_CLK_DIS_REG          (SRE_SYS_REG_BASEADDR + 0x44C)     /* HDCP时钟禁止寄存器 */
+#define SRE_SC_PDM_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x450)     /* PDM时钟使能寄存器 */
+#define SRE_SC_PDM_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x454)     /* PDM时钟禁止寄存器 */
+#define SRE_SC_TRING_CLK_EN_REG          (SRE_SYS_REG_BASEADDR + 0x458)     /* TRING时钟使能寄存器 */
+#define SRE_SC_TRING_CLK_DIS_REG         (SRE_SYS_REG_BASEADDR + 0x45C)     /* TRING时钟禁止寄存器 */
+#define SRE_SC_RNG_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x460)     /* RNG时钟使能寄存器 */
+#define SRE_SC_RNG_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x464)     /* RNG时钟禁止寄存器 */
+#define SRE_SC_IMA_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x468)     /* IMA时钟使能寄存器 */
+#define SRE_SC_IMA_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x46C)     /* IMA时钟禁止寄存器 */
+#define SRE_SC_SCH_CLK_EN_REG            (SRE_SYS_REG_BASEADDR + 0x470)     /* SCH时钟使能寄存器 */
+#define SRE_SC_SCH_CLK_DIS_REG           (SRE_SYS_REG_BASEADDR + 0x474)     /* SCH时钟禁止寄存器 */
+#define SRE_SC_TM_CLK_EN_REG             (SRE_SYS_REG_BASEADDR + 0x478)     /* TM时钟使能寄存器 */
+#define SRE_SC_TM_CLK_DIS_REG            (SRE_SYS_REG_BASEADDR + 0x47C)     /* TM时钟禁止寄存器 */
+#define SRE_SC_IO_H2X_BRG_WFQCFG_REG     (SRE_SYS_REG_BASEADDR + 0x4A0)
+#define SRE_SC_IO_H2X_BRG_CTRL_REG       (SRE_SYS_REG_BASEADDR + 0x4A4)
+#define SRE_SC_IO_H2X_BRG_STATCFG_REG    (SRE_SYS_REG_BASEADDR + 0x4A8)
+#define SRE_SC_ALG_H2X_BRG_WFQCFG_REG    (SRE_SYS_REG_BASEADDR + 0x4B0)
+#define SRE_SC_ALG_H2X_BRG_CTRL_REG      (SRE_SYS_REG_BASEADDR + 0x4B4)
+#define SRE_SC_ALG_H2X_BRG_STATCFG_REG   (SRE_SYS_REG_BASEADDR + 0x4B8)
+#define SRE_SC_TOP_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x500)     /* 顶层CRG软复位请求控制寄存器 */
+#define SRE_SC_TOP_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x504)     /* 顶层CRG软复位去请求控制寄存器 */
+#define SRE_SC_CPU_RESET_REQ0_REG        (SRE_SYS_REG_BASEADDR + 0x520)     /* Cluster0内部软复位请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_DREQ0_REG       (SRE_SYS_REG_BASEADDR + 0x524)     /* Cluster0内部软复位去请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_REQ1_REG        (SRE_SYS_REG_BASEADDR + 0x528)     /* Cluster1内部软复位请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_DREQ1_REG       (SRE_SYS_REG_BASEADDR + 0x52C)     /* Cluster1内部软复位去请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_REQ2_REG        (SRE_SYS_REG_BASEADDR + 0x530)     /* Cluster2内部软复位请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_DREQ2_REG       (SRE_SYS_REG_BASEADDR + 0x534)     /* Cluster2内部软复位去请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_REQ3_REG        (SRE_SYS_REG_BASEADDR + 0x538)     /* Cluster3内部软复位请求控制寄存器。 */
+#define SRE_SC_CPU_RESET_DREQ3_REG       (SRE_SYS_REG_BASEADDR + 0x53C)     /* Cluster3内部软复位去请求控制寄存器。 */
+#define SRE_SC_CACHE_RESET_REQ_REG       (SRE_SYS_REG_BASEADDR + 0x560)     /* l3cache软复位请求控制寄存器 */
+#define SRE_SC_CACHE_RESET_DREQ_REG      (SRE_SYS_REG_BASEADDR + 0x564)     /* l3cache软复位去请求控制寄存器 */
+#define SRE_SC_SERDES_RESET_REQ0_REG     (SRE_SYS_REG_BASEADDR + 0x580)     /* Serdes软复位请求控制寄存器1 */
+#define SRE_SC_SERDES_RESET_DREQ0_REG    (SRE_SYS_REG_BASEADDR + 0x584)     /* Serdes软复位去请求控制寄存器1 */
+#define SRE_SC_SERDES_RESET_REQ1_REG     (SRE_SYS_REG_BASEADDR + 0x588)     /* Serdes软复位请求控制寄存器2 */
+#define SRE_SC_SERDES_RESET_DREQ1_REG    (SRE_SYS_REG_BASEADDR + 0x58C)     /* Serdes软复位去请求控制寄存器2 */
+#define SRE_SC_SERDES_RESET_REQ2_REG     (SRE_SYS_REG_BASEADDR + 0x590)     /* Serdes软复位请求控制寄存器3 */
+#define SRE_SC_SERDES_RESET_DREQ2_REG    (SRE_SYS_REG_BASEADDR + 0x594)     /* Serdes软复位去请求控制寄存器3 */
+#define SRE_SC_GE_RESET_REQ_REG          (SRE_SYS_REG_BASEADDR + 0x5A0)     /* GE软复位请求控制寄存器 */
+#define SRE_SC_GE_RESET_DREQ_REG         (SRE_SYS_REG_BASEADDR + 0x5A4)     /* GE软复位去请求控制寄存器 */
+#define SRE_SC_XGE_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x5B0)     /* XGE软复位请求控制寄存器 */
+#define SRE_SC_XGE_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x5B4)     /* XGE软复位去请求控制寄存器 */
+#define SRE_SC_MAC_CFG_RESET_REQ_REG     (SRE_SYS_REG_BASEADDR + 0x5C0)     /* MAC配置软复位请求控制寄存器 */
+#define SRE_SC_MAC_CFG_RESET_DREQ_REG    (SRE_SYS_REG_BASEADDR + 0x5C4)     /* MAC配置软复位去请求控制寄存器 */
+#define SRE_SC_MAC_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x5C8)     /* MAC软复位请求控制寄存器 */
+#define SRE_SC_MAC_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x5CC)     /* MAC软复位去请求控制寄存器 */
+#define SRE_SC_PCIE_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x5E0)     /* PCIE软复位请求控制寄存器 */
+#define SRE_SC_PCIE_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x5E4)     /* PCIE软复位去请求控制寄存器 */
+#define SRE_SC_SRIO_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x5F0)     /* SRIO软复位请求控制寄存器 */
+#define SRE_SC_SRIO_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x5F4)     /* SRIO软复位去请求控制寄存器 */
+#define SRE_SC_USB_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x600)     /* USB软复位请求控制寄存器 */
+#define SRE_SC_USB_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x604)     /* USB软复位去请求控制寄存器 */
+#define SRE_SC_DDR_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x620)     /* DDR软复位请求控制寄存器 */
+#define SRE_SC_DDR_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x624)     /* DDR软复位去请求控制寄存器 */
+#define SRE_SC_MMC_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x630)     /* MMC软复位请求控制寄存器 */
+#define SRE_SC_MMC_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x634)     /* MMC软复位去请求控制寄存器 */
+#define SRE_SC_SFC_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x638)     /* SFC软复位请求控制寄存器 */
+#define SRE_SC_SFC_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x63C)     /* SFC软复位去请求控制寄存器 */
+#define SRE_SC_NANDC_RESET_REQ_REG       (SRE_SYS_REG_BASEADDR + 0x640)     /* NANDC软复位请求控制寄存器 */
+#define SRE_SC_NANDC_RESET_DREQ_REG      (SRE_SYS_REG_BASEADDR + 0x644)     /* NANDC软复位去请求控制寄存器 */
+#define SRE_SC_LOCALBUS_RESET_REQ_REG    (SRE_SYS_REG_BASEADDR + 0x650)     /* LOCALBUS软复位请求控制寄存器 */
+#define SRE_SC_LOCALBUS_RESET_DREQ_REG   (SRE_SYS_REG_BASEADDR + 0x654)     /* LOCALBUS软复位去请求控制寄存器 */
+#define SRE_SC_UART_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x680)     /* UART软复位请求控制寄存器 */
+#define SRE_SC_UART_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x684)     /* UART软复位去请求控制寄存器 */
+#define SRE_SC_I2C_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x688)     /* I2C软复位请求控制寄存器 */
+#define SRE_SC_I2C_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x68C)     /* I2C软复位去请求控制寄存器 */
+#define SRE_SC_MDIO_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x690)     /* MDIO软复位请求控制寄存器 */
+#define SRE_SC_MDIO_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x694)     /* MDIO软复位去请求控制寄存器 */
+#define SRE_SC_SPI_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x698)     /* SPI软复位请求控制寄存器 */
+#define SRE_SC_SPI_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x69C)     /* SPI软复位去请求控制寄存器 */
+#define SRE_SC_GPIO_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x6A0)     /* GPIO软复位请求控制寄存器 */
+#define SRE_SC_GPIO_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x6A4)     /* GPIO软复位去请求控制寄存器 */
+#define SRE_SC_TDM_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x6C0)     /* TDM软复位请求控制寄存器 */
+#define SRE_SC_TDM_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x6C4)     /* TDM软复位去请求控制寄存器 */
+#define SRE_SC_HDLC_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x6C8)     /* HDLC软复位请求控制寄存器 */
+#define SRE_SC_HDLC_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x6CC)     /* HDLC软复位去请求控制寄存器 */
+#define SRE_SC_BOOTROM_RESET_REQ_REG     (SRE_SYS_REG_BASEADDR + 0x700)     /* BOOTROM软复位请求控制寄存器 */
+#define SRE_SC_BOOTROM_RESET_DREQ_REG    (SRE_SYS_REG_BASEADDR + 0x704)     /* BOOTROM软复位去请求控制寄存器 */
+#define SRE_SC_SEC_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x708)     /* SEC软复位请求控制寄存器 */
+#define SRE_SC_SEC_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x70C)     /* SEC软复位去请求控制寄存器 */
+#define SRE_SC_POE_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x710)     /* POE软复位请求控制寄存器 */
+#define SRE_SC_POE_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x714)     /* POE软复位去请求控制寄存器 */
+#define SRE_SC_BMU_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x718)     /* BMU软复位请求控制寄存器 */
+#define SRE_SC_BMU_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x71C)     /* BMU软复位去请求控制寄存器 */
+#define SRE_SC_PPE_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x720)     /* PPE软复位请求控制寄存器 */
+#define SRE_SC_PPE_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x724)     /* PPE软复位去请求控制寄存器 */
+#define SRE_SC_NP_RESET_REQ_REG          (SRE_SYS_REG_BASEADDR + 0x728)     /* SPPE软复位请求控制寄存器 */
+#define SRE_SC_NP_RESET_DREQ_REG         (SRE_SYS_REG_BASEADDR + 0x72C)     /* SPPE软复位去请求控制寄存器 */
+#define SRE_SC_CRC_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x730)     /* CRC软复位请求控制寄存器 */
+#define SRE_SC_CRC_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x734)     /* CRC软复位去请求控制寄存器 */
+#define SRE_SC_DMAC_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x738)     /* DMAC软复位请求控制寄存器 */
+#define SRE_SC_DMAC_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x73C)     /* DMAC软复位去请求控制寄存器 */
+#define SRE_SC_ROHC_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x740)     /* ROHC软复位请求控制寄存器 */
+#define SRE_SC_ROHC_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x744)     /* ROHC软复位去请求控制寄存器 */
+#define SRE_SC_HDCP_RESET_REQ_REG        (SRE_SYS_REG_BASEADDR + 0x748)     /* HDCP软复位请求控制寄存器 */
+#define SRE_SC_HDCP_RESET_DREQ_REG       (SRE_SYS_REG_BASEADDR + 0x74C)     /* HDCP软复位去请求控制寄存器 */
+#define SRE_SC_PDM_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x750)     /* PDM软复位请求控制寄存器 */
+#define SRE_SC_PDM_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x754)     /* PDM软复位去请求控制寄存器 */
+#define SRE_SC_TRING_RESET_REQ_REG       (SRE_SYS_REG_BASEADDR + 0x758)     /* TRING软复位请求控制寄存器 */
+#define SRE_SC_TRING_RESET_DREQ_REG      (SRE_SYS_REG_BASEADDR + 0x75C)     /* TRING软复位去请求控制寄存器 */
+#define SRE_SC_RNG_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x760)     /* RNG软复位请求控制寄存器 */
+#define SRE_SC_RNG_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x764)     /* RNG软复位去请求控制寄存器 */
+#define SRE_SC_IMA_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x768)     /* IMA软复位请求控制寄存器 */
+#define SRE_SC_IMA_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x76C)     /* IMA软复位去请求控制寄存器 */
+#define SRE_SC_SCH_RESET_REQ_REG         (SRE_SYS_REG_BASEADDR + 0x770)     /* SCH软复位请求控制寄存器 */
+#define SRE_SC_SCH_RESET_DREQ_REG        (SRE_SYS_REG_BASEADDR + 0x774)     /* SCH软复位去请求控制寄存器 */
+#define SRE_SC_TM_RESET_REQ_REG          (SRE_SYS_REG_BASEADDR + 0x778)     /* TM软复位请求控制寄存器 */
+#define SRE_SC_TM_RESET_DREQ_REG         (SRE_SYS_REG_BASEADDR + 0x77c)     /* TM软复位去请求控制寄存器 */
+#define SRE_SC_FUNC_MBIST_MODE_CFG_REG   (SRE_SYS_REG_BASEADDR + 0x800)
+#define SRE_SC_FUNC_MBIST_CTRL_CFG_REG   (SRE_SYS_REG_BASEADDR + 0x804)
+#define SRE_SC_FUNC_MBIST_MEM_CFG_REG    (SRE_SYS_REG_BASEADDR + 0x808)
+#define SRE_SC_FUNC_MBIST_EN0_REG        (SRE_SYS_REG_BASEADDR + 0x810)
+#define SRE_SC_FUNC_MBIST_EN1_REG        (SRE_SYS_REG_BASEADDR + 0x814)
+#define SRE_SC_TCAM_MBIST_EN_REG         (SRE_SYS_REG_BASEADDR + 0x820)
+#define SRE_SC_CPU_CTRL0_REG             (SRE_SYS_REG_BASEADDR + 0x900)
+#define SRE_SC_CPU_CTRL1_REG             (SRE_SYS_REG_BASEADDR + 0x904)
+#define SRE_SC_CPU_CTRL2_REG             (SRE_SYS_REG_BASEADDR + 0x908)
+#define SRE_SC_CPU_CTRL3_REG             (SRE_SYS_REG_BASEADDR + 0x90C)
+#define SRE_SC_CPU_CTRL4_REG             (SRE_SYS_REG_BASEADDR + 0x910)
+#define SRE_SC_CPU_CTRL5_REG             (SRE_SYS_REG_BASEADDR + 0x914)
+#define SRE_SC_CORE0_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x930)     /* 到Core0的Event源头选择使能 */
+#define SRE_SC_CORE1_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x934)     /* 到Core1的Event源头选择使能 */
+#define SRE_SC_CORE2_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x938)     /* 到Core2的Event源头选择使能 */
+#define SRE_SC_CORE3_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x93C)     /* 到Core3的Event源头选择使能 */
+#define SRE_SC_CORE4_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x940)     /* 到Core4的Event源头选择使能 */
+#define SRE_SC_CORE5_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x944)     /* 到Core5的Event源头选择使能 */
+#define SRE_SC_CORE6_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x948)     /* 到Core6的Event源头选择使能 */
+#define SRE_SC_CORE7_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x94C)     /* 到Core7的Event源头选择使能 */
+#define SRE_SC_CORE8_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x950)     /* 到Core8的Event源头选择使能 */
+#define SRE_SC_CORE9_EVENT_EN_REG        (SRE_SYS_REG_BASEADDR + 0x954)     /* 到Core9的Event源头选择使能 */
+#define SRE_SC_CORE10_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x958)     /* 到Core10的Event源头选择使能 */
+#define SRE_SC_CORE11_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x95C)     /* 到Core11的Event源头选择使能 */
+#define SRE_SC_CORE12_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x960)     /* 到Core12的Event源头选择使能 */
+#define SRE_SC_CORE13_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x964)     /* 到Core13的Event源头选择使能 */
+#define SRE_SC_CORE14_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x968)     /* 到Core14的Event源头选择使能 */
+#define SRE_SC_CORE15_EVENT_EN_REG       (SRE_SYS_REG_BASEADDR + 0x96C)     /* 到Core15的Event源头选择使能 */
+#define SRE_SC_CACHE_CTRL_REG            (SRE_SYS_REG_BASEADDR + 0x9F0)     /* Cache工作模式配置 */
+#define SRE_SC_GIC_CTRL_REG              (SRE_SYS_REG_BASEADDR + 0xA00)     /* GIC控制寄存器 */
+#define SRE_SC_CS_CTRL_REG               (SRE_SYS_REG_BASEADDR + 0xA40)
+#define SRE_SC_DDR_CTRL0_REG             (SRE_SYS_REG_BASEADDR + 0xA80)
+#define SRE_SC_DDR_CTRL1_REG             (SRE_SYS_REG_BASEADDR + 0xA84)
+#define SRE_SC_EBI_CTRL_REG              (SRE_SYS_REG_BASEADDR + 0xAC0)
+#define SRE_SC_USB_CTRL0_REG             (SRE_SYS_REG_BASEADDR + 0xB80)
+#define SRE_SC_USB_CTRL1_REG             (SRE_SYS_REG_BASEADDR + 0xB84)
+#define SRE_SC_BOOTROM_CTRL_REG          (SRE_SYS_REG_BASEADDR + 0xC00)
+#define SRE_SC_TSENSOR_CTRL_REG          (SRE_SYS_REG_BASEADDR + 0xC10)
+#define SRE_SC_TSENSOR_TEST_CTRL_REG     (SRE_SYS_REG_BASEADDR + 0xC18)     /* Tsensor测试使用，请正常用户不要配置修改。 */
+#define SRE_SC_EMMC_CTRL_REG             (SRE_SYS_REG_BASEADDR + 0xC20)
+#define SRE_SC_MDIO_CTRL0_REG            (SRE_SYS_REG_BASEADDR + 0xC30)
+#define SRE_SC_MDIO_CTRL1_REG            (SRE_SYS_REG_BASEADDR + 0xC34)
+#define SRE_SC_SYNC_ETH0_CTRL_REG        (SRE_SYS_REG_BASEADDR + 0xC40)     /* 同步以太网时钟选择控制寄存器0 */
+#define SRE_SC_SYNC_ETH1_CTRL_REG        (SRE_SYS_REG_BASEADDR + 0xC44)     /* 同步以太网时钟选择控制器1 */
+#define SRE_SC_MAC_MODE_REG              (SRE_SYS_REG_BASEADDR + 0xC48)     /* 各网口MAC工作模式指示，同步以太网时钟上送功能模块根据此信号确定原始时钟到上送时钟需要进行的分频系数 */
+#define SRE_SC_MISC_CTRL_REG             (SRE_SYS_REG_BASEADDR + 0xC80)
+#define SRE_SC_IO_DRIVE_CTRL0_REG        (SRE_SYS_REG_BASEADDR + 0xC90)     /* 普通IO管脚驱动电流配置控制0 */
+#define SRE_SC_IO_DRIVE_CTRL1_REG        (SRE_SYS_REG_BASEADDR + 0xC94)     /* 普通IO管脚驱动电流配置控制1 */
+#define MC_SCITCR_REG                    (SRE_SYS_REG_BASEADDR + 0xF00)
+#define MC_SCITIR0_REG                   (SRE_SYS_REG_BASEADDR + 0xF04)
+#define MC_SCITIR1_REG                   (SRE_SYS_REG_BASEADDR + 0xF08)
+#define MC_SCITOR_REG                    (SRE_SYS_REG_BASEADDR + 0xF0C)
+#define MC_SCCNTCTRL_REG                 (SRE_SYS_REG_BASEADDR + 0xF10)
+#define MC_SCCNTDATA_REG                 (SRE_SYS_REG_BASEADDR + 0xF14)
+#define MC_SCCNTSTEP_REG                 (SRE_SYS_REG_BASEADDR + 0xF18)
+#define SRE_SC_TSENSOR_REG               (SRE_SYS_REG_BASEADDR + 0x1080)
+#define SRE_SC_BOOT_CFG_REG              (SRE_SYS_REG_BASEADDR + 0x1090)
+#define SRE_SC_BOOT_SEL_REG              (SRE_SYS_REG_BASEADDR + 0x1094)
+#define SRE_SC_PLL_LOCK_STATUS_REG       (SRE_SYS_REG_BASEADDR + 0x1110)
+#define SRE_SC_TOP_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1200)    /* 顶层CRG时钟状态寄存器 */
+#define SRE_SC_GE_CLK_ST_REG             (SRE_SYS_REG_BASEADDR + 0x12A0)    /* GE时钟状态寄存器 */
+#define SRE_SC_XGE_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x12B0)    /* XGE时钟状态寄存器 */
+#define SRE_SC_PCIE_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x12E0)    /* PCIE时钟状态寄存器 */
+#define SRE_SC_SRIO_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x12F0)    /* SRIO时钟状态寄存器 */
+#define SRE_SC_USB_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1300)    /* USB时钟状态寄存器 */
+#define SRE_SC_SATA_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1310)    /* SATA时钟状态寄存器 */
+#define SRE_SC_DDR_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1320)    /* DDR时钟状态寄存器 */
+#define SRE_SC_MMC_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1330)    /* MMC时钟状态寄存器 */
+#define SRE_SC_SFC_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1338)    /* SFC时钟状态寄存器 */
+#define SRE_SC_NANDC_CLK_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1340)    /* NANDC时钟状态寄存器 */
+#define SRE_SC_LOCALBUS_CLK_ST_REG       (SRE_SYS_REG_BASEADDR + 0x1350)    /* LOCALBUS时钟状态寄存器 */
+#define SRE_SC_UART_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1380)    /* UART时钟状态寄存器 */
+#define SRE_SC_I2C_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1388)    /* I2C时钟状态寄存器 */
+#define SRE_SC_MDIO_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1390)    /* MDIO时钟状态寄存器 */
+#define SRE_SC_SPI_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1398)    /* SPI时钟状态寄存器 */
+#define SRE_SC_GPIO_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x13A0)    /* GPIO时钟状态寄存器 */
+#define SRE_SC_TDM_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x13C0)    /* TDM时钟状态寄存器 */
+#define SRE_SC_HDLC_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x13C8)    /* HDLC时钟状态寄存器 */
+#define SRE_SC_BOOTROM_CLK_ST_REG        (SRE_SYS_REG_BASEADDR + 0x1400)    /* BOOTROM时钟状态寄存器 */
+#define SRE_SC_SEC_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1408)    /* SEC时钟状态寄存器 */
+#define SRE_SC_POE_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1410)    /* POE时钟状态寄存器 */
+#define SRE_SC_BMU_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1418)    /* BMU时钟状态寄存器 */
+#define SRE_SC_PPE_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1420)    /* PPE时钟状态寄存器 */
+#define SRE_SC_NP_CLK_ST_REG             (SRE_SYS_REG_BASEADDR + 0x1428)    /* SPPE时钟状态寄存器 */
+#define SRE_SC_CRC_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1430)    /* CRC时钟状态寄存器 */
+#define SRE_SC_DMAC_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1438)    /* DMAC时钟状态寄存器 */
+#define SRE_SC_ROHC_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1440)    /* ROHC时钟状态寄存器 */
+#define SRE_SC_HDCP_CLK_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1448)    /* HDCP时钟状态寄存器 */
+#define SRE_SC_PDM_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1450)    /* PDM时钟状态寄存器 */
+#define SRE_SC_TRING_CLK_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1458)    /* TRING时钟状态寄存器 */
+#define SRE_SC_RNG_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1460)    /* RNG时钟状态寄存器 */
+#define SRE_SC_IMA_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1468)    /* IMA时钟状态寄存器 */
+#define SRE_SC_SCH_CLK_ST_REG            (SRE_SYS_REG_BASEADDR + 0x1470)    /* SCH时钟状态寄存器 */
+#define SRE_SC_TM_CLK_ST_REG             (SRE_SYS_REG_BASEADDR + 0x1478)    /* TM时钟状态寄存器 */
+#define SRE_SC_TOP_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1500)    /* 顶层CRG软复位状态寄存器 */
+#define SRE_SC_CPU_RESET_ST0_REG         (SRE_SYS_REG_BASEADDR + 0x1520)    /* Cluster0内部软复位状态控制寄存器。 */
+#define SRE_SC_CPU_RESET_ST1_REG         (SRE_SYS_REG_BASEADDR + 0x1528)    /* Cluster1内部软复位状态控制寄存器。 */
+#define SRE_SC_CPU_RESET_ST2_REG         (SRE_SYS_REG_BASEADDR + 0x1530)    /* Cluster2内部软复位状态控制寄存器。 */
+#define SRE_SC_CPU_RESET_ST3_REG         (SRE_SYS_REG_BASEADDR + 0x1538)    /* Cluster3内部软复位状态控制寄存器。 */
+#define SRE_SC_CACHE_RESET_ST_REG        (SRE_SYS_REG_BASEADDR + 0x1560)    /* l3cache软复位状态控制寄存器 */
+#define SRE_SC_SERDES_RESET_ST0_REG      (SRE_SYS_REG_BASEADDR + 0x1580)    /* Serdes软复位状态寄存器1 */
+#define SRE_SC_SERDES_RESET_ST1_REG      (SRE_SYS_REG_BASEADDR + 0x1588)    /* Serdes软复位状态寄存器2 */
+#define SRE_SC_SERDES_RESET_ST2_REG      (SRE_SYS_REG_BASEADDR + 0x1590)    /* Serdes软复位状态寄存器3 */
+#define SRE_SC_GE_RESET_ST_REG           (SRE_SYS_REG_BASEADDR + 0x15A0)    /* GE软复位状态寄存器 */
+#define SRE_SC_XGE_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x15B0)    /* XGE软复位状态寄存器 */
+#define SRE_SC_MAC_CFG_RESET_ST_REG      (SRE_SYS_REG_BASEADDR + 0x15C0)    /* MAC配置软复位状态寄存器 */
+#define SRE_SC_MAC_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x15C8)    /* MAC软复位状态寄存器 */
+#define SRE_SC_PCIE_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x15E0)    /* PCIE软复位状态寄存器 */
+#define SRE_SC_SRIO_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x15F0)    /* SRIO软复位状态寄存器 */
+#define SRE_SC_USB_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1604)    /* USB软复位状态寄存器 */
+#define SRE_SC_DDR_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1620)    /* DDR软复位状态控制寄存器 */
+#define SRE_SC_MMC_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1630)    /* MMC软复位状态寄存器 */
+#define SRE_SC_SFC_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1638)    /* SFC软复位状态寄存器 */
+#define SRE_SC_NANDC_RESET_ST_REG        (SRE_SYS_REG_BASEADDR + 0x1640)    /* NANDC软复位状态寄存器 */
+#define SRE_SC_LOCALBUS_RESET_ST_REG     (SRE_SYS_REG_BASEADDR + 0x1650)    /* LOCALBUS软复位状态寄存器 */
+#define SRE_SC_UART_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1680)    /* UART软复位状态寄存器 */
+#define SRE_SC_I2C_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1688)    /* I2C软复位状态寄存器 */
+#define SRE_SC_MDIO_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1690)    /* MDIO软复位状态寄存器 */
+#define SRE_SC_SPI_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1698)    /* SPI软复位状态寄存器 */
+#define SRE_SC_GPIO_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x16A0)    /* GPIO软复位状态寄存器 */
+#define SRE_SC_TDM_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x16C0)    /* TDM软复位状态寄存器 */
+#define SRE_SC_HDLC_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x16C8)    /* HDLC软复位状态寄存器 */
+#define SRE_SC_BOOTROM_RESET_ST_REG      (SRE_SYS_REG_BASEADDR + 0x1700)    /* BOOTROM软复位状态寄存器 */
+#define SRE_SC_SEC_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1708)    /* SEC软复位状态寄存器 */
+#define SRE_SC_POE_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1710)    /* POE软复位状态寄存器 */
+#define SRE_SC_BMU_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1718)    /* BMU软复位状态寄存器 */
+#define SRE_SC_PPE_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1720)    /* PPE软复位状态寄存器 */
+#define SRE_SC_NP_RESET_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1728)    /* SPPE软复位状态寄存器 */
+#define SRE_SC_CRC_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1730)    /* CRC软复位状态寄存器 */
+#define SRE_SC_DMAC_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1738)    /* DMAC软复位状态寄存器 */
+#define SRE_SC_ROHC_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1740)    /* ROHC软复位状态寄存器 */
+#define SRE_SC_HDCP_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1748)    /* HDCP软复位状态寄存器 */
+#define SRE_SC_PDM_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1750)    /* PDM软复位状态寄存器 */
+#define SRE_SC_TRING_RESET_ST_REG        (SRE_SYS_REG_BASEADDR + 0x1758)    /* TRING软复位状态寄存器 */
+#define SRE_SC_RNG_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1760)    /* RNG软复位状态寄存器 */
+#define SRE_SC_IMA_RESET_ST_REG          (SRE_SYS_REG_BASEADDR + 0x1768)    /* IMA软复位状态寄存器 */
+#define SRE_SC_SCH_RESET_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1770)    /* SCH软复位状态寄存器 */
+#define SRE_SC_TM_RESET_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1778)    /* TM软复位状态寄存器 */
+#define SRE_SC_FUNC_MBIST_DONE0_REG      (SRE_SYS_REG_BASEADDR + 0x1810)
+#define SRE_SC_FUNC_MBIST_DONE1_REG      (SRE_SYS_REG_BASEADDR + 0x1814)
+#define SRE_SC_FUNC_MBIST_RESULT0_REG    (SRE_SYS_REG_BASEADDR + 0x1820)
+#define SRE_SC_FUNC_MBIST_RESULT1_REG    (SRE_SYS_REG_BASEADDR + 0x1824)
+#define SRE_SC_CLUSTER0_MBIST_ST0_REG    (SRE_SYS_REG_BASEADDR + 0x1830)    /* Cluster0 MBIST测试状态和结果 */
+#define SRE_SC_CLUSTER0_MBIST_ST1_REG    (SRE_SYS_REG_BASEADDR + 0x1834)    /* Cluster0 L1 MBIST测试结果状态 */
+#define SRE_SC_CLUSTER1_MBIST_ST0_REG    (SRE_SYS_REG_BASEADDR + 0x1838)    /* Cluster1 MBIST测试状态和结果 */
+#define SRE_SC_CLUSTER1_MBIST_ST1_REG    (SRE_SYS_REG_BASEADDR + 0x183C)    /* Cluster1 L1 MBIST测试结果状态 */
+#define SRE_SC_CLUSTER2_MBIST_ST0_REG    (SRE_SYS_REG_BASEADDR + 0x1840)    /* Cluster2 MBIST测试状态和结果 */
+#define SRE_SC_CLUSTER2_MBIST_ST1_REG    (SRE_SYS_REG_BASEADDR + 0x1844)    /* Cluster2 L1 MBIST测试结果状态 */
+#define SRE_SC_CLUSTER3_MBIST_ST0_REG    (SRE_SYS_REG_BASEADDR + 0x1848)    /* Cluster0 MBIST测试状态和结果 */
+#define SRE_SC_CLUSTER3_MBIST_ST1_REG    (SRE_SYS_REG_BASEADDR + 0x184C)    /* Cluster0 L1 MBIST测试结果状态 */
+#define SRE_SC_TCAM_MBIST_ST_REG         (SRE_SYS_REG_BASEADDR + 0x1860)    /* TCAM MBIST测试结果状态 */
+#define SRE_SC_SYNC_ETH_ST_REG           (SRE_SYS_REG_BASEADDR + 0x1900)    /* 同步以太网工作状态 */
+#define SRE_SC_DDR_ST_REG                (SRE_SYS_REG_BASEADDR + 0x1A80)
+#define SRE_SC_LOGIC_FREEZE_EN_REG       (SRE_SYS_REG_BASEADDR + 0x1E00)    /* 通过此寄存器控制锁定所有逻辑，供同时获取芯片状态， */
+#define SRE_SC_LOGIC_FREEZE_SRC_EN_REG   (SRE_SYS_REG_BASEADDR + 0x1E04)    /* 时钟停止源头选择 */
+#define SRE_SC_LOGIC_FREEZE_REQ_REG      (SRE_SYS_REG_BASEADDR + 0x1E08)    /* 内部软件请求停止业务通路工作时钟 */
+#define SRE_SC_IO_H2X_STAT_REG           (SRE_SYS_REG_BASEADDR + 0x1E40)
+#define SRE_SC_ALG_H2X_STAT_REG          (SRE_SYS_REG_BASEADDR + 0x1E44)
+#define SRE_SC_NORESET_REC0_REG          (SRE_SYS_REG_BASEADDR + 0x1E80)    /* 无复位寄存器0，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC1_REG          (SRE_SYS_REG_BASEADDR + 0x1E84)    /* 无复位寄存器1，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC2_REG          (SRE_SYS_REG_BASEADDR + 0x1E88)    /* 无复位寄存器2，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC3_REG          (SRE_SYS_REG_BASEADDR + 0x1E8C)    /* 无复位寄存器3，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC4_REG          (SRE_SYS_REG_BASEADDR + 0x1E90)    /* 无复位寄存器4，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC5_REG          (SRE_SYS_REG_BASEADDR + 0x1E94)    /* 无复位寄存器5，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC6_REG          (SRE_SYS_REG_BASEADDR + 0x1E98)    /* 无复位寄存器6，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC7_REG          (SRE_SYS_REG_BASEADDR + 0x1E9C)    /* 无复位寄存器7，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC8_REG          (SRE_SYS_REG_BASEADDR + 0x1EA0)    /* 无复位寄存器8，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC9_REG          (SRE_SYS_REG_BASEADDR + 0x1EA4)    /* 无复位寄存器9，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC10_REG         (SRE_SYS_REG_BASEADDR + 0x1EA8)    /* 无复位寄存器10，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC11_REG         (SRE_SYS_REG_BASEADDR + 0x1EAC)    /* 无复位寄存器11，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC12_REG         (SRE_SYS_REG_BASEADDR + 0x1EB0)    /* 无复位寄存器12，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC13_REG         (SRE_SYS_REG_BASEADDR + 0x1EB4)    /* 无复位寄存器13，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC14_REG         (SRE_SYS_REG_BASEADDR + 0x1EB8)    /* 无复位寄存器14，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SC_NORESET_REC15_REG         (SRE_SYS_REG_BASEADDR + 0x1EBC)    /* 无复位寄存器15，可以用于在非掉电复位时，保留复位前的状态。 */
+#define SRE_SYS_SYSID_0_REG                  (SRE_SYS_REG_BASEADDR + 0x1EE0)    /* SYS ID 31~0比特 */
+#define SRE_SYS_SYSID_1_REG                  (SRE_SYS_REG_BASEADDR + 0x1EE4)    /* SYS ID 63~32比特 */
+#define SRE_SYS_SYSID_2_REG                  (SRE_SYS_REG_BASEADDR + 0x1EE8)    /* SYS ID 95~64比特 */
+#define SRE_SYS_SYSID_3_REG                  (SRE_SYS_REG_BASEADDR + 0x1EEC)    /* SYS ID 127~96比特 */
+#define SRE_SYS_SYSID_4_REG                  (SRE_SYS_REG_BASEADDR + 0x1EF0)    /* SYS ID 159~128比特 */
+#define SRE_SYS_SYSID_5_REG                  (SRE_SYS_REG_BASEADDR + 0x1EF4)    /* SYS ID 191~160比特 */
+#define SRE_SYS_SYSID_6_REG                  (SRE_SYS_REG_BASEADDR + 0x1EF8)    /* SYS ID 223~192比特 */
+#define SRE_SYS_SYSID_7_REG                  (SRE_SYS_REG_BASEADDR + 0x1EFC)    /* SYS ID 255~224比特 */
+/* END:   Added by h00176630, 2012/6/9 */
+
+/******************************************************************************/
+/*                      PhosphorV600 GIC 寄存器定义                           */
+/******************************************************************************/
+#define MC_GIC0_REG_BASEADDR     (0x1A000100 + 0x80000000)   /* GIC0的寄存器基地址 */
+#define MC_GIC1_REG_BASEADDR     (0x1B000100 + 0x80000000)   /* GIC1的寄存器基地址 */
+
+/******************************************************************************/
+/*                      PhosphorV600 UART0 寄存器定义                         */
+/******************************************************************************/
+#define MC_URAT0_REG_BASEADDR           0xe4007000   /* URAT0的寄存器基地址 */
+#define MC_UART0_REG_DR_DLL          (MC_URAT0_REG_BASEADDR + 0x00 )  /* GIC0的寄存器基地址 */
+#define MC_UART0_REG_USR             (MC_URAT0_REG_BASEADDR + 0x7c )  /* GIC0的寄存器基地址 */
+
+/* 看门狗定时器的IO起始基址 */
+#define MC_WATCHDOG_IO_BASE        (0x600)
+#define MC_WATCHDOG_LOAD_GER       (MC_WATCHDOG_IO_BASE + 0x20)
+#define MC_WATCHDOG_COUNT_GER      (MC_WATCHDOG_IO_BASE + 0x24)
+#define MC_WATCHDOG_CONTRL_GER     (MC_WATCHDOG_IO_BASE + 0x28)
+#define MC_WATCHDOG_INT_STAU_GER   (MC_WATCHDOG_IO_BASE + 0x2C)
+
+/******************************************************************************/
+/*                                    GPIO寄存器                              */
+/******************************************************************************/
+#define MC_GPIO0_REG_BASE           (0x2000a000 + 0x80000000)
+#define MC_GPIO0_SWPORT_DR_REG      (MC_GPIO0_REG_BASE + 0x00)
+#define MC_GPIO0_SWPORT_DDR_REG     (MC_GPIO0_REG_BASE + 0x04)
+
+/******************************************************************************/
+/*                                    IO_CONFIG寄存器                              */
+/******************************************************************************/
+#define MC_IOCONFIG_REG_BASE        (0x2000d000 + 0x80000000)
+#define MC_IOMG012_REG              (MC_IOCONFIG_REG_BASE + 0x30)
+
+/* BEGIN: Added by c00111586, 2010/9/24   问题单号:DTS2010091901574 */
+#define MC_PADMG00_REG              (MC_IOCONFIG_REG_BASE + 0x800)
+/* END:   Added by c00111586, 2010/9/24 */
+
+/********QMU模块使用的寄存器地址定义************/
+#define MC_QMU_REG_BASE            (0x10020000 + 0x80000000)
+#define MC_QMU_INT_STATUS_REG      (MC_QMU_REG_BASE + 0x00)
+#define MC_QMU_INT_ENA_REG         (MC_QMU_REG_BASE + 0x04)
+#define MC_QMU_INT_CLR_REG         (MC_QMU_REG_BASE + 0x08)
+
+#define MC_QMU_CNT_SEL_REG         (MC_QMU_REG_BASE + 0x00E8)
+#define MC_QMU_RD_EXPT_RET_REG0    (MC_QMU_REG_BASE + 0x00FC)
+#define MC_QMU_RD_EXPT_RET_REG1    (MC_QMU_REG_BASE + 0x0100)
+#define MC_QMU_DEBUG_CTR_REG       (MC_QMU_REG_BASE + 0x0104)
+#define MC_QMU_DEBUG_STAT_REG      (MC_QMU_REG_BASE + 0x0108)
+
+#define MC_QMU_PQ_BASE_REG         (MC_QMU_REG_BASE + 0x2000)
+#define MC_QMU_PQ_CNT_REG          (MC_QMU_REG_BASE + 0x2004)
+#define MC_QMU_PQ_RWP_REG          (MC_QMU_REG_BASE + 0x2008)
+
+#define MC_QMU_RQ_BASE_REG         (MC_QMU_REG_BASE + 0x2300)
+#define MC_QMU_RQ_CNT_REG          (MC_QMU_REG_BASE + 0x2304)
+#define MC_QMU_RQ_RWP_REG          (MC_QMU_REG_BASE + 0x2308)
+
+#define MC_QMU_PQ_CORE0_LDST_REG   (MC_QMU_REG_BASE + 0x4000)
+#define MC_QMU_PQ_CORE0_ST_STA_REG (MC_QMU_REG_BASE + 0x6000)
+
+#define MC_QMU_RQ_CORE0_LDST_REG   (MC_QMU_REG_BASE + 0x8000)
+#define MC_QMU_RQ_CORE0_ST_STA_REG (MC_QMU_REG_BASE + 0x9000)
+
+
+/********HDCP 模块使用的寄存器地址定义************/
+#define MC_HDCP_REG_BASE            (0x100e0000 + 0x80000000)
+#define SRE_HDCP_ENABLE_REG         (MC_HDCP_REG_BASE + 0x0000)
+#define HDCP_BMU_CFG_ADDR          (MC_HDCP_REG_BASE + 0x0004)
+#define HDCP_POE_CFG_ADDR          (MC_HDCP_REG_BASE + 0x0008)          /**POE ADD 寄存器**/
+#define HDCP_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x000c)
+#define HDCP_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0010)
+
+#define HDCP_INT_MASK_REG          (MC_HDCP_REG_BASE + 0x0014)
+#define HDCP_INT_STATUS_REG        (MC_HDCP_REG_BASE + 0x0018)
+#define HDCP_RAWINT_STATUS_REG     (MC_HDCP_REG_BASE + 0x001C)
+#define HDCP_INT_CLR_REG           (MC_HDCP_REG_BASE + 0x0020)
+
+#define HDCP_MEMREQ_FAIL_REG       (MC_HDCP_REG_BASE + 0x0024)
+#define HDCP_BMURLS_FAIL_REG       (MC_HDCP_REG_BASE + 0x0028)
+#define HDCP_ADDPOE_FAIL_REG       (MC_HDCP_REG_BASE + 0x002C)
+#define HDCP_DATA_FAIL_REG         (MC_HDCP_REG_BASE + 0x0030)
+
+#define HDCP_TRANS_CNT_REG         (MC_HDCP_REG_BASE + 0x0034)
+#define HDCP_DATA_TIMECNT_REG      (MC_HDCP_REG_BASE + 0x0038)
+#define HDCP_MEMRES_CMPL_CNT_REG   (MC_HDCP_REG_BASE + 0x003C)
+#define HDCP_MEMREQ_CMPL_CNT_REG   (MC_HDCP_REG_BASE + 0x0040)
+#define HDCP_ADDPOE_CMPL_CNT_REG   (MC_HDCP_REG_BASE + 0x0044)
+
+
+#define HDCP_CH0_ENABLE_REG        (MC_HDCP_REG_BASE + 0x0100)
+#define HDCP_CH0_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x0104)
+#define HDCP_CH0_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x0108)
+#define HDCP_CH0_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x010C)
+#define HDCP_CH0_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x0110)
+#define HDCP_CH0_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0114)
+#define HDCP_CH0_DEBUG_REG             (MC_HDCP_REG_BASE + 0x0118)
+
+#define HDCP_CH1_ENABLE_REG            (MC_HDCP_REG_BASE + 0x0120)
+#define HDCP_CH1_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x0124)
+#define HDCP_CH1_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x0128)
+#define HDCP_CH1_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x012C)
+#define HDCP_CH1_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x0130)
+#define HDCP_CH1_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0134)
+#define HDCP_CH1_DEBUG_REG             (MC_HDCP_REG_BASE + 0x0138)
+
+#define HDCP_CH2_ENABLE_REG            (MC_HDCP_REG_BASE + 0x0140)
+#define HDCP_CH2_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x0144)
+#define HDCP_CH2_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x0148)
+#define HDCP_CH2_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x014C)
+#define HDCP_CH2_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x0150)
+#define HDCP_CH2_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0154)
+#define HDCP_CH2_DEBUG_REG             (MC_HDCP_REG_BASE + 0x0158)
+
+#define HDCP_CH3_ENABLE_REG            (MC_HDCP_REG_BASE + 0x0160)
+#define HDCP_CH3_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x0164)
+#define HDCP_CH3_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x0168)
+#define HDCP_CH3_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x016C)
+#define HDCP_CH3_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x0170)
+#define HDCP_CH3_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0174)
+#define HDCP_CH3_DEBUG_REG             (MC_HDCP_REG_BASE + 0x0178)
+
+#define HDCP_CH4_ENABLE_REG            (MC_HDCP_REG_BASE + 0x0180)
+#define HDCP_CH4_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x0184)
+#define HDCP_CH4_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x0188)
+#define HDCP_CH4_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x018C)
+#define HDCP_CH4_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x0190)
+#define HDCP_CH4_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x0194)
+#define HDCP_CH4_DEBUG_REG             (MC_HDCP_REG_BASE + 0x0198)
+
+#define HDCP_CH5_ENABLE_REG            (MC_HDCP_REG_BASE + 0x01A0)
+#define HDCP_CH5_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x01A4)
+#define HDCP_CH5_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x01A8)
+#define HDCP_CH5_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x01AC)
+#define HDCP_CH5_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x01B0)
+#define HDCP_CH5_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x01B4)
+#define HDCP_CH5_DEBUG_REG             (MC_HDCP_REG_BASE + 0x01B8)
+
+#define HDCP_CH6_ENABLE_REG            (MC_HDCP_REG_BASE + 0x01C0)
+#define HDCP_CH6_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x01C4)
+#define HDCP_CH6_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x01C8)
+#define HDCP_CH6_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x01CC)
+#define HDCP_CH6_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x01D0)
+#define HDCP_CH6_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x01D4)
+#define HDCP_CH6_DEBUG_REG             (MC_HDCP_REG_BASE + 0x01D8)
+
+#define HDCP_CH7_ENABLE_REG            (MC_HDCP_REG_BASE + 0x01E0)
+#define HDCP_CH7_ADD_POE_WDATA2_REG    (MC_HDCP_REG_BASE + 0x01E4)
+#define HDCP_CH7_SRC_SADDR_REG         (MC_HDCP_REG_BASE + 0x01E8)
+#define HDCP_CH7_DES_SADDR_REG         (MC_HDCP_REG_BASE + 0x01EC)
+#define HDCP_CH7_CONFIG0_REG           (MC_HDCP_REG_BASE + 0x01F0)
+#define HDCP_CH7_CONFIG1_REG           (MC_HDCP_REG_BASE + 0x01F4)
+#define HDCP_CH7_DEBUG_REG             (MC_HDCP_REG_BASE + 0x01F8)
+
+/******************************************************************************/
+/*                                    外设TIMER寄存器                         */
+/******************************************************************************/
+#define MC_GLOBAL_TIMER_BASE      (0x20009000UL + 0x80000000UL)
+#define MC_GLOBAL_TIMER0_LOAD     (MC_GLOBAL_TIMER_BASE + 0x00)
+#define MC_GLOBAL_TIMER0_VALUE    (MC_GLOBAL_TIMER_BASE + 0x04)
+#define MC_GLOBAL_TIMER0_CONTRL   (MC_GLOBAL_TIMER_BASE + 0x08)
+#define MC_GLOBAL_TIMER0_INCLR    (MC_GLOBAL_TIMER_BASE + 0x0C)
+#define MC_GLOBAL_TIMER0_RIS      (MC_GLOBAL_TIMER_BASE + 0x10)
+#define MC_GLOBAL_TIMER0_MIS      (MC_GLOBAL_TIMER_BASE + 0x14)
+#define MC_GLOBAL_TIMER0_BGLOAD   (MC_GLOBAL_TIMER_BASE + 0x18)
+#define MC_GLOBAL_TIMER1_LOAD     (MC_GLOBAL_TIMER_BASE + 0x20)
+#define MC_GLOBAL_TIMER1_VALUE    (MC_GLOBAL_TIMER_BASE + 0x24)
+#define MC_GLOBAL_TIMER1_CONTRL   (MC_GLOBAL_TIMER_BASE + 0x28)
+#define MC_GLOBAL_TIMER1_INCLR    (MC_GLOBAL_TIMER_BASE + 0x2C)
+#define MC_GLOBAL_TIMER1_RIS      (MC_GLOBAL_TIMER_BASE + 0x30)
+#define MC_GLOBAL_TIMER1_MIS      (MC_GLOBAL_TIMER_BASE + 0x34)
+#define MC_GLOBAL_TIMER1_BGLOAD   (MC_GLOBAL_TIMER_BASE + 0x38)
+
+/* GIC 模块寄存器基地址 */
+#if 0
+#define SRE_GIC_BASE                               (0x10c00000)
+#else
+#define SRE_GIC_BASE                               (0xe0c00000)
+#endif
+/******************************************************************************/
+/*                      PhosphorV650 GIC 寄存器定义                           */
+/******************************************************************************/
+#define OS_GIC_GICD_CTLR_REG                      (SRE_GIC_BASE + 0x1000)          /* Distributor的使能控制 */
+#define OS_GIC_GICD_TYPER_REG                     (SRE_GIC_BASE + 0x1004)          /* GIC的配置信息，包括是否使用安全扩展，最大锁定的SPI数，最大支持的中断数等信息 */
+#define OS_GIC_GICD_IIDR_REG                      (SRE_GIC_BASE + 0x1008)          /* GIC身份寄存器 */
+#define OS_GIC_GICD_IGROUPR0_REG                  (SRE_GIC_BASE + 0x1080)          /* 标识中断分组至Group0或Group1 */
+#define OS_GIC_GICD_ISENABLER0_REG                (SRE_GIC_BASE + 0x1100)          /* 单个中断的使能寄存器，决定是否发给Cpu Interface。 */
+#define OS_GIC_GICD_ICENABLER0_REG                (SRE_GIC_BASE + 0x1180)          /* 单个中断的清除使能的寄存器，确定是否发给CPU Interface。n的值由GICD_TYPER.ITLinesNumber决定,n=0 */
+#define OS_GIC_GICD_ISPENDR0_REG                  (SRE_GIC_BASE + 0x1200)          /* 单个中断设置pending状态的控制信号寄存器。 */
+#define OS_GIC_GICD_ICPENDR0_REG                  (SRE_GIC_BASE + 0x1280)          /* 单个中断清除pending状态的控制信号寄存器。 */
+#define OS_GIC_GICD_ISACTIVER0_REG                (SRE_GIC_BASE + 0x1300)          /* 单个中断设置active状态的控制信号寄存器。 */
+#define OS_GIC_GICD_ICACTIVER0_REG                (SRE_GIC_BASE + 0x1380)          /* 单个中断清除active状态的控制信号寄存器，这些寄存器在需要保存和回复GIC的状态时使用。 */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_NS_0_REG       (SRE_GIC_BASE + 0x1400)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_NS_1_REG       (SRE_GIC_BASE + 0x1404)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_NS_2_REG       (SRE_GIC_BASE + 0x1408)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_NS_3_REG       (SRE_GIC_BASE + 0x140C)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define OS_GIC_GICD_IPRIORITYR0TO3_S_0_REG        (SRE_GIC_BASE + 0x1400)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_S_1_REG        (SRE_GIC_BASE + 0x1404)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_S_2_REG        (SRE_GIC_BASE + 0x1408)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR0TO3_S_3_REG        (SRE_GIC_BASE + 0x140C)          /* 每8bit对应一个中断的优先级。x{0,3} */
+#define SRE_GIC_GICD_IPRIORITYR6_NS_REG            (SRE_GIC_BASE + 0x1418)          /* 每8bit对应一个中断的优先级。 */
+#define SRE_GIC_GICD_IPRIORITYR6_S_REG             (SRE_GIC_BASE + 0x1418)          /* 每8bit对应一个中断的优先级。 */
+#define SRE_GIC_GICD_IPRIORITYR7_NS_REG            (SRE_GIC_BASE + 0x141C)          /* 每8bit对应一个中断的优先级。 */
+#define SRE_GIC_GICD_IPRIORITYR7_S_REG             (SRE_GIC_BASE + 0x141C)          /* 每8bit对应一个中断的优先级。 */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_0_REG     (SRE_GIC_BASE + 0x1420)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_1_REG     (SRE_GIC_BASE + 0x1424)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_2_REG     (SRE_GIC_BASE + 0x1428)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_3_REG     (SRE_GIC_BASE + 0x142C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_4_REG     (SRE_GIC_BASE + 0x1430)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_5_REG     (SRE_GIC_BASE + 0x1434)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_6_REG     (SRE_GIC_BASE + 0x1438)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_7_REG     (SRE_GIC_BASE + 0x143C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_8_REG     (SRE_GIC_BASE + 0x1440)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_9_REG     (SRE_GIC_BASE + 0x1444)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_10_REG    (SRE_GIC_BASE + 0x1448)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_11_REG    (SRE_GIC_BASE + 0x144C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_12_REG    (SRE_GIC_BASE + 0x1450)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_13_REG    (SRE_GIC_BASE + 0x1454)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_14_REG    (SRE_GIC_BASE + 0x1458)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_15_REG    (SRE_GIC_BASE + 0x145C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_16_REG    (SRE_GIC_BASE + 0x1460)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_17_REG    (SRE_GIC_BASE + 0x1464)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_18_REG    (SRE_GIC_BASE + 0x1468)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_19_REG    (SRE_GIC_BASE + 0x146C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_20_REG    (SRE_GIC_BASE + 0x1470)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_21_REG    (SRE_GIC_BASE + 0x1474)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_22_REG    (SRE_GIC_BASE + 0x1478)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_23_REG    (SRE_GIC_BASE + 0x147C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_24_REG    (SRE_GIC_BASE + 0x1480)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_25_REG    (SRE_GIC_BASE + 0x1484)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_26_REG    (SRE_GIC_BASE + 0x1488)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_27_REG    (SRE_GIC_BASE + 0x148C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_28_REG    (SRE_GIC_BASE + 0x1490)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_29_REG    (SRE_GIC_BASE + 0x1494)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_30_REG    (SRE_GIC_BASE + 0x1498)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_31_REG    (SRE_GIC_BASE + 0x149C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_32_REG    (SRE_GIC_BASE + 0x14A0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_33_REG    (SRE_GIC_BASE + 0x14A4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_34_REG    (SRE_GIC_BASE + 0x14A8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_35_REG    (SRE_GIC_BASE + 0x14AC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_36_REG    (SRE_GIC_BASE + 0x14B0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_37_REG    (SRE_GIC_BASE + 0x14B4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_38_REG    (SRE_GIC_BASE + 0x14B8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_39_REG    (SRE_GIC_BASE + 0x14BC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_40_REG    (SRE_GIC_BASE + 0x14C0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_41_REG    (SRE_GIC_BASE + 0x14C4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_42_REG    (SRE_GIC_BASE + 0x14C8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_43_REG    (SRE_GIC_BASE + 0x14CC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_44_REG    (SRE_GIC_BASE + 0x14D0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_45_REG    (SRE_GIC_BASE + 0x14D4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_46_REG    (SRE_GIC_BASE + 0x14D8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_47_REG    (SRE_GIC_BASE + 0x14DC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_48_REG    (SRE_GIC_BASE + 0x14E0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_49_REG    (SRE_GIC_BASE + 0x14E4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_50_REG    (SRE_GIC_BASE + 0x14E8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_51_REG    (SRE_GIC_BASE + 0x14EC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_52_REG    (SRE_GIC_BASE + 0x14F0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_53_REG    (SRE_GIC_BASE + 0x14F4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_54_REG    (SRE_GIC_BASE + 0x14F8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_55_REG    (SRE_GIC_BASE + 0x14FC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_56_REG    (SRE_GIC_BASE + 0x1500)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_57_REG    (SRE_GIC_BASE + 0x1504)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_58_REG    (SRE_GIC_BASE + 0x1508)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_59_REG    (SRE_GIC_BASE + 0x150C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_60_REG    (SRE_GIC_BASE + 0x1510)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_61_REG    (SRE_GIC_BASE + 0x1514)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_62_REG    (SRE_GIC_BASE + 0x1518)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_63_REG    (SRE_GIC_BASE + 0x151C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_64_REG    (SRE_GIC_BASE + 0x1520)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_65_REG    (SRE_GIC_BASE + 0x1524)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_66_REG    (SRE_GIC_BASE + 0x1528)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_67_REG    (SRE_GIC_BASE + 0x152C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_68_REG    (SRE_GIC_BASE + 0x1530)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_69_REG    (SRE_GIC_BASE + 0x1534)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_70_REG    (SRE_GIC_BASE + 0x1538)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_71_REG    (SRE_GIC_BASE + 0x153C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_72_REG    (SRE_GIC_BASE + 0x1540)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_73_REG    (SRE_GIC_BASE + 0x1544)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_74_REG    (SRE_GIC_BASE + 0x1548)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_75_REG    (SRE_GIC_BASE + 0x154C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_76_REG    (SRE_GIC_BASE + 0x1550)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_77_REG    (SRE_GIC_BASE + 0x1554)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_78_REG    (SRE_GIC_BASE + 0x1558)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_79_REG    (SRE_GIC_BASE + 0x155C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_80_REG    (SRE_GIC_BASE + 0x1560)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_81_REG    (SRE_GIC_BASE + 0x1564)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_82_REG    (SRE_GIC_BASE + 0x1568)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_83_REG    (SRE_GIC_BASE + 0x156C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_84_REG    (SRE_GIC_BASE + 0x1570)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_85_REG    (SRE_GIC_BASE + 0x1574)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_86_REG    (SRE_GIC_BASE + 0x1578)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_87_REG    (SRE_GIC_BASE + 0x157C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_88_REG    (SRE_GIC_BASE + 0x1580)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_89_REG    (SRE_GIC_BASE + 0x1584)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_90_REG    (SRE_GIC_BASE + 0x1588)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_91_REG    (SRE_GIC_BASE + 0x158C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_92_REG    (SRE_GIC_BASE + 0x1590)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_93_REG    (SRE_GIC_BASE + 0x1594)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_94_REG    (SRE_GIC_BASE + 0x1598)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_95_REG    (SRE_GIC_BASE + 0x159C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_96_REG    (SRE_GIC_BASE + 0x15A0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_97_REG    (SRE_GIC_BASE + 0x15A4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_98_REG    (SRE_GIC_BASE + 0x15A8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_99_REG    (SRE_GIC_BASE + 0x15AC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_100_REG   (SRE_GIC_BASE + 0x15B0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_101_REG   (SRE_GIC_BASE + 0x15B4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_102_REG   (SRE_GIC_BASE + 0x15B8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_103_REG   (SRE_GIC_BASE + 0x15BC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_104_REG   (SRE_GIC_BASE + 0x15C0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_105_REG   (SRE_GIC_BASE + 0x15C4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_106_REG   (SRE_GIC_BASE + 0x15C8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_107_REG   (SRE_GIC_BASE + 0x15CC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_108_REG   (SRE_GIC_BASE + 0x15D0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_109_REG   (SRE_GIC_BASE + 0x15D4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_110_REG   (SRE_GIC_BASE + 0x15D8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_NS_111_REG   (SRE_GIC_BASE + 0x15DC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_0_REG      (SRE_GIC_BASE + 0x1420)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_1_REG      (SRE_GIC_BASE + 0x1424)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_2_REG      (SRE_GIC_BASE + 0x1428)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_3_REG      (SRE_GIC_BASE + 0x142C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_4_REG      (SRE_GIC_BASE + 0x1430)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_5_REG      (SRE_GIC_BASE + 0x1434)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_6_REG      (SRE_GIC_BASE + 0x1438)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_7_REG      (SRE_GIC_BASE + 0x143C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_8_REG      (SRE_GIC_BASE + 0x1440)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_9_REG      (SRE_GIC_BASE + 0x1444)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_10_REG     (SRE_GIC_BASE + 0x1448)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_11_REG     (SRE_GIC_BASE + 0x144C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_12_REG     (SRE_GIC_BASE + 0x1450)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_13_REG     (SRE_GIC_BASE + 0x1454)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_14_REG     (SRE_GIC_BASE + 0x1458)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_15_REG     (SRE_GIC_BASE + 0x145C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_16_REG     (SRE_GIC_BASE + 0x1460)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_17_REG     (SRE_GIC_BASE + 0x1464)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_18_REG     (SRE_GIC_BASE + 0x1468)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_19_REG     (SRE_GIC_BASE + 0x146C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_20_REG     (SRE_GIC_BASE + 0x1470)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_21_REG     (SRE_GIC_BASE + 0x1474)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_22_REG     (SRE_GIC_BASE + 0x1478)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_23_REG     (SRE_GIC_BASE + 0x147C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_24_REG     (SRE_GIC_BASE + 0x1480)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_25_REG     (SRE_GIC_BASE + 0x1484)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_26_REG     (SRE_GIC_BASE + 0x1488)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_27_REG     (SRE_GIC_BASE + 0x148C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_28_REG     (SRE_GIC_BASE + 0x1490)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_29_REG     (SRE_GIC_BASE + 0x1494)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_30_REG     (SRE_GIC_BASE + 0x1498)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_31_REG     (SRE_GIC_BASE + 0x149C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_32_REG     (SRE_GIC_BASE + 0x14A0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_33_REG     (SRE_GIC_BASE + 0x14A4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_34_REG     (SRE_GIC_BASE + 0x14A8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_35_REG     (SRE_GIC_BASE + 0x14AC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_36_REG     (SRE_GIC_BASE + 0x14B0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_37_REG     (SRE_GIC_BASE + 0x14B4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_38_REG     (SRE_GIC_BASE + 0x14B8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_39_REG     (SRE_GIC_BASE + 0x14BC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_40_REG     (SRE_GIC_BASE + 0x14C0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_41_REG     (SRE_GIC_BASE + 0x14C4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_42_REG     (SRE_GIC_BASE + 0x14C8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_43_REG     (SRE_GIC_BASE + 0x14CC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_44_REG     (SRE_GIC_BASE + 0x14D0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_45_REG     (SRE_GIC_BASE + 0x14D4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_46_REG     (SRE_GIC_BASE + 0x14D8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_47_REG     (SRE_GIC_BASE + 0x14DC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_48_REG     (SRE_GIC_BASE + 0x14E0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_49_REG     (SRE_GIC_BASE + 0x14E4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_50_REG     (SRE_GIC_BASE + 0x14E8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_51_REG     (SRE_GIC_BASE + 0x14EC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_52_REG     (SRE_GIC_BASE + 0x14F0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_53_REG     (SRE_GIC_BASE + 0x14F4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_54_REG     (SRE_GIC_BASE + 0x14F8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_55_REG     (SRE_GIC_BASE + 0x14FC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_56_REG     (SRE_GIC_BASE + 0x1500)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_57_REG     (SRE_GIC_BASE + 0x1504)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_58_REG     (SRE_GIC_BASE + 0x1508)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_59_REG     (SRE_GIC_BASE + 0x150C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_60_REG     (SRE_GIC_BASE + 0x1510)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_61_REG     (SRE_GIC_BASE + 0x1514)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_62_REG     (SRE_GIC_BASE + 0x1518)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_63_REG     (SRE_GIC_BASE + 0x151C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_64_REG     (SRE_GIC_BASE + 0x1520)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_65_REG     (SRE_GIC_BASE + 0x1524)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_66_REG     (SRE_GIC_BASE + 0x1528)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_67_REG     (SRE_GIC_BASE + 0x152C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_68_REG     (SRE_GIC_BASE + 0x1530)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_69_REG     (SRE_GIC_BASE + 0x1534)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_70_REG     (SRE_GIC_BASE + 0x1538)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_71_REG     (SRE_GIC_BASE + 0x153C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_72_REG     (SRE_GIC_BASE + 0x1540)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_73_REG     (SRE_GIC_BASE + 0x1544)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_74_REG     (SRE_GIC_BASE + 0x1548)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_75_REG     (SRE_GIC_BASE + 0x154C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_76_REG     (SRE_GIC_BASE + 0x1550)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_77_REG     (SRE_GIC_BASE + 0x1554)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_78_REG     (SRE_GIC_BASE + 0x1558)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_79_REG     (SRE_GIC_BASE + 0x155C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_80_REG     (SRE_GIC_BASE + 0x1560)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_81_REG     (SRE_GIC_BASE + 0x1564)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_82_REG     (SRE_GIC_BASE + 0x1568)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_83_REG     (SRE_GIC_BASE + 0x156C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_84_REG     (SRE_GIC_BASE + 0x1570)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_85_REG     (SRE_GIC_BASE + 0x1574)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_86_REG     (SRE_GIC_BASE + 0x1578)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_87_REG     (SRE_GIC_BASE + 0x157C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_88_REG     (SRE_GIC_BASE + 0x1580)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_89_REG     (SRE_GIC_BASE + 0x1584)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_90_REG     (SRE_GIC_BASE + 0x1588)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_91_REG     (SRE_GIC_BASE + 0x158C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_92_REG     (SRE_GIC_BASE + 0x1590)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_93_REG     (SRE_GIC_BASE + 0x1594)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_94_REG     (SRE_GIC_BASE + 0x1598)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_95_REG     (SRE_GIC_BASE + 0x159C)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_96_REG     (SRE_GIC_BASE + 0x15A0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_97_REG     (SRE_GIC_BASE + 0x15A4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_98_REG     (SRE_GIC_BASE + 0x15A8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_99_REG     (SRE_GIC_BASE + 0x15AC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_100_REG    (SRE_GIC_BASE + 0x15B0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_101_REG    (SRE_GIC_BASE + 0x15B4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_102_REG    (SRE_GIC_BASE + 0x15B8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_103_REG    (SRE_GIC_BASE + 0x15BC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_104_REG    (SRE_GIC_BASE + 0x15C0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_105_REG    (SRE_GIC_BASE + 0x15C4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_106_REG    (SRE_GIC_BASE + 0x15C8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_107_REG    (SRE_GIC_BASE + 0x15CC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_108_REG    (SRE_GIC_BASE + 0x15D0)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_109_REG    (SRE_GIC_BASE + 0x15D4)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_110_REG    (SRE_GIC_BASE + 0x15D8)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define SRE_GIC_GICD_IPRIORITYR8TO119_S_111_REG    (SRE_GIC_BASE + 0x15DC)          /* 每8bit对应一个中断的优先级。n{0,111} */
+#define OS_GIC_GICD_ITARGETSRZ_0_REG              (SRE_GIC_BASE + 0x1800)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_1_REG              (SRE_GIC_BASE + 0x1804)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_2_REG              (SRE_GIC_BASE + 0x1808)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_3_REG              (SRE_GIC_BASE + 0x180C)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_4_REG              (SRE_GIC_BASE + 0x1810)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_5_REG              (SRE_GIC_BASE + 0x1814)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_6_REG              (SRE_GIC_BASE + 0x1818)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSRZ_7_REG              (SRE_GIC_BASE + 0x181C)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的z范围为0～7，即对应的中断是SGIs。z{0,7}。 */
+#define SRE_GIC_GICD_ITARGETSR12_REG               (SRE_GIC_BASE + 0x1830)          /* 每16bit对应一个中断的所有相应的CPU Interface。。 */
+#define SRE_GIC_GICD_ITARGETSRH_0_REG              (SRE_GIC_BASE + 0x1834)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的h范围为13～15，即对应的中断是PPIs。h{0,2} */
+#define SRE_GIC_GICD_ITARGETSRH_1_REG              (SRE_GIC_BASE + 0x1838)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的h范围为13～15，即对应的中断是PPIs。h{0,2} */
+#define SRE_GIC_GICD_ITARGETSRH_2_REG              (SRE_GIC_BASE + 0x183C)          /* 每16bit对应一个中断的所有相应的CPU Interface。此处的h范围为13～15，即对应的中断是PPIs。h{0,2} */
+#define SRE_GIC_GICD_ITARGETSRY_0_REG              (SRE_GIC_BASE + 0x1840)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_1_REG              (SRE_GIC_BASE + 0x1844)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_2_REG              (SRE_GIC_BASE + 0x1848)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_3_REG              (SRE_GIC_BASE + 0x184C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_4_REG              (SRE_GIC_BASE + 0x1850)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_5_REG              (SRE_GIC_BASE + 0x1854)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_6_REG              (SRE_GIC_BASE + 0x1858)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_7_REG              (SRE_GIC_BASE + 0x185C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_8_REG              (SRE_GIC_BASE + 0x1860)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_9_REG              (SRE_GIC_BASE + 0x1864)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_10_REG             (SRE_GIC_BASE + 0x1868)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_11_REG             (SRE_GIC_BASE + 0x186C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_12_REG             (SRE_GIC_BASE + 0x1870)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_13_REG             (SRE_GIC_BASE + 0x1874)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_14_REG             (SRE_GIC_BASE + 0x1878)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_15_REG             (SRE_GIC_BASE + 0x187C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_16_REG             (SRE_GIC_BASE + 0x1880)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_17_REG             (SRE_GIC_BASE + 0x1884)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_18_REG             (SRE_GIC_BASE + 0x1888)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_19_REG             (SRE_GIC_BASE + 0x188C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_20_REG             (SRE_GIC_BASE + 0x1890)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_21_REG             (SRE_GIC_BASE + 0x1894)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_22_REG             (SRE_GIC_BASE + 0x1898)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_23_REG             (SRE_GIC_BASE + 0x189C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_24_REG             (SRE_GIC_BASE + 0x18A0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_25_REG             (SRE_GIC_BASE + 0x18A4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_26_REG             (SRE_GIC_BASE + 0x18A8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_27_REG             (SRE_GIC_BASE + 0x18AC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_28_REG             (SRE_GIC_BASE + 0x18B0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_29_REG             (SRE_GIC_BASE + 0x18B4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_30_REG             (SRE_GIC_BASE + 0x18B8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_31_REG             (SRE_GIC_BASE + 0x18BC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_32_REG             (SRE_GIC_BASE + 0x18C0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_33_REG             (SRE_GIC_BASE + 0x18C4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_34_REG             (SRE_GIC_BASE + 0x18C8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_35_REG             (SRE_GIC_BASE + 0x18CC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_36_REG             (SRE_GIC_BASE + 0x18D0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_37_REG             (SRE_GIC_BASE + 0x18D4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_38_REG             (SRE_GIC_BASE + 0x18D8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_39_REG             (SRE_GIC_BASE + 0x18DC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_40_REG             (SRE_GIC_BASE + 0x18E0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_41_REG             (SRE_GIC_BASE + 0x18E4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_42_REG             (SRE_GIC_BASE + 0x18E8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_43_REG             (SRE_GIC_BASE + 0x18EC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_44_REG             (SRE_GIC_BASE + 0x18F0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_45_REG             (SRE_GIC_BASE + 0x18F4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_46_REG             (SRE_GIC_BASE + 0x18F8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_47_REG             (SRE_GIC_BASE + 0x18FC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_48_REG             (SRE_GIC_BASE + 0x1900)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_49_REG             (SRE_GIC_BASE + 0x1904)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_50_REG             (SRE_GIC_BASE + 0x1908)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_51_REG             (SRE_GIC_BASE + 0x190C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_52_REG             (SRE_GIC_BASE + 0x1910)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_53_REG             (SRE_GIC_BASE + 0x1914)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_54_REG             (SRE_GIC_BASE + 0x1918)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_55_REG             (SRE_GIC_BASE + 0x191C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_56_REG             (SRE_GIC_BASE + 0x1920)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_57_REG             (SRE_GIC_BASE + 0x1924)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_58_REG             (SRE_GIC_BASE + 0x1928)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_59_REG             (SRE_GIC_BASE + 0x192C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_60_REG             (SRE_GIC_BASE + 0x1930)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_61_REG             (SRE_GIC_BASE + 0x1934)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_62_REG             (SRE_GIC_BASE + 0x1938)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_63_REG             (SRE_GIC_BASE + 0x193C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_64_REG             (SRE_GIC_BASE + 0x1940)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_65_REG             (SRE_GIC_BASE + 0x1944)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_66_REG             (SRE_GIC_BASE + 0x1948)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_67_REG             (SRE_GIC_BASE + 0x194C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_68_REG             (SRE_GIC_BASE + 0x1950)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_69_REG             (SRE_GIC_BASE + 0x1954)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_70_REG             (SRE_GIC_BASE + 0x1958)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_71_REG             (SRE_GIC_BASE + 0x195C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_72_REG             (SRE_GIC_BASE + 0x1960)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_73_REG             (SRE_GIC_BASE + 0x1964)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_74_REG             (SRE_GIC_BASE + 0x1968)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_75_REG             (SRE_GIC_BASE + 0x196C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_76_REG             (SRE_GIC_BASE + 0x1970)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_77_REG             (SRE_GIC_BASE + 0x1974)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_78_REG             (SRE_GIC_BASE + 0x1978)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_79_REG             (SRE_GIC_BASE + 0x197C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_80_REG             (SRE_GIC_BASE + 0x1980)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_81_REG             (SRE_GIC_BASE + 0x1984)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_82_REG             (SRE_GIC_BASE + 0x1988)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_83_REG             (SRE_GIC_BASE + 0x198C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_84_REG             (SRE_GIC_BASE + 0x1990)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_85_REG             (SRE_GIC_BASE + 0x1994)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_86_REG             (SRE_GIC_BASE + 0x1998)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_87_REG             (SRE_GIC_BASE + 0x199C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_88_REG             (SRE_GIC_BASE + 0x19A0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_89_REG             (SRE_GIC_BASE + 0x19A4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_90_REG             (SRE_GIC_BASE + 0x19A8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_91_REG             (SRE_GIC_BASE + 0x19AC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_92_REG             (SRE_GIC_BASE + 0x19B0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_93_REG             (SRE_GIC_BASE + 0x19B4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_94_REG             (SRE_GIC_BASE + 0x19B8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_95_REG             (SRE_GIC_BASE + 0x19BC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_96_REG             (SRE_GIC_BASE + 0x19C0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_97_REG             (SRE_GIC_BASE + 0x19C4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_98_REG             (SRE_GIC_BASE + 0x19C8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_99_REG             (SRE_GIC_BASE + 0x19CC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_100_REG            (SRE_GIC_BASE + 0x19D0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_101_REG            (SRE_GIC_BASE + 0x19D4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_102_REG            (SRE_GIC_BASE + 0x19D8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_103_REG            (SRE_GIC_BASE + 0x19DC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_104_REG            (SRE_GIC_BASE + 0x19E0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_105_REG            (SRE_GIC_BASE + 0x19E4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_106_REG            (SRE_GIC_BASE + 0x19E8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_107_REG            (SRE_GIC_BASE + 0x19EC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_108_REG            (SRE_GIC_BASE + 0x19F0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_109_REG            (SRE_GIC_BASE + 0x19F4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_110_REG            (SRE_GIC_BASE + 0x19F8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_111_REG            (SRE_GIC_BASE + 0x19FC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_112_REG            (SRE_GIC_BASE + 0x1A00)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_113_REG            (SRE_GIC_BASE + 0x1A04)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_114_REG            (SRE_GIC_BASE + 0x1A08)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_115_REG            (SRE_GIC_BASE + 0x1A0C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_116_REG            (SRE_GIC_BASE + 0x1A10)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_117_REG            (SRE_GIC_BASE + 0x1A14)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_118_REG            (SRE_GIC_BASE + 0x1A18)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_119_REG            (SRE_GIC_BASE + 0x1A1C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_120_REG            (SRE_GIC_BASE + 0x1A20)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_121_REG            (SRE_GIC_BASE + 0x1A24)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_122_REG            (SRE_GIC_BASE + 0x1A28)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_123_REG            (SRE_GIC_BASE + 0x1A2C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_124_REG            (SRE_GIC_BASE + 0x1A30)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_125_REG            (SRE_GIC_BASE + 0x1A34)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_126_REG            (SRE_GIC_BASE + 0x1A38)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_127_REG            (SRE_GIC_BASE + 0x1A3C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_128_REG            (SRE_GIC_BASE + 0x1A40)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_129_REG            (SRE_GIC_BASE + 0x1A44)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_130_REG            (SRE_GIC_BASE + 0x1A48)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_131_REG            (SRE_GIC_BASE + 0x1A4C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_132_REG            (SRE_GIC_BASE + 0x1A50)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_133_REG            (SRE_GIC_BASE + 0x1A54)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_134_REG            (SRE_GIC_BASE + 0x1A58)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_135_REG            (SRE_GIC_BASE + 0x1A5C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_136_REG            (SRE_GIC_BASE + 0x1A60)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_137_REG            (SRE_GIC_BASE + 0x1A64)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_138_REG            (SRE_GIC_BASE + 0x1A68)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_139_REG            (SRE_GIC_BASE + 0x1A6C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_140_REG            (SRE_GIC_BASE + 0x1A70)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_141_REG            (SRE_GIC_BASE + 0x1A74)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_142_REG            (SRE_GIC_BASE + 0x1A78)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_143_REG            (SRE_GIC_BASE + 0x1A7C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_144_REG            (SRE_GIC_BASE + 0x1A80)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_145_REG            (SRE_GIC_BASE + 0x1A84)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_146_REG            (SRE_GIC_BASE + 0x1A88)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_147_REG            (SRE_GIC_BASE + 0x1A8C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_148_REG            (SRE_GIC_BASE + 0x1A90)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_149_REG            (SRE_GIC_BASE + 0x1A94)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_150_REG            (SRE_GIC_BASE + 0x1A98)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_151_REG            (SRE_GIC_BASE + 0x1A9C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_152_REG            (SRE_GIC_BASE + 0x1AA0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_153_REG            (SRE_GIC_BASE + 0x1AA4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_154_REG            (SRE_GIC_BASE + 0x1AA8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_155_REG            (SRE_GIC_BASE + 0x1AAC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_156_REG            (SRE_GIC_BASE + 0x1AB0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_157_REG            (SRE_GIC_BASE + 0x1AB4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_158_REG            (SRE_GIC_BASE + 0x1AB8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_159_REG            (SRE_GIC_BASE + 0x1ABC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_160_REG            (SRE_GIC_BASE + 0x1AC0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_161_REG            (SRE_GIC_BASE + 0x1AC4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_162_REG            (SRE_GIC_BASE + 0x1AC8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_163_REG            (SRE_GIC_BASE + 0x1ACC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_164_REG            (SRE_GIC_BASE + 0x1AD0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_165_REG            (SRE_GIC_BASE + 0x1AD4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_166_REG            (SRE_GIC_BASE + 0x1AD8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_167_REG            (SRE_GIC_BASE + 0x1ADC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_168_REG            (SRE_GIC_BASE + 0x1AE0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_169_REG            (SRE_GIC_BASE + 0x1AE4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_170_REG            (SRE_GIC_BASE + 0x1AE8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_171_REG            (SRE_GIC_BASE + 0x1AEC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_172_REG            (SRE_GIC_BASE + 0x1AF0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_173_REG            (SRE_GIC_BASE + 0x1AF4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_174_REG            (SRE_GIC_BASE + 0x1AF8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_175_REG            (SRE_GIC_BASE + 0x1AFC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_176_REG            (SRE_GIC_BASE + 0x1B00)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_177_REG            (SRE_GIC_BASE + 0x1B04)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_178_REG            (SRE_GIC_BASE + 0x1B08)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_179_REG            (SRE_GIC_BASE + 0x1B0C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_180_REG            (SRE_GIC_BASE + 0x1B10)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_181_REG            (SRE_GIC_BASE + 0x1B14)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_182_REG            (SRE_GIC_BASE + 0x1B18)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_183_REG            (SRE_GIC_BASE + 0x1B1C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_184_REG            (SRE_GIC_BASE + 0x1B20)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_185_REG            (SRE_GIC_BASE + 0x1B24)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_186_REG            (SRE_GIC_BASE + 0x1B28)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_187_REG            (SRE_GIC_BASE + 0x1B2C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_188_REG            (SRE_GIC_BASE + 0x1B30)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_189_REG            (SRE_GIC_BASE + 0x1B34)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_190_REG            (SRE_GIC_BASE + 0x1B38)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_191_REG            (SRE_GIC_BASE + 0x1B3C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_192_REG            (SRE_GIC_BASE + 0x1B40)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_193_REG            (SRE_GIC_BASE + 0x1B44)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_194_REG            (SRE_GIC_BASE + 0x1B48)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_195_REG            (SRE_GIC_BASE + 0x1B4C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_196_REG            (SRE_GIC_BASE + 0x1B50)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_197_REG            (SRE_GIC_BASE + 0x1B54)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_198_REG            (SRE_GIC_BASE + 0x1B58)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_199_REG            (SRE_GIC_BASE + 0x1B5C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_200_REG            (SRE_GIC_BASE + 0x1B60)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_201_REG            (SRE_GIC_BASE + 0x1B64)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_202_REG            (SRE_GIC_BASE + 0x1B68)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_203_REG            (SRE_GIC_BASE + 0x1B6C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_204_REG            (SRE_GIC_BASE + 0x1B70)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_205_REG            (SRE_GIC_BASE + 0x1B74)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_206_REG            (SRE_GIC_BASE + 0x1B78)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_207_REG            (SRE_GIC_BASE + 0x1B7C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_208_REG            (SRE_GIC_BASE + 0x1B80)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_209_REG            (SRE_GIC_BASE + 0x1B84)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_210_REG            (SRE_GIC_BASE + 0x1B88)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_211_REG            (SRE_GIC_BASE + 0x1B8C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_212_REG            (SRE_GIC_BASE + 0x1B90)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_213_REG            (SRE_GIC_BASE + 0x1B94)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_214_REG            (SRE_GIC_BASE + 0x1B98)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_215_REG            (SRE_GIC_BASE + 0x1B9C)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_216_REG            (SRE_GIC_BASE + 0x1BA0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_217_REG            (SRE_GIC_BASE + 0x1BA4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_218_REG            (SRE_GIC_BASE + 0x1BA8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_219_REG            (SRE_GIC_BASE + 0x1BAC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_220_REG            (SRE_GIC_BASE + 0x1BB0)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_221_REG            (SRE_GIC_BASE + 0x1BB4)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_222_REG            (SRE_GIC_BASE + 0x1BB8)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ITARGETSRY_223_REG            (SRE_GIC_BASE + 0x1BBC)          /* 该寄存器每16bit表示一个中断的所有相应的CPU Interface。此处的y>15。即对应的中断是SPIs。y的范围是y{0，223} */
+#define SRE_GIC_GICD_ICFGR0_REG                    (SRE_GIC_BASE + 0x1C00)          /* 该寄存器每2bit表示一个SGI中断是电平敏感还是边沿触发 */
+#define SRE_GIC_GICD_ICFGR1_REG                    (SRE_GIC_BASE + 0x1C04)          /* 该寄存器每2bit表示一个PPI中断是电平敏感还是边沿触发 */
+#define SRE_GIC_GICD_ICFGR_0_REG                   (SRE_GIC_BASE + 0x1C08)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_1_REG                   (SRE_GIC_BASE + 0x1C0C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_2_REG                   (SRE_GIC_BASE + 0x1C10)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_3_REG                   (SRE_GIC_BASE + 0x1C14)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_4_REG                   (SRE_GIC_BASE + 0x1C18)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_5_REG                   (SRE_GIC_BASE + 0x1C1C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_6_REG                   (SRE_GIC_BASE + 0x1C20)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_7_REG                   (SRE_GIC_BASE + 0x1C24)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_8_REG                   (SRE_GIC_BASE + 0x1C28)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_9_REG                   (SRE_GIC_BASE + 0x1C2C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_10_REG                  (SRE_GIC_BASE + 0x1C30)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_11_REG                  (SRE_GIC_BASE + 0x1C34)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_12_REG                  (SRE_GIC_BASE + 0x1C38)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_13_REG                  (SRE_GIC_BASE + 0x1C3C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_14_REG                  (SRE_GIC_BASE + 0x1C40)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_15_REG                  (SRE_GIC_BASE + 0x1C44)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_16_REG                  (SRE_GIC_BASE + 0x1C48)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_17_REG                  (SRE_GIC_BASE + 0x1C4C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_18_REG                  (SRE_GIC_BASE + 0x1C50)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_19_REG                  (SRE_GIC_BASE + 0x1C54)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_20_REG                  (SRE_GIC_BASE + 0x1C58)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_21_REG                  (SRE_GIC_BASE + 0x1C5C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_22_REG                  (SRE_GIC_BASE + 0x1C60)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_23_REG                  (SRE_GIC_BASE + 0x1C64)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_24_REG                  (SRE_GIC_BASE + 0x1C68)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_25_REG                  (SRE_GIC_BASE + 0x1C6C)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_26_REG                  (SRE_GIC_BASE + 0x1C70)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_ICFGR_27_REG                  (SRE_GIC_BASE + 0x1C74)          /* 该寄存器每2bit表示一个SPI中断是电平敏感还是边沿触发。e的最大值为2*GICD_TYPER.ITLinesNumber。e{0,27} */
+#define SRE_GIC_GICD_PPISR_REG                     (SRE_GIC_BASE + 0x1D00)          /* PPI中断输入至Distributor的状态 */
+#define SRE_GIC_GICD_SPISR_0_REG                   (SRE_GIC_BASE + 0x1D04)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_1_REG                   (SRE_GIC_BASE + 0x1D08)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_2_REG                   (SRE_GIC_BASE + 0x1D0C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_3_REG                   (SRE_GIC_BASE + 0x1D10)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_4_REG                   (SRE_GIC_BASE + 0x1D14)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_5_REG                   (SRE_GIC_BASE + 0x1D18)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_6_REG                   (SRE_GIC_BASE + 0x1D1C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_7_REG                   (SRE_GIC_BASE + 0x1D20)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_8_REG                   (SRE_GIC_BASE + 0x1D24)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_9_REG                   (SRE_GIC_BASE + 0x1D28)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_10_REG                  (SRE_GIC_BASE + 0x1D2C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_11_REG                  (SRE_GIC_BASE + 0x1D30)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_12_REG                  (SRE_GIC_BASE + 0x1D34)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_13_REG                  (SRE_GIC_BASE + 0x1D38)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_14_REG                  (SRE_GIC_BASE + 0x1D3C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_15_REG                  (SRE_GIC_BASE + 0x1D40)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_16_REG                  (SRE_GIC_BASE + 0x1D44)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_17_REG                  (SRE_GIC_BASE + 0x1D48)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_18_REG                  (SRE_GIC_BASE + 0x1D4C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_19_REG                  (SRE_GIC_BASE + 0x1D50)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_20_REG                  (SRE_GIC_BASE + 0x1D54)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_21_REG                  (SRE_GIC_BASE + 0x1D58)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_22_REG                  (SRE_GIC_BASE + 0x1D5C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_23_REG                  (SRE_GIC_BASE + 0x1D60)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_24_REG                  (SRE_GIC_BASE + 0x1D64)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_25_REG                  (SRE_GIC_BASE + 0x1D68)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_26_REG                  (SRE_GIC_BASE + 0x1D6C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_27_REG                  (SRE_GIC_BASE + 0x1D70)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_28_REG                  (SRE_GIC_BASE + 0x1D74)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_29_REG                  (SRE_GIC_BASE + 0x1D78)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_30_REG                  (SRE_GIC_BASE + 0x1D7C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_31_REG                  (SRE_GIC_BASE + 0x1D80)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_32_REG                  (SRE_GIC_BASE + 0x1D84)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_33_REG                  (SRE_GIC_BASE + 0x1D88)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_34_REG                  (SRE_GIC_BASE + 0x1D8C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_35_REG                  (SRE_GIC_BASE + 0x1D90)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_36_REG                  (SRE_GIC_BASE + 0x1D94)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_37_REG                  (SRE_GIC_BASE + 0x1D98)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_38_REG                  (SRE_GIC_BASE + 0x1D9C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_39_REG                  (SRE_GIC_BASE + 0x1DA0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_40_REG                  (SRE_GIC_BASE + 0x1DA4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_41_REG                  (SRE_GIC_BASE + 0x1DA8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_42_REG                  (SRE_GIC_BASE + 0x1DAC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_43_REG                  (SRE_GIC_BASE + 0x1DB0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_44_REG                  (SRE_GIC_BASE + 0x1DB4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_45_REG                  (SRE_GIC_BASE + 0x1DB8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_46_REG                  (SRE_GIC_BASE + 0x1DBC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_47_REG                  (SRE_GIC_BASE + 0x1DC0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_48_REG                  (SRE_GIC_BASE + 0x1DC4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_49_REG                  (SRE_GIC_BASE + 0x1DC8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_50_REG                  (SRE_GIC_BASE + 0x1DCC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_51_REG                  (SRE_GIC_BASE + 0x1DD0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_52_REG                  (SRE_GIC_BASE + 0x1DD4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_53_REG                  (SRE_GIC_BASE + 0x1DD8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_54_REG                  (SRE_GIC_BASE + 0x1DDC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_55_REG                  (SRE_GIC_BASE + 0x1DE0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_56_REG                  (SRE_GIC_BASE + 0x1DE4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_57_REG                  (SRE_GIC_BASE + 0x1DE8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_58_REG                  (SRE_GIC_BASE + 0x1DEC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_59_REG                  (SRE_GIC_BASE + 0x1DF0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_60_REG                  (SRE_GIC_BASE + 0x1DF4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_61_REG                  (SRE_GIC_BASE + 0x1DF8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_62_REG                  (SRE_GIC_BASE + 0x1DFC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_63_REG                  (SRE_GIC_BASE + 0x1E00)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_64_REG                  (SRE_GIC_BASE + 0x1E04)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_65_REG                  (SRE_GIC_BASE + 0x1E08)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_66_REG                  (SRE_GIC_BASE + 0x1E0C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_67_REG                  (SRE_GIC_BASE + 0x1E10)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_68_REG                  (SRE_GIC_BASE + 0x1E14)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_69_REG                  (SRE_GIC_BASE + 0x1E18)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_70_REG                  (SRE_GIC_BASE + 0x1E1C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_71_REG                  (SRE_GIC_BASE + 0x1E20)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_72_REG                  (SRE_GIC_BASE + 0x1E24)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_73_REG                  (SRE_GIC_BASE + 0x1E28)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_74_REG                  (SRE_GIC_BASE + 0x1E2C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_75_REG                  (SRE_GIC_BASE + 0x1E30)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_76_REG                  (SRE_GIC_BASE + 0x1E34)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_77_REG                  (SRE_GIC_BASE + 0x1E38)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_78_REG                  (SRE_GIC_BASE + 0x1E3C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_79_REG                  (SRE_GIC_BASE + 0x1E40)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_80_REG                  (SRE_GIC_BASE + 0x1E44)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_81_REG                  (SRE_GIC_BASE + 0x1E48)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_82_REG                  (SRE_GIC_BASE + 0x1E4C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_83_REG                  (SRE_GIC_BASE + 0x1E50)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_84_REG                  (SRE_GIC_BASE + 0x1E54)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_85_REG                  (SRE_GIC_BASE + 0x1E58)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_86_REG                  (SRE_GIC_BASE + 0x1E5C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_87_REG                  (SRE_GIC_BASE + 0x1E60)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_88_REG                  (SRE_GIC_BASE + 0x1E64)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_89_REG                  (SRE_GIC_BASE + 0x1E68)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_90_REG                  (SRE_GIC_BASE + 0x1E6C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_91_REG                  (SRE_GIC_BASE + 0x1E70)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_92_REG                  (SRE_GIC_BASE + 0x1E74)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_93_REG                  (SRE_GIC_BASE + 0x1E78)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_94_REG                  (SRE_GIC_BASE + 0x1E7C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_95_REG                  (SRE_GIC_BASE + 0x1E80)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_96_REG                  (SRE_GIC_BASE + 0x1E84)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_97_REG                  (SRE_GIC_BASE + 0x1E88)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_98_REG                  (SRE_GIC_BASE + 0x1E8C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_99_REG                  (SRE_GIC_BASE + 0x1E90)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_100_REG                 (SRE_GIC_BASE + 0x1E94)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_101_REG                 (SRE_GIC_BASE + 0x1E98)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_102_REG                 (SRE_GIC_BASE + 0x1E9C)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_103_REG                 (SRE_GIC_BASE + 0x1EA0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_104_REG                 (SRE_GIC_BASE + 0x1EA4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_105_REG                 (SRE_GIC_BASE + 0x1EA8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_106_REG                 (SRE_GIC_BASE + 0x1EAC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_107_REG                 (SRE_GIC_BASE + 0x1EB0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_108_REG                 (SRE_GIC_BASE + 0x1EB4)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_109_REG                 (SRE_GIC_BASE + 0x1EB8)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_110_REG                 (SRE_GIC_BASE + 0x1EBC)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define SRE_GIC_GICD_SPISR_111_REG                 (SRE_GIC_BASE + 0x1EC0)          /* SPI中断输入IRQS至GIC的状态。n的值由实际的外部中断数目决定。n{0,14} */
+#define OS_GIC_GICD_SGIR_REG                      (SRE_GIC_BASE + 0x1F00)          /* 控制SGI的产生 */
+#define SRE_GIC_GICD_CPENDSGIR_0_REG               (SRE_GIC_BASE + 0x1F40)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_1_REG               (SRE_GIC_BASE + 0x1F44)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_2_REG               (SRE_GIC_BASE + 0x1F48)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_3_REG               (SRE_GIC_BASE + 0x1F4C)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_4_REG               (SRE_GIC_BASE + 0x1F50)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_5_REG               (SRE_GIC_BASE + 0x1F54)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_6_REG               (SRE_GIC_BASE + 0x1F58)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_CPENDSGIR_7_REG               (SRE_GIC_BASE + 0x1F5C)          /* 每16bit表示单个SGI中断对应的16个CPU Interface清除pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_0_REG               (SRE_GIC_BASE + 0x1F80)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_1_REG               (SRE_GIC_BASE + 0x1F84)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_2_REG               (SRE_GIC_BASE + 0x1F88)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_3_REG               (SRE_GIC_BASE + 0x1F8C)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_4_REG               (SRE_GIC_BASE + 0x1F90)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_5_REG               (SRE_GIC_BASE + 0x1F94)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_6_REG               (SRE_GIC_BASE + 0x1F98)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_SPENDSGIR_7_REG               (SRE_GIC_BASE + 0x1F9C)          /* 每16bit表示单个SGI中断对应的16个CPU Interface设置pending状态。f{0,7} */
+#define SRE_GIC_GICD_PIDR4_REG                     (SRE_GIC_BASE + 0x1FD0)          /* Peripheral ID4身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR5_REG                     (SRE_GIC_BASE + 0x1FD4)          /* Peripheral ID5身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR6_REG                     (SRE_GIC_BASE + 0x1FD8)          /* Peripheral ID6身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR7_REG                     (SRE_GIC_BASE + 0x1FDC)          /* Peripheral ID7身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR0_REG                     (SRE_GIC_BASE + 0x1FE0)          /* Peripheral ID0身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR1_REG                     (SRE_GIC_BASE + 0x1FE4)          /* Peripheral ID1身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR2_REG                     (SRE_GIC_BASE + 0x1FE8)          /* Peripheral ID2身份识别寄存器 */
+#define SRE_GIC_GICD_PIDR3_REG                     (SRE_GIC_BASE + 0x1FEC)          /* Peripheral ID3身份识别寄存器 */
+#define SRE_GIC_GICD_CIDR0_REG                     (SRE_GIC_BASE + 0x1FF0)          /* Component ID0寄存器 */
+#define SRE_GIC_GICD_CIDR1_REG                     (SRE_GIC_BASE + 0x1FF4)          /* Component ID1寄存器 */
+#define SRE_GIC_GICD_CIDR2_REG                     (SRE_GIC_BASE + 0x1FF8)          /* Component ID2寄存器 */
+#define SRE_GIC_GICD_CIDR3_REG                     (SRE_GIC_BASE + 0x1FFC)          /* Component ID3寄存器 */
+#define SRE_GIC_GICC_CTLR_NS_REG                   (SRE_GIC_BASE + 0x2000)          /* CPU Interface使能以及顶层控制寄存器。（特别注意：GICC_CTLR是banked。此寄存器是在secure access下的备份。和在non_secure 的备份的位分配不一样）。 */
+#define OS_GIC_GICC_CTLR_S_REG                    (SRE_GIC_BASE + 0x2000)          /* CPU Interface使能以及顶层控制寄存器。（特别注意：此寄存器是在non_secure access下的备份。和在secure 的备份的位分配不一样）。 */
+#define OS_GIC_GICC_PMR_S_REG                     (SRE_GIC_BASE + 0x2004)          /* 中断优先级屏蔽寄存器 */
+#define SRE_GIC_GICC_PMR_NS_REG                    (SRE_GIC_BASE + 0x2004)          /* 中断优先级屏蔽寄存器 */
+#define SRE_GIC_GICC_BPR_NS_REG                    (SRE_GIC_BASE + 0x2008)          /* Group 优先级设置寄存器 */
+#define OS_GIC_GICC_BPR_S_REG                     (SRE_GIC_BASE + 0x2008)          /* Group 优先级设置寄存器 */
+#define OS_GIC_GICC_IAR_REG                       (SRE_GIC_BASE + 0x200C)          /* 中断确认寄存器 */
+#define OS_GIC_GICC_EOIR_REG                      (SRE_GIC_BASE + 0x2010)          /* 中断结束寄存器 */
+#define SRE_GIC_GICC_RPR_REG                       (SRE_GIC_BASE + 0x2014)          /* 指示running priority的寄存器 */
+#define SRE_GIC_GICC_HPPIR_REG                     (SRE_GIC_BASE + 0x2018)          /* 具有最高优先级pending状态的中断寄存器 */
+#define OS_GIC_GICC_ABPR_REG                      (SRE_GIC_BASE + 0x201C)          /* Group优先级设置寄存器 */
+#define OS_GIC_GICC_AIAR_REG                      (SRE_GIC_BASE + 0x2020)          /* Group1中断确认寄存器 */
+#define SRE_GIC_GICC_AEOIR_REG                     (SRE_GIC_BASE + 0x2024)          /* Group1中断结束寄存器 */
+#define SRE_GIC_GICC_AHPPIR_REG                    (SRE_GIC_BASE + 0x2028)          /* 具有最高优先级pending状态的Group1中断寄存器 */
+#define SRE_GIC_GICC_APR0_REG                      (SRE_GIC_BASE + 0x20D0)          /* active状态的安全中断优先级寄存器 */
+#define SRE_GIC_GICC_NSAPR0_REG                    (SRE_GIC_BASE + 0x20E0)          /* active状态的非安全中断优先级寄存器 */
+#define SRE_GIC_GICC_IIDR_REG                      (SRE_GIC_BASE + 0x20FC)          /* CPU interface身份寄存器 */
+#define SRE_GIC_GICC_DIR_REG                       (SRE_GIC_BASE + 0x3000)          /* deactive中断寄存器 */
+#define SRE_GIC_GICH_HCR_REG                       (SRE_GIC_BASE + 0x4000)          /* Hypervisor控制寄存器 */
+#define SRE_GIC_GICH_VTR_REG                       (SRE_GIC_BASE + 0x4004)          /* 记录GIC虚拟化扩展的参数寄存器 */
+#define SRE_GIC_GICH_VMCR_REG                      (SRE_GIC_BASE + 0x4008)          /* VM控制寄存器，在VM切换时，使能hypervisor保留和恢复GIC的状态。 */
+#define SRE_GIC_GICH_MISR_REG                      (SRE_GIC_BASE + 0x4010)          /* Maintenance中断状态寄存器，标识哪种maintenance interrupt置有效。 */
+#define SRE_GIC_GICH_EISR0_REG                     (SRE_GIC_BASE + 0x4020)          /* List register0～31 EOI状态寄存器 */
+#define SRE_GIC_GICH_ELSR0_REG                     (SRE_GIC_BASE + 0x4030)          /* List register0～31 空状态寄存器 */
+#define SRE_GIC_GICH_APR0_REG                      (SRE_GIC_BASE + 0x4070)          /* active 优先级寄存器。（n=0） */
+#define SRE_GIC_GICH_LR_0_REG                      (SRE_GIC_BASE + 0x4080)          /* List register，一个List register记录一个中断的信息，n的值由GICH_VTR.ListRegs域定义。g{0,3} */
+#define SRE_GIC_GICH_LR_1_REG                      (SRE_GIC_BASE + 0x4084)          /* List register，一个List register记录一个中断的信息，n的值由GICH_VTR.ListRegs域定义。g{0,3} */
+#define SRE_GIC_GICH_LR_2_REG                      (SRE_GIC_BASE + 0x4088)          /* List register，一个List register记录一个中断的信息，n的值由GICH_VTR.ListRegs域定义。g{0,3} */
+#define SRE_GIC_GICH_LR_3_REG                      (SRE_GIC_BASE + 0x408C)          /* List register，一个List register记录一个中断的信息，n的值由GICH_VTR.ListRegs域定义。g{0,3} */
+#define SRE_GIC_GICV_CTLR_REG                      (SRE_GIC_BASE + 0x6000)          /* Virtual CPU Interface使能以及顶层控制寄存器 */
+#define SRE_GIC_GICV_PMR_REG                       (SRE_GIC_BASE + 0x6004)          /* 虚拟中断优先级屏蔽寄存器 */
+#define SRE_GIC_GICV_BPR_REG                       (SRE_GIC_BASE + 0x6008)          /* 虚拟中断Group优先级设置寄存器 */
+#define SRE_GIC_GICV_IAR_REG                       (SRE_GIC_BASE + 0x600C)          /* 虚拟中断确认寄存器 */
+#define SRE_GIC_GICV_EOIR_REG                      (SRE_GIC_BASE + 0x6010)          /* 虚拟中断结束寄存器 */
+#define SRE_GIC_GICV_RPR_REG                       (SRE_GIC_BASE + 0x6014)          /* 指示VM中running priority的寄存器 */
+#define SRE_GIC_GICV_HPPIR_REG                     (SRE_GIC_BASE + 0x6018)          /* 具有最高优先级pending状态的虚拟中断寄存器 */
+#define SRE_GIC_GICV_ABPR_REG                      (SRE_GIC_BASE + 0x601C)          /* 虚拟中断Group优先级设置寄存器 */
+#define SRE_GIC_GICV_AIAR_REG                      (SRE_GIC_BASE + 0x6020)          /* 虚拟中断确认寄存器 */
+#define SRE_GIC_GICV_AEOIR_REG                     (SRE_GIC_BASE + 0x6024)          /* 虚拟中断结束寄存器 */
+#define SRE_GIC_GICV_AHPPIR_REG                    (SRE_GIC_BASE + 0x6028)          /* 具有最高优先级pending状态的虚拟中断寄存器 */
+#define SRE_GIC_GICV_APR0_REG                      (SRE_GIC_BASE + 0x60D0)          /* active状态的group0虚拟中断优先级寄存器。(n=0) */
+#define SRE_GIC_GICV_IIDR_REG                      (SRE_GIC_BASE + 0x60FC)          /* Virtual CPU Interface身份寄存器 */
+#define SRE_GIC_GICV_DIR_REG                       (SRE_GIC_BASE + 0x7000)          /* deactive虚拟中断寄存器 */
+
+/* TMR 模块寄存器基地址 */
+#define MC_TMR_BASE                               (0xe3000000)
+
+/******************************************************************************/
+/*                      MC TMR 寄存器定义                                     */
+/******************************************************************************/
+#define MC_TMR_TIMER0_LOAD_REG                    (MC_TMR_BASE + 0x0)             /* TIMER0_LOAD为Timer0计数初值寄存器。 */
+#define MC_TMR_TIMER0_VALUE_REG                   (MC_TMR_BASE + 0x4)             /* TIMER0_VALUE为Timer0当前计数值寄存器。 */
+#define MC_TMR_TIMER0_CONTROL_REG                 (MC_TMR_BASE + 0x8)             /* TIMER0_CONTROL为Timer0控制寄存器。 */
+#define MC_TMR_TIMER0_INTCLR_REG                  (MC_TMR_BASE + 0xC)             /* TIMER0_INTCLR为Timer0中断清除寄存器。 */
+#define MC_TMR_TIMER0_RIS_REG                     (MC_TMR_BASE + 0x10)            /* TIMER0_RIS为Timer0中断状态寄存器。 */
+#define MC_TMR_TIMER0_MIS_REG                     (MC_TMR_BASE + 0x14)            /* TIMER0_MIS为Timer0屏蔽后中断状态寄存器。 */
+#define MC_TMR_TIMER0_BGLOAD_REG                  (MC_TMR_BASE + 0x18)            /* TIMER0_BGLOAD为Timer0循环模式计数初值寄存器。 */
+#define MC_TMR_TIMER1_LOAD_REG                    (MC_TMR_BASE + 0x20)            /* TIMER1_LOAD为Timer1计数初值寄存器。 */
+#define MC_TMR_TIMER1_VALUE_REG                   (MC_TMR_BASE + 0x24)            /* TIMER1_VALUE为Timer1当前计数值寄存器。 */
+#define MC_TMR_TIMER1_CONTROL_REG                 (MC_TMR_BASE + 0x28)            /* TIMER1_CONTROL为Timer1控制寄存器。 */
+#define MC_TMR_TIMER1_INTCLR_REG                  (MC_TMR_BASE + 0x2C)            /* TIMER1_INTCLR为Timer1中断清除寄存器。 */
+#define MC_TMR_TIMER1_RIS_REG                     (MC_TMR_BASE + 0x30)            /* TIMER1_RIS为Timer1中断状态寄存器。 */
+#define MC_TMR_TIMER1_MIS_REG                     (MC_TMR_BASE + 0x34)            /* TIMER1_MIS为Timer1屏蔽后中断状态寄存器。 */
+#define MC_TMR_TIMER1_BGLOAD_REG                  (MC_TMR_BASE + 0x38)            /* TIMER1_BGLOAD为Timer1循环模式计数初值寄存器。 */
+
+
+/*64位定时器*/
+#define MC_TIMER64_0_LOAD_L                       (MC_TMR_BASE + 0x10000)
+#define MC_TIMER64_0_LOAD_H                       (MC_TMR_BASE + 0x10000 + 0x4)
+#define MC_Timer64_0_VALUE_L                      (MC_TMR_BASE + 0x10000 + 0x8)
+#define MC_Timer64_0_VALUE_H                      (MC_TMR_BASE + 0x10000 + 0xC)
+#define MC_Timer64_0_CONTROL                      (MC_TMR_BASE + 0x10000 + 0x10)
+#define MC_Timer64_0_INTCLR                       (MC_TMR_BASE + 0x10000 + 0x14)
+#define MC_Timer64_0_RIS                          (MC_TMR_BASE + 0x10000 + 0x18)
+#define MC_Timer64_0_MIS                          (MC_TMR_BASE + 0x10000 + 0x1C)
+#define MC_Timer64_0_BGLOAD_L                     (MC_TMR_BASE + 0x10000 + 0x20)
+#define MC_Timer64_0_BGLOAD_H                     (MC_TMR_BASE + 0x10000 + 0x24)
+
+
+#define MC_TIMER64_1_LOAD_L                       (MC_TMR_BASE + 0x10000 + 0x40)
+#define MC_TIMER64_1_LOAD_H                       (MC_TMR_BASE + 0x10000 + 0x44)
+#define MC_Timer64_1_VALUE_L                      (MC_TMR_BASE + 0x10000 + 0x48)
+#define MC_Timer64_1_VALUE_H                      (MC_TMR_BASE + 0x10000 + 0x4C)
+#define MC_Timer64_1_CONTROL                      (MC_TMR_BASE + 0x10000 + 0x50)
+#define MC_Timer64_1_INTCLR                       (MC_TMR_BASE + 0x10000 + 0x54)
+#define MC_Timer64_1_RIS                          (MC_TMR_BASE + 0x10000 + 0x58)
+#define MC_Timer64_1_MIS                          (MC_TMR_BASE + 0x10000 + 0x5C)
+#define MC_Timer64_1_BGLOAD_L                     (MC_TMR_BASE + 0x10000 + 0x60)
+#define MC_Timer64_1_BGLOAD_H                     (MC_TMR_BASE + 0x10000 + 0x64)
+
+
+/* RNG 模块寄存器基地址 */
+#define SRE_RNG_BASE                               (0xe40a0000UL)
+
+/******************************************************************************/
+/*                      MC RNG 寄存器定义                                     */
+/******************************************************************************/
+#define SRE_RNG_SEED_REG                       (SRE_RNG_BASE + 0x0)             /* PRBS_SEED为种子值，即产生器的初始状态值 */
+#define SRE_RNG_CTRL_REG                       (SRE_RNG_BASE + 0x4)             /* PRBS_CTRL为PRBS工作状态控制寄存器。 */
+#define SRE_RNG_RAN_NUM_REG                    (SRE_RNG_BASE + 0x10)            /* LFSR产生的随机数数值 */
+#define SRE_RNG_PHY_SEED_REG                   (SRE_RNG_BASE + 0x14)            /* 内部物理反相器震荡环产生的随机数 */
+#define SRE_RNG_RELOAD_ERR_REG                 (SRE_RNG_BASE + 0x84)
+
+
+/* DLHDCP 模块寄存器基地址 */
+#if 0         /* z00202052 */
+#define SRE_DLHDCP_BASE                              (0x140b0000UL)
+#else
+#define SRE_DLHDCP_BASE                              (0xe40b0000UL)
+#endif        /* z00202052 */
+
+/******************************************************************************/
+/*                      MC DLHDCP_CFG 寄存器定义                              */
+/******************************************************************************/
+#define SRE_DLHDCP_CFG_CTRL_REG         (SRE_DLHDCP_BASE + 0x0)      /* DLHDCP控制寄存器 */
+#define SRE_DLHDCP_CFG_BMU_POOL_ID_REG  (SRE_DLHDCP_BASE + 0x4)      /* BMU POOL ID选择寄存器 */
+#define SRE_DLHDCP_CFG_CACHEABLE_REG    (SRE_DLHDCP_BASE + 0x8)      /* Allocate配置寄存器 */
+#define SRE_DLHDCP_CFG_BMU_REQ_ADDR_REG  (SRE_DLHDCP_BASE + 0xC)      /* 申请BMU的地址 */
+#define SRE_DLHDCP_STS_REG              (SRE_DLHDCP_BASE + 0x10)     /* DLHDCP模块状态寄存器 */
+#define SRE_DLHDCP_M0_BUS_WR_CNT_REG    (SRE_DLHDCP_BASE + 0x14)     /* MASTER0总线写传输次数统计寄存器 */
+#define SRE_DLHDCP_M1_BUS_WR_TRANS_CNT_REG  (SRE_DLHDCP_BASE + 0x18)     /* MASTER1总线写传输次数统计寄存器 */
+#define SRE_DLHDCP_M0_BUS_RD_TRANS_CNT_REG  (SRE_DLHDCP_BASE + 0x1C)     /* MASTER0总线读传输次数统计寄存器 */
+#define SRE_DLHDCP_M1_BUS_RD_TRANS_CNT_REG  (SRE_DLHDCP_BASE + 0x20)     /* MASTER1总线读传输次数统计寄存器 */
+#define SRE_DLHDCP_POE_GET_CNT_REG      (SRE_DLHDCP_BASE + 0x24)     /* POE GET任务总次数寄存器 */
+#define SRE_DLHDCP_POE_ADD_CNT_REG      (SRE_DLHDCP_BASE + 0x28)     /* POE ADD任务总次数寄存器 */
+#define SRE_DLHDCP_POE_FAIL_CNT_REG     (SRE_DLHDCP_BASE + 0x2C)     /* POE GET和ADD任务失败次数寄存器 */
+#define SRE_DLHDCP_BMU_REQ_CNT_REG      (SRE_DLHDCP_BASE + 0x30)     /* BMU申请Buffer次数统计寄存器 */
+#define SRE_DLHDCP_BMU_FAIL_CNT_REG     (SRE_DLHDCP_BASE + 0x34)     /* BMU申请Buffer失败次数统计寄存器 */
+#define SRE_DLHDCP_M0_MEM_RD_CNT_REG    (SRE_DLHDCP_BASE + 0x38)     /* MASTER0 Memory读次数统计寄存器 */
+#define SRE_DLHDCP_M1_MEM_RD_CNT_REG    (SRE_DLHDCP_BASE + 0x3C)     /* MASTER1 Memory读次数统计寄存器 */
+#define SRE_DLHDCP_M0_MEM_WR_CNT_REG    (SRE_DLHDCP_BASE + 0x40)     /* MASTER0 Memory写次数统计寄存器 */
+#define SRE_DLHDCP_M1_MEM_WR_CNT_REG    (SRE_DLHDCP_BASE + 0x44)     /* MASTER1 Memory写次数统计寄存器 */
+#define SRE_DLHDCP_M0_MEM_FAIL_CNT_REG  (SRE_DLHDCP_BASE + 0x48)     /* MASTER0 Memory读写失败次数统计寄存器 */
+#define SRE_DLHDCP_M1_MEM_FAIL_CNT_REG  (SRE_DLHDCP_BASE + 0x4C)     /* MASTER1 Memory读写失败次数统计寄存器 */
+#define SRE_DLHDCP_RINT_REG             (SRE_DLHDCP_BASE + 0x50)     /* DLHDCP原始中断寄存器 */
+#define SRE_DLHDCP_INTMSK_REG           (SRE_DLHDCP_BASE + 0x54)     /* DLHDCP中断屏蔽寄存器 */
+#define SRE_DLHDCP_INTSTS_REG           (SRE_DLHDCP_BASE + 0x58)     /* DLHDCP中断状态寄存器 */
+#define SRE_DLHDCP_BDERR_ADDR_REG       (SRE_DLHDCP_BASE + 0x5C)     /* 异常DLHDCP_BD对应的HBD首地址 */
+#define SRE_DLHDCP_WRMEM_ERR_ADDR_REG   (SRE_DLHDCP_BASE + 0x60)     /* 写L3C/DDR失败时对应的写命令地址 */
+#define SRE_DLHDCP_RDMEM_ERR_ADDR_REG   (SRE_DLHDCP_BASE + 0x64)     /* 读L3C/DDR失败时对应的读命令地址 */
+#define SRE_DLHDCP_SRIO_ADDR_REG        (SRE_DLHDCP_BASE + 0x68)     /* SRIO任务寄存器地址 */
+#define SRE_DLHDCP_POE_GET_ADDR_REG     (SRE_DLHDCP_BASE + 0x6C)     /* 向POE取任务地址 */
+#define SRE_DLHDCP_POE_ADDR_ADDR_REG    (SRE_DLHDCP_BASE + 0x70)     /* 往POE添加任务地址 */
+#define SRE_DLHDCP_VMID_REG             (SRE_DLHDCP_BASE + 0x74)     /* VMID配置寄存器 */
+#define SRE_DLHDCP_NODE_CODE_REG        (SRE_DLHDCP_BASE + 0x78)     /* 任务源设备号 */
+#define SRE_DLHDCP_MST_DFX_CTRL_REG     (SRE_DLHDCP_BASE + 0x7C)     /* AXI_MST接口DFX配置寄存器 */
+#define SRE_DLHDCP_MST0_AVG_LAT_CNT_REG  (SRE_DLHDCP_BASE + 0x80)     /* AXI_MST_IF0接口读写平均延时统计 */
+#define SRE_DLHDCP_MST0_MAX_LAT_CNT_REG  (SRE_DLHDCP_BASE + 0x84)     /* AXI_MST_IFO接口读写最大延时统计 */
+#define SRE_DLHDCP_MST0_ACC_RD_REG      (SRE_DLHDCP_BASE + 0x88)     /* MSTO读总次数统计 */
+#define SRE_DLHDCP_MST0_ACC_WR_REG      (SRE_DLHDCP_BASE + 0x8C)     /* MSTO写总次数统计 */
+#define SRE_DLHDCP_MST1_AVG_LAT_CNT_REG  (SRE_DLHDCP_BASE + 0x90)     /* AXI_MST_IF1接口读写平均延时统计 */
+#define SRE_DLHDCP_MST1_MAX_LAT_CNT_REG  (SRE_DLHDCP_BASE + 0x94)     /* AXI_MST_IF1接口读写最大延时统计 */
+#define SRE_DLHDCP_MST1_ACC_RD_REG      (SRE_DLHDCP_BASE + 0x98)     /* MST1读写总次数统计 */
+#define SRE_DLHDCP_MST1_ACC_WR_REG      (SRE_DLHDCP_BASE + 0x9C)     /* MST1读写总次数统计 */
+#define SRE_DLHDCP_RD_OTSD_DEPTH_REG    (SRE_DLHDCP_BASE + 0xA0)     /* 读报文的outstanding深度 */
+#define SRE_DLHDCP_M0_BD_RRESP_NOK_STAT_REG  (SRE_DLHDCP_BASE + 0xA4)     /* MST0读BD读响应不正确统计值 */
+#define SRE_DLHDCP_MEM_BD_ID_NEQ_STAT0_REG  (SRE_DLHDCP_BASE + 0xA8)     /* MST0读BD读响应ID和读命令ID不匹配统计值 */
+#define SRE_DLHDCP_MEM_BD_RLAST_NOK_STAT0_REG  (SRE_DLHDCP_BASE + 0xAC)     /* MST0读BD的rlast不正确统计值 */
+#define SRE_DLHDCP_MEM_VBD_BUF_ADDR_NCACHE_STAT0_REG  (SRE_DLHDCP_BASE + 0xB0)     /* MST0读BD的VBD地址没有cacheline对齐的统计 */
+#define SRE_DLHDCP_MEM_RBD_BUF_ADDR_NCACHE_STAT0_REG  (SRE_DLHDCP_BASE + 0xB4)     /* MST0读BD的RBD地址没有cacheline对齐的统计 */
+#define SRE_DLHDCP_M1_BD_RRESP_NOK_STAT_REG  (SRE_DLHDCP_BASE + 0xB8)     /* MST1读BD读响应不正确统计值 */
+#define SRE_DLHDCP_MEM_BD_ID_NEQ_STAT1_REG  (SRE_DLHDCP_BASE + 0xBC)     /* MST1读BD读响应ID和读命令ID不匹配统计值 */
+#define SRE_DLHDCP_MEM_BD_RLAST_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0xC0)     /* MST1读BD的rlast不正确统计值 */
+#define SRE_DLHDCP_MEM_VBD_BUF_ADDR_NCACHE_STAT1_REG  (SRE_DLHDCP_BASE + 0xC4)     /* MST1读BD的VBD地址没有cacheline对齐的统计 */
+#define SRE_DLHDCP_MEM_RBD_BUF_ADDR_NCACHE_STAT1_REG  (SRE_DLHDCP_BASE + 0xC8)     /* MST1读BD的RBD地址没有cacheline对齐的统计 */
+#define SRE_DLHDCP_PKT_LEN_ZERO_STAT0_REG  (SRE_DLHDCP_BASE + 0xCC)     /* 通过MST0读取的描述符报文总长度为0的个数统计 */
+#define SRE_DLHDCP_MEM_MSG_RRESP_NOK_STAT0_REG  (SRE_DLHDCP_BASE + 0xD0)     /* MST0读MSG读响应不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_ID_NEQ_STAT0_REG  (SRE_DLHDCP_BASE + 0xD4)     /* MST0读MSG读响应ID和读命令ID不匹配统计值 */
+#define SRE_DLHDCP_MEM_MSG_RLAST_NOK_STAT0_REG  (SRE_DLHDCP_BASE + 0xD8)     /* MST0读MSG的rlast不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_BRESP_NOK_STAT_REG  (SRE_DLHDCP_BASE + 0xDC)     /* MST0写MSG写响应不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_BID_NEQ_STAT0_REG  (SRE_DLHDCP_BASE + 0xE0)     /* MST0写MSG写响应ID和写命令ID不匹配统计值 */
+#define SRE_DLHDCP_TASK_PRO_AVG_TIME_STAT0_REG  (SRE_DLHDCP_BASE + 0xE4)     /* 通过MST0处理的任务的平均处理时间 */
+#define SRE_DLHDCP_TASK_PRO_MAX_TIME_STAT0_REG  (SRE_DLHDCP_BASE + 0xE8)     /* 通过MST0处理的任务的最大处理时间 */
+#define SRE_DLHDCP_TASK_PRO_TIME_CNT_OVFL_STAT0_REG  (SRE_DLHDCP_BASE + 0xEC)     /* 通过MST0处理的任务的最大处理时间计数器溢出次数统计 */
+#define SRE_DLHDCP_PKT_LEN_ZERO_STAT1_REG  (SRE_DLHDCP_BASE + 0xF0)     /* 通过MST1读取的描述符报文总长度为0的个数统计 */
+#define SRE_DLHDCP_MEM_MSG_RRESP_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0xF4)     /* MST1读MSG读响应不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_ID_NEQ_STAT1_REG  (SRE_DLHDCP_BASE + 0xF8)     /* MST1读MSG读响应ID和读命令ID不匹配统计值 */
+#define SRE_DLHDCP_MEM_MSG_RLAST_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0xFC)     /* MST1读MSG的rlast不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_BRESP_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0x100)    /* MST1写MSG写响应不正确统计值 */
+#define SRE_DLHDCP_MEM_MSG_BID_NEQ_STAT1_REG  (SRE_DLHDCP_BASE + 0x104)    /* MST1写MSG写响应ID和写命令ID不匹配统计值 */
+#define SRE_DLHDCP_TASK_PRO_AVG_TIME_STAT1_REG  (SRE_DLHDCP_BASE + 0x108)    /* 通过MST1处理的任务的平均处理时间 */
+#define SRE_DLHDCP_TASK_PRO_MAX_TIME_STAT1_REG  (SRE_DLHDCP_BASE + 0x10C)    /* 通过MST1处理的任务的最大处理时间 */
+#define SRE_DLHDCP_TASK_PRO_TIME_CNT_OVFL_STAT1_REG  (SRE_DLHDCP_BASE + 0x110)    /* 通过MST1处理的任务的最大处理时间计数器溢出次数统计 */
+#define SRE_DLHDCP_BD_PKT_SIZE_ZERO_STAT0_REG  (SRE_DLHDCP_BASE + 0x114)    /* MST0处理的任务的pkt size 为0的任务次数统计 */
+#define SRE_DLHDCP_BD_FIFO_OVFL_STAT0_REG  (SRE_DLHDCP_BASE + 0x118)    /* MST0 BD FIFO满写的次数统计 */
+#define SRE_DLHDCP_BD_FIFO_UDFL_STAT0_REG  (SRE_DLHDCP_BASE + 0x11C)    /* MSTO BD FIFO空读的次数统计 */
+#define SRE_DLHDCP_SHAPING_FIFO_OVFL_STAT0_REG  (SRE_DLHDCP_BASE + 0x120)    /* MST0 SHAPING FIFO满写的次数统计 */
+#define SRE_DLHDCP_SHAPING_FIFO_UDFL_STAT0_REG  (SRE_DLHDCP_BASE + 0x124)    /* MST0 SHAPING FIFO空读的次数统计 */
+#define SRE_DLHDCP_BD_PKT_SIZE_ZERO_STAT1_REG  (SRE_DLHDCP_BASE + 0x128)    /* MST1处理的任务的pkt size 为0的任务次数统计 */
+#define SRE_DLHDCP_BD_FIFO_OVFL_STAT1_REG  (SRE_DLHDCP_BASE + 0x12C)    /* MST1 BD FIFO满写的次数统计 */
+#define SRE_DLHDCP_BD_FIFO_UDFL_STAT1_REG  (SRE_DLHDCP_BASE + 0x130)    /* MST1 BD FIFO空读的次数统计 */
+#define SRE_DLHDCP_SHAPING_FIFO_OVFL_STAT1_REG  (SRE_DLHDCP_BASE + 0x134)    /* MST1 SHAPING FIFO满写的次数统计 */
+#define SRE_DLHDCP_SHAPING_FIFO_UDFL_STAT1_REG  (SRE_DLHDCP_BASE + 0x138)    /* MST1 SHAPING FIFO空读的次数统计 */
+#define SRE_DLHDCP_PKT_LEN_NOK_STATO_REG  (SRE_DLHDCP_BASE + 0x13C)    /* MST0报文总长度和各个结点长度的累加值不匹配 */
+#define SRE_DLHDCP_PKT_BUF_NUM_NOK_STAT0_REG  (SRE_DLHDCP_BASE + 0x140)    /* MST0 BUF_NUM数量不正确统计 */
+#define SRE_DLHDCP_PKT_NXT_BUF_ADDR_NOK_STAT0_REG  (SRE_DLHDCP_BASE + 0x144)    /* MST0 下一结点地址不正确统计 */
+#define SRE_DLHDCP_PKT_LEN_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0x148)    /* MST1报文总长度和各个结点长度的累加值不匹配 */
+#define SRE_DLHDCP_PKT_BUF_NUM_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0x14C)    /* MST1 BUF_NUM数量不正确统计 */
+#define SRE_DLHDCP_PKT_NXT_BUF_ADDR_NOK_STAT1_REG  (SRE_DLHDCP_BASE + 0x150)    /* MST1 下一结点地址不正确统计 */
+#define SRE_DLHDCP_ABNORM_TYPE0_REG     (SRE_DLHDCP_BASE + 0x154)    /* 异常类型寄存器 */
+#define SRE_DLHDCP_ABNORM_INFORMATION0_REG  (SRE_DLHDCP_BASE + 0x158)    /* 异常信息寄存器 */
+#define SRE_DLHDCP_ABNORM_TYPE1_REG     (SRE_DLHDCP_BASE + 0x15C)    /* 异常类型寄存器 */
+#define SRE_DLHDCP_ABNORM_INFORMATION1_REG  (SRE_DLHDCP_BASE + 0x160)    /* 异常信息寄存器 */
+#define SRE_DLHDCP_CFG_RSV0_REG         (SRE_DLHDCP_BASE + 0x164)    /* DLHDCP 配置保留寄存器0 */
+#define SRE_DLHDCP_CFG_RSV1_REG         (SRE_DLHDCP_BASE + 0x168)    /* DLHDCP 配置保留寄存器1 */
+#define SRE_DLHDCP_CFG_RSV2_REG         (SRE_DLHDCP_BASE + 0x16C)    /* DLHDCP 配置保留寄存器2 */
+#define SRE_DLHDCP_STS_RSV0_REG         (SRE_DLHDCP_BASE + 0x170)    /* DLHDCP 状态保留寄存器0 */
+#define SRE_DLHDCP_STS_RSV1_REG         (SRE_DLHDCP_BASE + 0x174)    /* DLHDCP 状态保留寄存器1 */
+#define SRE_DLHDCP_STS_RSV2_REG         (SRE_DLHDCP_BASE + 0x178)    /* DLHDCP 状态保留寄存器2 */
+
+/* ULHDCP_REG 模块寄存器基地址 */
+#define SRE_ULHDCP_REG_BASE             (0x10870000)
+
+/******************************************************************************/
+/*                      MC ULHDCP_REG 寄存器定义                   */
+/******************************************************************************/
+#define SRE_ULHDCP_REG_CFG_ENABLE_REG  (SRE_ULHDCP_REG_BASE + 0x0)  /* ULHDCP使能控制寄存器。 */
+#define SRE_ULHDCP_REG_CFG_BMU_POOL_ID_REG  (SRE_ULHDCP_REG_BASE + 0x4)  /* BMU POOL ID选择寄存器。 */
+#define SRE_ULHDCP_REG_CFG_BMU_POOL_SIZE_REG  (SRE_ULHDCP_REG_BASE + 0x8)  /* Buffer空间大小配置寄存器。 */
+#define SRE_ULHDCP_REG_CFG_BMU_REQ_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x10)  /* 申请BMU的地址。 */
+#define SRE_ULHDCP_REG_MODE_REG  (SRE_ULHDCP_REG_BASE + 0x14)  /* ULHDCP状态寄存器 */
+#define SRE_ULHDCP_REG_M0_BUS_WR_TRANS_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x18)  /* MASTER总线写传输次数统计寄存器。 */
+#define SRE_ULHDCP_REG_STS_REG   (SRE_ULHDCP_REG_BASE + 0x1C)  /* ULHDCP模块状态寄存器 */
+#define SRE_ULHDCP_REG_M0_BUS_RD_TRANS_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x20)  /* MASTER总线读传输次数统计寄存器。 */
+#define SRE_ULHDCP_REG_POE_ADD_TRS_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x34)  /* POE ADD任务总次数寄存器。 */
+#define SRE_ULHDCP_REG_POE_GET_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x48)  /* POE GET任务总次数寄存器。 */
+#define SRE_ULHDCP_REG_POE_ADD_RLS_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x4C)  /* POE ADD任务总次数寄存器。 */
+#define SRE_ULHDCP_REG_POE_FAIL_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x50)  /* POE GET或者ADD任务失败次数寄存器。 */
+#define SRE_ULHDCP_REG_BMU_REQ_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x60)  /* BMU申请Buffer次数统计寄存器。 */
+#define SRE_ULHDCP_REG_BMU_FAIL_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x64)  /* BMU申请Buffer失败次数统计寄存器。 */
+#define SRE_ULHDCP_REG_ADD_POE_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x68)  /* ADD POE失败次数统计寄存器。 */
+#define SRE_ULHDCP_REG_M0_MEM_RD_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x6C)  /* MASTER Memory读次数统计寄存器。 */
+#define SRE_ULHDCP_REG_M0_MEM_WR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x70)  /* MASTER Memory写次数统计寄存器。 */
+#define SRE_ULHDCP_REG_L3CACHE_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x74)  /* ULHDCP模块读写数据时是否经过L3 Cache控制寄存器。 */
+#define SRE_ULHDCP_REG_RINT_REG  (SRE_ULHDCP_REG_BASE + 0x78)  /* ULHDCP原始中断寄存器。 */
+#define SRE_ULHDCP_REG_INTMSK_REG  (SRE_ULHDCP_REG_BASE + 0x7C)  /* ULHDCP中断屏蔽寄存器。 */
+#define SRE_ULHDCP_REG_INTSTS_REG  (SRE_ULHDCP_REG_BASE + 0x80)  /* ULHDCP中断状态寄存器。 */
+#define SRE_ULHDCP_REG_POE_GET_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x98)  /* 向POE取任务地址。 */
+#define SRE_ULHDCP_REG_POE_ADDR_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x9C)  /* 往POE添加任务地址。 */
+#define SRE_ULHDCP_REG_VMID_REG  (SRE_ULHDCP_REG_BASE + 0xA0)  /* VMID配置寄存器。 */
+#define SRE_ULHDCP_REG_SKIP1_LEN_REG  (SRE_ULHDCP_REG_BASE + 0xD0)  /* ULHDCP模块SKIP1长度配置寄存器。 */
+#define SRE_ULHDCP_REG_SKIP2_LEN_REG  (SRE_ULHDCP_REG_BASE + 0xD4)  /* ULHDCP模块SKIP2长度配置寄存器。 */
+
+#define SRE_ULHDCP_REG_ERR_STA_REG  (SRE_ULHDCP_REG_BASE + 0xDC)  /* ULHDCP模块内部告警查询接存器。 */
+#define SRE_ULHDCP_REG_PKTLEN_ERR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0xE0)  /* ULHDCP模块处理的长度为0的数据包个数统计计数器。 */
+#define SRE_ULHDCP_REG_INVLD_TASK_CNT_REG  (SRE_ULHDCP_REG_BASE + 0xE4)  /* ULHDCP模块处理的无效任务个数统计计数器。 */
+#define SRE_ULHDCP_REG_CIPHER_ERR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0xE8)  /* ULHDCP模块搬移的SEC BD的加密范围错误的数据包个数统计计数器。 */
+#define SRE_ULHDCP_REG_AUTH_ERR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0xEC)  /* ULHDCP模块搬移的SEC BD的认证范围错误的数据包个数统计计数器。 */
+#define SRE_ULHDCP_REG_MAC_ERR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0xF0)  /* ULHDCP模块搬移的SEC BD的认证码地址错误的数据包个数统计计数器。 */
+#define SRE_ULHDCP_REG_BIG_ENDIAN_REG  (SRE_ULHDCP_REG_BASE + 0xF4)  /* ULHDCP模块访问DDR时的大小端模式配置寄存器。 */
+#define SRE_ULHDCP_REG_NODE_CODE_REG  (SRE_ULHDCP_REG_BASE + 0xF8)  /* ULHDCP模块设备号配置寄存器。 */
+#define SRE_ULHDCP_REG_BDERR_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0xFC)  /* ULHDCP模块异常BD对应的VBD首地址 */
+#define SRE_ULHDCP_REG_WRMEM_ERR_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x100)  /* ULHDCP模块写L3C/DDR失败时对应的写命令地址 */
+#define SRE_ULHDCP_REG_RDMEM_ERR_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x104)  /* ULHDCP模块读L3C/DDR失败时对应的读命令地址 */
+#define SRE_ULHDCP_REG_MEM_FAIL_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x108)  /* ULHDCP模块读写Memory失败次数统计寄存器 */
+#define SRE_ULHDCP_REG_VBD_ERR0_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x10C)  /* ULHDCP模块各VBD错误数据包的个数统计计数器。 */
+#define SRE_ULHDCP_REG_VBD_ERR1_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x110)  /* ULHDCP模块各VBD错误数据包的个数统计计数器。 */
+#define SRE_ULHDCP_REG_VBD_ERR2_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x114)  /* ULHDCP模块各VBD错误数据包的个数统计计数器。 */
+#define SRE_ULHDCP_REG_BMU_REQ_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x17C)  /* ULHDCP模块读BMU配置控制寄存器。 */
+#define SRE_ULHDCP_REG_GET_POE_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x180)  /* ULHDCP模块GET POE配置控制寄存器。 */
+#define SRE_ULHDCP_REG_ADD_POE_RLS_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x184)  /* ULHDCP模块ADD POE（缓存释放）配置控制寄存器。 */
+#define SRE_ULHDCP_REG_ADD_POE_TRS_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x18C)  /* ULHDCP模块ADD POE（报文转发）配置控制寄存器。 */
+#define SRE_ULHDCP_REG_BMU_REQ_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x190)  /* ULHDCP模块申请BMU缓存时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_POE_GET_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x194)  /* ULHDCP模块GET POE时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_VBD_RD_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x198)  /* ULHDCP模块读VBD时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_PKT_RD_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x19C)  /* ULHDCP模块读数据包时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_POE_ADDTRS_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x1A0)  /* ULHDCP模块ADD POE（报文转发）时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_POE_ADDRLS_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x1A4)  /* ULHDCP模块ADD POE（缓存释放）时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_BD_WR_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x1A8)  /* ULHDCP模块写copy后的BD时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_PKT_WR_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x1AC)  /* ULHDCP模块写copy后的数据包时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_RW_RSV0_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1B0)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_RW_RSV1_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1B4)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_RW_RSV2_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1B8)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_RO_RSV0_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1C0)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_RO_RSV1_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1C4)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_RO_RSV2_DFX_REG  (SRE_ULHDCP_REG_BASE + 0x1C8)  /* ULHDCP模块用于DFX的保留寄存器。 */
+#define SRE_ULHDCP_REG_AXIRD_DFX_CFG_REG  (SRE_ULHDCP_REG_BASE + 0x1D0)  /* ULHDCP模块AXI总线读命令通道DFX配置寄存器。 */
+#define SRE_ULHDCP_REG_AXIWR_DFX_CFG_REG  (SRE_ULHDCP_REG_BASE + 0x1D4)  /* ULHDCP模块AXI总线写命令通道DFX配置寄存器。 */
+#define SRE_ULHDCP_REG_AXIRD_DFX_RPT_REG  (SRE_ULHDCP_REG_BASE + 0x1D8)  /* ULHDCP模块AXI总线读命令通道DFX状态上报寄存器。 */
+#define SRE_ULHDCP_REG_AXIWR_DFX_RPT_REG  (SRE_ULHDCP_REG_BASE + 0x1DC)  /* ULHDCP模块AXI总线写命令通道DFX状态上报寄存器。 */
+#define SRE_ULHDCP_REG_AXIWR_TIMES_RPT_REG  (SRE_ULHDCP_REG_BASE + 0x1E0)  /* ULHDCP模块AXI总线写命令通道写次数状态上报寄存器。 */
+#define SRE_ULHDCP_REG_AXIRD_TIMES_RPT_REG  (SRE_ULHDCP_REG_BASE + 0x1E4)  /* ULHDCP模块AXI总线读命令通道写次数状态上报寄存器。 */
+#define SRE_ULHDCP_REG_AXI_OTSD_0CNT_REG  (SRE_ULHDCP_REG_BASE + 0x1E8)  /* ULHDCP模块AXI总线读命令通道OutStanding深度上报寄存器。 */
+#define SRE_ULHDCP_REG_AXI_OTSD_1CNT_REG  (SRE_ULHDCP_REG_BASE + 0x1EC)  /* ULHDCP模块AXI总线写命令通道写OutStanding深度上报寄存器。 */
+#define SRE_ULHDCP_REG_ADDSPE_OVERTIME_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x1F0)  /* ULHDCP模块ADD POE（核间消息）时超时控制寄存器。 */
+#define SRE_ULHDCP_REG_POE_SPE_ADDR_REG  (SRE_ULHDCP_REG_BASE + 0x1F4)  /* ULHDCP模块向POE模块ADD核间消息时的基地址配置寄存器。 */
+#define SRE_ULHDCP_REG_ROHCBD_ERR_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x1F8)  /* ULHDCP模块搬移的ROHC BD错误的数据包个数统计计数器。 */
+#define SRE_ULHDCP_REG_ADDSPE_CNT_REG  (SRE_ULHDCP_REG_BASE + 0x1FC)  /* ULHDCP模块ADD核间消息次数统计计数器。 */
+#define SRE_ULHDCP_REG_ADD_POE_SPE_CTRL_REG  (SRE_ULHDCP_REG_BASE + 0x200)  /* ULHDCP模块ADD POE（核间消息）配置控制寄存器。 */
+
+
+
+//******************************************************************************
+
+/* SPPE 模块寄存器基地址 */
+#define  MC_SPPE_REG_BASE                                 (0x20000000)
+
+/******************************************************************************/
+/*                      MC SPPE 寄存器定义                                    */
+/******************************************************************************/
+#define MC_SAP_OFFSET                                         (0x0007000)
+
+#define MC_SPPE_SAP_THREAD_RBA_REQ_IOOP_0_REG      (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x0)               /* RBA Request的IO操作类型控制 */
+#define MC_SPPE_SAP_THREAD_RBA_REQ_ADDR_0_REG      (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x4)               /* RBA Request中LOAD、STORE、LOOKUP指令中CTRL Word中的ADDR域 */
+#define MC_SPPE_SAP_THREAD_RBA_REQ_CTRL_0_REG       (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x8)               /* RBA Request中LOAD、STORE、LOOKUP指令中CTRL Word中的CTRL域 */
+#define MC_SPPE_SAP_THREAD_RBA_REQ_START_0_REG     (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0xC)               /* RBA Request启动控制 */
+#define MC_SPPE_SAP_THREAD_RBA_STATUS_0_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x10)              /* RBA线程控制状态寄存器 */
+#define MC_SPPE_SAP_THREAD_RBA_TOUT_TH_0_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x20)              /* 该寄存器为线程RBA访问Timer计时的阈值 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA0_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x40)              /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA1_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x44)              /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA2_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x48)              /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA3_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x4c)              /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA4_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x50)              /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA5_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x54)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA6_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x58)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA7_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x5c)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA8_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x60)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA9_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x64)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA10_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x64)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA11_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x6c)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA12_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x70)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA13_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x74)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA14_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x78)             /* RBA request或RBA response中的DATA域 */
+#define MC_SPPE_SAP_THREAD_RBA_DATA15_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x7C)             /* RBA request或RBA response中的DATA域 */
+
+
+#define MC_SPPE_SAP_AVAIL_THREAD_BADDR_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET + 0x800)             /* CPU申请线程基地址寄存器 */
+#define MC_SPPE_SAP_RELEASE_THREAD_BADDR_REG         (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x810)             /* CPU释放线程基地址寄存器 */
+#define MC_SPPE_SAP_THREAD_ALLOC_FLAG_REG            (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x814)             /* 线程分配状态寄存器 */
+#define MC_SPPE_SAP_MEM_INIT_START_REG               (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x820)             /* SAP Memory初始化触发寄存器 */
+#define MC_SPPE_SAP_MEM_INIT_STATUS_REG              (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x824)             /* SAP Memory初始化状态寄存器 */
+#define MC_SPPE_SAP_INT_RINT_REG                     (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x830)             /* SAP中断原始寄存器 */
+#define MC_SPPE_SAP_INT_STATUS_REG                   (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x834)             /* SAP中断状态寄存器 */
+#define MC_SPPE_SAP_INT_EN_REG                       (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x838)             /* SAP中断使能寄存器 */
+#define MC_SPPE_SAP_BUSY_ACCESS_BADDR_REG            (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x840)             /* busy_access中断发生时，记录重复访问的线程寄存器基地址 */
+#define MC_SPPE_SAP_INVALID_REL_BADDR_REG            (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x844)             /* invalid_rel中断发生时，记录被错误写入的线程寄存器基地址 */
+#define MC_SPPE_SAP_DUPL_REL_BADDR_REG               (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x848)             /* dupl_rel中断发生时，记录重复释放的线程寄存器基地址 */
+#define MC_SPPE_SAP_INVALID_IOOP_BADDR_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x84C)             /* invalid_ioop中断发生时，记录写入IOOP错误的线程寄存器基地址 */
+#define MC_SPPE_SAP_INVALID_RESP_BADDR_REG           (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x850)             /* invalid_resp中断发生时，记录错误返回响应的线程ID对应的线程寄存器基地址 */
+#define MC_SPPE_SAP_MUTEX_QUEUE_FULL_BADDR_REG       (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x854)             /* Mutex Queue满时，记录A15写入RELEASE_THREAD_BADDR的线程寄存器组基地址 */
+#define MC_SPPE_SAP_OE_ACC_ERR_BADDR_REG             (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x858)             /* A15通过SAP错误地发起OE访问时，记录线程寄存器组基地址 */
+#define MC_SPPE_SAP_IERR_INSERT_REG                  (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x880)             /* 寄存器允许用户在准备写入SAP内部Memory的数据中插入错误 */
+#define MC_SPPE_SAP_IERR_C_INFO_REG                  (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x884)             /* 记录可校正Memory一致性错误的Memory ID */
+#define MC_SPPE_SAP_IERR_U_INFO_REG                  (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x888)             /* 记录不可校正Memory一致性错误的Memory ID */
+#define MC_SPPE_SAP_IERR_C_CNT_REG                   (MC_SPPE_REG_BASE  +MC_SAP_OFFSET+ 0x88C)             /* 对可校正Memory一致性错误计数，读清。 */
+#define MC_SPPE_SAP_IERR_U_CNT_REG                   (MC_SPPE_REG_BASE +MC_SAP_OFFSET+ 0x890)             /* 对不可校正Memory一致性错误计数，读清。 */
+
+
+#define MC_MASTER_ATOM_CLK_ENABLE         (MC_SPPE_REG_BASE + 0x0003004C)
+/******************************************************************************/
+/*                      TS 寄存器定义                                    */
+/******************************************************************************/
+#define MC_SE_EM_INT_STATUS	                 (MC_SPPE_REG_BASE + 0x00010004)
+#define MC_SE_EM_INT_ENABLE	                 (MC_SPPE_REG_BASE + 0x00010008)
+#define MC_SE_EM_INT_SET	                          (MC_SPPE_REG_BASE + 0x0001000C)
+#define MC_SE_DISP_IERR_F_INFO	        (MC_SPPE_REG_BASE + 0x00010020)
+#define MC_SE_DISP_IERR_U_CNT	        (MC_SPPE_REG_BASE + 0x00010024)
+#define MC_SE_DISP_IERR_U_INFO	        (MC_SPPE_REG_BASE + 0x00010028)
+#define MC_SE_DISP_IERR_C_CNT	        (MC_SPPE_REG_BASE + 0x0001002C)
+#define MC_SE_DISP_IERR_C_INFO	        (MC_SPPE_REG_BASE + 0x00010030)
+#define MC_SE_DISP_BAD_CMD_CNT	        (MC_SPPE_REG_BASE + 0x0001003C)
+#define MC_SE_DISP_BAD_CMD_INFO	        (MC_SPPE_REG_BASE + 0x00010040)
+#define MC_SE_DISP_FIFO_OVF_CNT	        (MC_SPPE_REG_BASE + 0x0001004C)
+#define MC_SE_DISP_FIFO_OVF_INFO	        (MC_SPPE_REG_BASE + 0x00010050)
+#define MC_SE_DISP_QUE_LPM_CNT	        (MC_SPPE_REG_BASE + 0x00010060)
+#define MC_SE_DISP_QUE_LCAM_CNT	        (MC_SPPE_REG_BASE + 0x00010064)
+#define MC_SE_DISP_QUE_EM_SLOW_CNT	(MC_SPPE_REG_BASE + 0x00010068)
+#define MC_SE_DISP_QUE_EM_FAST_CNT	(MC_SPPE_REG_BASE + 0x0001006C)
+#define MC_SE_DISP_FIFO_STATUS0	        (MC_SPPE_REG_BASE + 0x00010070)
+#define MC_SE_EM_DISP_EM_CMD_FIFO_TH	(MC_SPPE_REG_BASE + 0x00010074)
+#define MC_SE_EM_DISP_LPM_CMD_FIFO_TH	(MC_SPPE_REG_BASE + 0x00010078)
+#define MC_SE_DISP_PROBE0_EN	                 (MC_SPPE_REG_BASE + 0x000100A0)
+#define MC_SE_DISP_PROBE0_DONE	        (MC_SPPE_REG_BASE + 0x000100A4)
+#define MC_SE_DISP_PROBE0_MSK 	        (MC_SPPE_REG_BASE + 0x000100A8)
+#define MC_SE_DISP_PROBE0_MSK16	        (MC_SPPE_REG_BASE + 0x000100E8)
+#define MC_SE_DISP_PROBE0_MSK17	        (MC_SPPE_REG_BASE + 0x000100EC)
+#define MC_SE_DISP_PROBE0_DAT 	        (MC_SPPE_REG_BASE + 0x000100F0)
+#define MC_SE_DISP_PROBE0_DAT16	        (MC_SPPE_REG_BASE + 0x00010130)
+#define MC_SE_DISP_PROBE0_DAT17	        (MC_SPPE_REG_BASE + 0x00010134)
+#define MC_SE_DISP_PROBE0_RSLT 	        (MC_SPPE_REG_BASE + 0x00010138)
+#define MC_SE_DISP_PROBE0_RSLT16	        (MC_SPPE_REG_BASE + 0x00010178)
+#define MC_SE_DISP_PROBE0_RSLT17	        (MC_SPPE_REG_BASE + 0x0001017C)
+#define MC_SE_DISP_PROBE1_EN	                 (MC_SPPE_REG_BASE + 0x00010180)
+#define MC_SE_DISP_PROBE1_DONE	        (MC_SPPE_REG_BASE + 0x00010184)
+#define MC_SE_DISP_PROBE1_MSK 	        (MC_SPPE_REG_BASE + 0x00010188)
+#define MC_SE_DISP_PROBE1_MSK16	        (MC_SPPE_REG_BASE + 0x000101C8)
+#define MC_SE_DISP_PROBE1_DAT 	        (MC_SPPE_REG_BASE + 0x000101CC)
+#define MC_SE_DISP_PROBE1_DAT16	        (MC_SPPE_REG_BASE + 0x0001020C)
+#define MC_SE_DISP_PROBE1_RSLT 	        (MC_SPPE_REG_BASE + 0x00010210)
+#define MC_SE_DISP_PROBE1_RSLT16	        (MC_SPPE_REG_BASE + 0x00010250)
+#define MC_SE_DISP_ATOM_HASH_CNT	(MC_SPPE_REG_BASE + 0x00010254)
+#define MC_SE_DISP_ATOM_MOD_CNT        (MC_SPPE_REG_BASE + 0x00010258)
+#define MC_SE_DISP_ATOM_POP_CNT	        (MC_SPPE_REG_BASE + 0x0001025C)
+#define MC_SE_DISP_ATOM_PUSH_CNT	(MC_SPPE_REG_BASE + 0x00010260)
+#define MC_SE_DISP_ATOM_LPM_SRCH_CNT	(MC_SPPE_REG_BASE + 0x00010264)
+#define MC_SE_DISP_ATOM_LCAM_SRCH_CNT	(MC_SPPE_REG_BASE + 0x00010268)
+#define MC_SE_DISP_RBA_DISP_CNT	                  (MC_SPPE_REG_BASE + 0x00010270)
+#define MC_SE_DISP_RBA_CNT	                          (MC_SPPE_REG_BASE + 0x00010274)
+#define MC_SE_DISP_EM_0_CNT	                          (MC_SPPE_REG_BASE + 0x00010278)
+#define MC_SE_DISP_EM_1_CNT	                          (MC_SPPE_REG_BASE + 0x0001027C)
+#define MC_SE_DISP_LPM_0_CNT	                          (MC_SPPE_REG_BASE + 0x00010280)
+#define MC_SE_DISP_ATOM_READ_CNT	         (MC_SPPE_REG_BASE + 0x00010290)
+#define MC_SE_DISP_ATOM_WRITE_CNT	         (MC_SPPE_REG_BASE + 0x00010294)
+#define MC_SE_DISP_ATOM_EM_SRCH_CNT	(MC_SPPE_REG_BASE + 0x00010298)
+#define MC_SE_DISP_ATOM_LOCK_CNT	         (MC_SPPE_REG_BASE + 0x0001029C)
+#define MC_SE_DISP_ATOM_UNLOCK_CNT	         (MC_SPPE_REG_BASE + 0x000102A0)
+#define MC_SE_DISP_EM_CFG_TBL 	                  (MC_SPPE_REG_BASE + 0x00010300)
+#define MC_SE_DISP_EM_HT1_SIZE 	                  (MC_SPPE_REG_BASE + 0x00010340)
+#define MC_SE_DISP_EM_HT1_INDEX_MASK 	(MC_SPPE_REG_BASE + 0x00010380)
+#define MC_SE_DISP_CRC_CFG_VALUE        (MC_SPPE_REG_BASE + 0x000103C0)
+#define MC_SE_DISP_CRC_INIT_MATRIX	(MC_SPPE_REG_BASE + 0x00010400)
+#define MC_SE_DISP_LOCK_TAB_WORD	(MC_SPPE_REG_BASE + 0x00010500)
+#define MC_SE_DISP_VQ_DEBUG_MOD	        (MC_SPPE_REG_BASE + 0x00010600)
+#define MC_SE_DISP_VQ_DEBUG_REQ	        (MC_SPPE_REG_BASE + 0x00010604)
+#define MC_SE_DISP_VQ_DEBUG_DONE	(MC_SPPE_REG_BASE + 0x00010608)
+#define MC_SE_DISP_VQ_DEBUG_DATA0	(MC_SPPE_REG_BASE + 0x0001060C)
+#define MC_SE_DISP_VQ_DEBUG_DATA1	(MC_SPPE_REG_BASE + 0x00010610)
+#define MC_SE_EM_CAM_INIT_DONE	        (MC_SPPE_REG_BASE + 0x00015000)
+#define MC_SE_EM_CAM_SCAN_PRD	        (MC_SPPE_REG_BASE + 0x00015004)
+#define MC_SE_EM_CAM_SCAN_EN	        (MC_SPPE_REG_BASE + 0x00015008)
+#define MC_SE_LPM_CAM_BASE_ADDR	        (MC_SPPE_REG_BASE + 0x0001500C)
+#define MC_SE_EM_CAM_BASE_ADDR	        (MC_SPPE_REG_BASE + 0x00015010)
+#define MC_SE_EM_CAM_RCL_TH	                         (MC_SPPE_REG_BASE + 0x00015014)
+#define MC_SE_EM_CAM_HPTR_L245W	        (MC_SPPE_REG_BASE + 0x00015018)
+#define MC_SE_EM_CAM_HPTR_L245R	                 (MC_SPPE_REG_BASE + 0x0001501C)
+#define MC_SE_EM_CAM_TPTR_L245W	        (MC_SPPE_REG_BASE + 0x00015020)
+#define MC_SE_EM_CAM_TPTR_L245R	                 (MC_SPPE_REG_BASE + 0x00015024)
+#define MC_SE_EM_CAM_IDLENTRY_L245W	        (MC_SPPE_REG_BASE + 0x00015028)
+#define MC_SE_EM_CAM_IDLENTRY_L245R	        (MC_SPPE_REG_BASE + 0x0001502C)
+#define MC_SE_EM_CAM_HPTR_L490W	        (MC_SPPE_REG_BASE + 0x00015030)
+#define MC_SE_EM_CAM_HPTR_L490R	                 (MC_SPPE_REG_BASE + 0x00015034)
+#define MC_SE_EM_CAM_TPTR_L490W	        (MC_SPPE_REG_BASE + 0x00015038)
+#define MC_SE_EM_CAM_TPTR_L490R	                 (MC_SPPE_REG_BASE + 0x0001503C)
+#define MC_SE_EM_CAM_IDLENTRY_L490W        (MC_SPPE_REG_BASE + 0x00015040)
+#define MC_SE_EM_CAM_IDLENTRY_L490R	        (MC_SPPE_REG_BASE + 0x00015044)
+#define MC_SE_EM_CFG_TBL 	                          (MC_SPPE_REG_BASE + 0x00015100)
+#define MC_SE_EM_KT_SIZE 	                                   (MC_SPPE_REG_BASE + 0x00015140)
+#define MC_SE_EM_HT1_BASE_ADDR 	        (MC_SPPE_REG_BASE + 0x00015180)
+#define MC_SE_EM_KT_BASE_ADDR 	        (MC_SPPE_REG_BASE + 0x000151C0)
+#define MC_SE_EM_AGE_BASE_ADDR 	        (MC_SPPE_REG_BASE + 0x00015200)
+#define MC_SE_EM_FREE_FIFO_UP_TH 	(MC_SPPE_REG_BASE + 0x00015240)
+#define MC_SE_EM_FREE_FIFO_LOW_TH      (MC_SPPE_REG_BASE + 0x00015280)
+#define MC_SE_EM_KT_HEAD_POINTER 	(MC_SPPE_REG_BASE + 0x000152C0)
+#define MC_SE_EM_KT_TAIL_POINTER 	(MC_SPPE_REG_BASE + 0x00015300)
+#define MC_SE_LPM_CAM_GMR                       (MC_SPPE_REG_BASE + 0x00015340)
+#define MC_SE_LPM_CAM_SEL_GMR	        (MC_SPPE_REG_BASE + 0x00015400)
+#define MC_SE_EM_POOL_EN	                 (MC_SPPE_REG_BASE + 0x00015410)
+#define MC_SE_EM_TIMEOUT_TH	                 (MC_SPPE_REG_BASE + 0x0001541C)
+#define MC_SE_EM_FIFO_OVF_CNT	        (MC_SPPE_REG_BASE + 0x00015434)
+#define MC_SE_EM_FIFO_OVF_INFO	        (MC_SPPE_REG_BASE + 0x00015438)
+#define MC_SE_EM_TIMEOUT_CNT	        (MC_SPPE_REG_BASE + 0x0001543C)
+#define MC_SE_EM_TIMEOUT_INFO	        (MC_SPPE_REG_BASE + 0x00015440)
+#define MC_SE_EM_IERR_U_CNT	        (MC_SPPE_REG_BASE + 0x00015444)
+#define MC_SE_EM_IERR_U_INFO	        (MC_SPPE_REG_BASE + 0x00015448)
+#define MC_SE_EM_IERR_L_CNT	        (MC_SPPE_REG_BASE + 0x0001544C)
+#define MC_SE_EM_IERR_L_INFO	        (MC_SPPE_REG_BASE + 0x00015450)
+#define MC_SE_EM_IERR_C_CNT	        (MC_SPPE_REG_BASE + 0x00015454)
+#define MC_SE_EM_IERR_C_INFO	        (MC_SPPE_REG_BASE + 0x00015458)
+#define MC_SE_EM_IERR_F_INFO	        (MC_SPPE_REG_BASE + 0x0001545C)
+#define MC_SE_EM_FIFO_STATUS0	        (MC_SPPE_REG_BASE + 0x00015460)
+#define MC_SE_EM_KT_RSLT_FIFO_TH	        (MC_SPPE_REG_BASE + 0x0001546C)
+#define MC_SE_EM_COMP_RSLT_FIFO_TH	(MC_SPPE_REG_BASE + 0x00015470)
+#define MC_SE_EM_READ_ONCE_FIFO_TH	(MC_SPPE_REG_BASE + 0x00015474)
+#define MC_SE_EM_KEY_INFO_FIFO_TH	(MC_SPPE_REG_BASE + 0x0001547C)
+#define MC_SE_EM_AGE_BP_EN	                 (MC_SPPE_REG_BASE + 0x00015480)
+#define MC_SE_ESM_IERR_U_CNT	        (MC_SPPE_REG_BASE + 0x00015484)
+#define MC_SE_ESM_IERR_U_INFO	        (MC_SPPE_REG_BASE + 0x00015488)
+#define MC_SE_ESM_IERR_C_CNT	        (MC_SPPE_REG_BASE + 0x0001548C)
+#define MC_SE_ESM_IERR_C_INFO	        (MC_SPPE_REG_BASE + 0x00015490)
+#define MC_SE_ESM_INT_STATUS	                 (MC_SPPE_REG_BASE + 0x00015494)
+#define MC_SE_ESM_INT_ENABLE	                 (MC_SPPE_REG_BASE + 0x00015498)
+#define MC_SE_ESM_INT_SET	                 (MC_SPPE_REG_BASE + 0x0001549C)
+#define MC_SE_ESM_FIFO_OVF_INFO	        (MC_SPPE_REG_BASE + 0x000154A0)
+#define MC_SE_ESM_FIFO_OVF_CNT	        (MC_SPPE_REG_BASE + 0x000154A4)
+#define MC_SE_ESM_FIFO_STATUS	        (MC_SPPE_REG_BASE + 0x000154A8)
+#define MC_SE_ESM_EM_EXTB0_FIFO_AFUL_TH	        (MC_SPPE_REG_BASE + 0x000154AC)
+#define MC_SE_ESM_EM_EXTB1_FIFO_AFUL_TH	        (MC_SPPE_REG_BASE + 0x000154B0)
+#define MC_SE_ESM_EM_HT_BYPASS_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154B4)
+#define MC_SE_ESM_EM_HT_INFO_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154B8)
+#define MC_SE_ESM_EM_DMC_HT_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154BC)
+#define MC_SE_ESM_EM_KT_BYPASS_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154C0)
+#define MC_SE_ESM_EM_KT_INFO_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154C4)
+#define MC_SE_ESM_EM_DMC_KT_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x000154C8)
+#define MC_SE_EM_SEARCH_CNT	                                  (MC_SPPE_REG_BASE + 0x00015500)
+#define MC_SE_EM_RD_CAM_IDX_CNT	                         (MC_SPPE_REG_BASE + 0x00015504)
+#define MC_SE_EM_WR_CAM_IDX_CNT	                (MC_SPPE_REG_BASE + 0x00015508)
+#define MC_SE_EM_RD_CAM_CNT	                                  (MC_SPPE_REG_BASE + 0x00015510)
+#define MC_SE_EM_WR_CAM_CNT	                         (MC_SPPE_REG_BASE + 0x0001551C)
+#define MC_SE_EM_RD_HT1_CNT	                                  (MC_SPPE_REG_BASE + 0x00015520)
+#define MC_SE_EM_WR_HT1_CNT	                                  (MC_SPPE_REG_BASE + 0x00015524)
+#define MC_SE_LPM_SEARCH_CNT	                         (MC_SPPE_REG_BASE + 0x00015528)
+#define MC_SE_EM_RD_KT_CNT	                                  (MC_SPPE_REG_BASE + 0x0001553C)
+#define MC_SE_EM_WR_KT_CNT	                                  (MC_SPPE_REG_BASE + 0x00015540)
+#define MC_SE_EM_PUSH_CAM_CNT	                (MC_SPPE_REG_BASE + 0x00015544)
+#define MC_SE_EM_POP_CAM_CNT	                (MC_SPPE_REG_BASE + 0x00015548)
+#define MC_SE_EM_PUSH_KT_CNT	                (MC_SPPE_REG_BASE + 0x0001554C)
+#define MC_SE_EM_POP_KT_CNT	                        (MC_SPPE_REG_BASE + 0x00015550)
+#define MC_SE_EM_AGE_REQ_CNT	                (MC_SPPE_REG_BASE + 0x00015554)
+#define MC_SE_EM_HT1_RSLT_CNT	                (MC_SPPE_REG_BASE + 0x0001555C)
+#define MC_SE_EM_KT_RSLT_CNT	                (MC_SPPE_REG_BASE + 0x00015560)
+#define MC_SE_EM_CKEY_RD_CNT	                (MC_SPPE_REG_BASE + 0x00015564)
+#define MC_SE_EM_HT1_REQ_CNT	                (MC_SPPE_REG_BASE + 0x00015568)
+#define MC_SE_EM_KT_REQ_CNT	                        (MC_SPPE_REG_BASE + 0x0001556C)
+#define MC_SE_EM_POOL_KT_REQ_CNT	        (MC_SPPE_REG_BASE + 0x00015574)
+#define MC_SE_EM_POOL_KT_RSLT_CNT	        (MC_SPPE_REG_BASE + 0x00015578)
+#define MC_SE_EM_AGE_DROP_CNT	                (MC_SPPE_REG_BASE + 0x0001557C)
+#define MC_SE_EM_FLIST_DEBUG_REQ	        (MC_SPPE_REG_BASE + 0x00015600)
+#define MC_SE_EM_FLIST_DEBUG_DONE	        (MC_SPPE_REG_BASE + 0x00015604)
+#define MC_SE_EM_FLIST_DEBUG_DATA	        (MC_SPPE_REG_BASE + 0x00015608)
+#define MC_SE_DISP_EM_DISP_0_CNT	                (MC_SPPE_REG_BASE + 0x00015800)
+#define MC_SE_DISP_EM_DISP_1_CNT	                 (MC_SPPE_REG_BASE + 0x00015804)
+#define MC_SE_DISP_LPM_DISP_1_CNT	        (MC_SPPE_REG_BASE + 0x00015808)
+#define MC_SE_DISP_LCAM_DISP_1_CNT	        (MC_SPPE_REG_BASE + 0x0001580C)
+#define MC_SE_DISP_LPM_RSP_FIFO_AFUL_TH	        (MC_SPPE_REG_BASE + 0x00015810)
+#define MC_SE_DISP_LCAM_RSP_FIFO_AFUL_TH	(MC_SPPE_REG_BASE + 0x00015814)
+#define MC_SE_DISP_EM_RSP_FIFO_AFUL_TH	        (MC_SPPE_REG_BASE + 0x00015818)
+#define MC_SE_DISP_FIFO_STATUS1	                          (MC_SPPE_REG_BASE + 0x00015820)
+
+/*LCAM*/
+#define MC_LCAM_OFFSET                       (0x0c000)
+#define MC_LCAM_INT_STATUS	         (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000004)
+#define MC_LCAM_INT_ENABLE              (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000008)
+#define MC_LCAM_CORE_INT_STATUS  (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000020)
+#define MC_LCAM_CORE_INT_ENABLE  (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000024)
+#define MC_LCAM_CORE_INT_SET         (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000028)
+#define MC_LCAM_RAM_INIT_START    (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000030)
+#define MC_LCAM_RAM_INIT_STATUS  (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000034)
+#define MC_LCAM_BG_SCAN                    (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000038)
+#define MC_LCAM_RM_TRANS0               (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000048)
+#define MC_LCAM_TCAM_PROFILE         (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000100)
+#define MC_LCAM_TCAM_GMR                (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000140)
+#define MC_LCAM_RBA_ABORT               (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x000001E0)
+#define MC_LCAM_REQ_TCAM_CNT	 (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x000001E4)
+#define MC_LCAM_RSP_TCAM_CNT	 (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000220)
+#define MC_LCAM_IERR_C_INFO            (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000230)
+#define MC_LCAM_IERR_U_INFO            (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000234)
+#define MC_LCAM_IERR_C_TCAM_INFO   (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000238)
+#define MC_LCAM_IERR_U_TCAM_INFO   (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x0000023C)
+#define MC_LCAM_BAD_CMD_AA0_INFO   (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000240)
+#define MC_LCAM_IERR_C_CNT                 (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x0000024C)
+#define MC_LCAM_IERR_U_CNT                 (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000250)
+#define MC_LCAM_IERR_C_TCAM_CNT     (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000254)
+#define MC_LCAM_IERR_U_TCAM_CNT     (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000258)
+#define MC_LCAM_TEST_DBG_CFG	    (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000600)
+#define MC_LCAM_CORE_CLK_DBG_CFG  (MC_SPPE_REG_BASE + MC_LCAM_OFFSET+ 0x00000604)
+
+/* CACHE 模块寄存器基地址 */
+#define MC_CACHE_BASE                             (0x1302b000)
+
+/******************************************************************************/
+/*                      MC CACHE 寄存器定义                                   */
+/******************************************************************************/
+#define MC_CACHE_L3_CTRL_REG                      (MC_CACHE_BASE + 0x0)           /* L3_CTRL为L3 Cache的控制寄存器。 */
+#define MC_CACHE_L3_AUCTRL_REG                    (MC_CACHE_BASE + 0x4)           /* L3_AUCTRL为L3 Cache的辅助控制寄存器。 */
+#define MC_CACHE_L3_TIMEOUT_REG                   (MC_CACHE_BASE + 0x8)           /* L3_TIMEOUT为L3 Cache的命令timeout配置寄存器。 */
+#define MC_CACHE_L3_STATUS_REG                    (MC_CACHE_BASE + 0xC)           /* L3_STATUS为L3 Cache的状态寄存器。 */
+#define MC_CACHE_L3_CA_START_REG                  (MC_CACHE_BASE + 0x10)          /* L3_CA_START为L3 Cache的Cacheable空间的起始地址。 */
+#define MC_CACHE_L3_CA_END_REG                    (MC_CACHE_BASE + 0x14)          /* L3_CA_END为L3 Cache的Cacheable空间的结束地址。 */
+#define MC_CACHE_L3_ARAM_START_REG                (MC_CACHE_BASE + 0x18)          /* L3_ARAM_START为L3 Cache中Sram的安全存储空间起始地址。 */
+#define MC_CACHE_L3_ARAM_END_REG                  (MC_CACHE_BASE + 0x1C)          /* L3_ARAM_END为L3 Cache中Sram的安全存储空间结束地址。 */
+#define MC_CACHE_L3_SYNC_REG                      (MC_CACHE_BASE + 0x20)          /* L3_SYNC为L3 Cache的同步寄存器。 */
+#define MC_CACHE_L3_MAINT_CTRL_REG                (MC_CACHE_BASE + 0x24)          /* L3_MAINT_CTRL为L3 Cache 按地址 clean/invalidate操作的配置寄存器。 */
+#define MC_CACHE_L3_MAINT_ADDR_REG                (MC_CACHE_BASE + 0x28)          /* L3_MAINT_ADDR为L3 Cache 按地址 clean/invalidate操作的配置寄存器。 */
+#define MC_CACHE_L3_LOCKDOWN_REG                  (MC_CACHE_BASE + 0x2C)          /* L3_LOCKDOWN为L3 Cache的锁定Way配置寄存器。 */
+#define MC_L3_PREFETCH_REG                        (MC_CACHE_BASE + 0x30)          /* L3_PREFECTH为L3 Cache的硬件预取操作配置寄存器。 */
+#define MC_L3_ALLOC_FREQ_REG                      (MC_CACHE_BASE + 0x34)          /* L3_PREFECTH为L3 Cache的控制allocate发生频度的配置寄存器。 */
+#define MC_CACHE_L3_BANK0_INTM_REG                (MC_CACHE_BASE + 0x100)         /* L3_BANK0_INTM为BANK0的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK0_RINT_REG                (MC_CACHE_BASE + 0x104)         /* L3_BANK0_RINT为BANK0的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK0_INTS_REG                (MC_CACHE_BASE + 0x108)         /* L3_BANK0_INTS为BANK0的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK0_INTC_REG                (MC_CACHE_BASE + 0x10C)         /* L3_BANK0_INTC为BANK0的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK1_INTM_REG                (MC_CACHE_BASE + 0x110)         /* L3_BANK1_INTM为BANK1的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK1_RINT_REG                (MC_CACHE_BASE + 0x114)         /* L3_BANK1_RINT为BANK1的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK1_INTS_REG                (MC_CACHE_BASE + 0x118)         /* L3_BANK1_INTS为BANK1的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK1_INTC_REG                (MC_CACHE_BASE + 0x11C)         /* L3_BANK1_INTC为BANK1的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK2_INTM_REG                (MC_CACHE_BASE + 0x120)         /* L3_BANK2_INTM为BANK2的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK2_RINT_REG                (MC_CACHE_BASE + 0x124)         /* L3_BANK2_RINT为BANK2的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK2_INTS_REG                (MC_CACHE_BASE + 0x128)         /* L3_BANK2_INTS为BANK2的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK2_INTC_REG                (MC_CACHE_BASE + 0x12C)         /* L3_BANK2_INTC为BANK2的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK3_INTM_REG                (MC_CACHE_BASE + 0x130)         /* L3_BANK3_INTM为BANK3的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK3_RINT_REG                (MC_CACHE_BASE + 0x134)         /* L3_BANK3_RINT为BANK3的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK3_INTS_REG                (MC_CACHE_BASE + 0x138)         /* L3_BANK3_INTS为BANK3的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK3_INTC_REG                (MC_CACHE_BASE + 0x13C)         /* L3_BANK3_INTC为BANK3的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK4_INTM_REG                (MC_CACHE_BASE + 0x140)         /* L3_BANK4_INTM为BANK4的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK4_RINT_REG                (MC_CACHE_BASE + 0x144)         /* L3_BANK4_RINT为BANK4的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK4_INTS_REG                (MC_CACHE_BASE + 0x148)         /* L3_BANK4_INTS为BANK4的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK4_INTC_REG                (MC_CACHE_BASE + 0x14C)         /* L3_BANK4_INTC为BANK4的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK5_INTM_REG                (MC_CACHE_BASE + 0x150)         /* L3_BANK5_INTM为BANK5的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK5_RINT_REG                (MC_CACHE_BASE + 0x154)         /* L3_BANK5_RINT为BANK5的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK5_INTS_REG                (MC_CACHE_BASE + 0x158)         /* L3_BANK5_INTS为BANK5的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK5_INTC_REG                (MC_CACHE_BASE + 0x15C)         /* L3_BANK5_INTC为BANK5的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK6_INTM_REG                (MC_CACHE_BASE + 0x160)         /* L3_BANK6_INTM为BANK6的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK6_RINT_REG                (MC_CACHE_BASE + 0x164)         /* L3_BANK6_RINT为BANK6的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK6_INTS_REG                (MC_CACHE_BASE + 0x168)         /* L3_BANK6_INTS为BANK6的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK6_INTC_REG                (MC_CACHE_BASE + 0x16C)         /* L3_BANK6_INTC为BANK6的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK7_INTM_REG                (MC_CACHE_BASE + 0x170)         /* L3_BANK7_INTM为BANK7的中断屏蔽寄存器。 */
+#define MC_CACHE_L3_BANK7_RINT_REG                (MC_CACHE_BASE + 0x174)         /* L3_BANK7_RINT为BANK7的原始中断状态寄存器。 */
+#define MC_CACHE_L3_BANK7_INTS_REG                (MC_CACHE_BASE + 0x178)         /* L3_BANK7_INTS为BANK7的屏蔽后的中断状态寄存器。 */
+#define MC_CACHE_L3_BANK7_INTC_REG                (MC_CACHE_BASE + 0x17C)         /* L3_BANK7_INTC为BANK7的中断清除寄存器。 */
+#define MC_CACHE_L3_BANK0_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x180)         /* L3_BANK0_CNT_TYPE为BANK0的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK1_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x190)         /* L3_BANK1_CNT_TYPE为BANK1的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK2_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1A0)         /* L3_BANK2_CNT_TYPE为BANK2的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK3_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1B0)         /* L3_BANK3_CNT_TYPE为BANK3的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK4_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1C0)         /* L3_BANK4_CNT_TYPE为BANK4的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK5_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1D0)         /* L3_BANK5_CNT_TYPE为BANK5的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK6_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1E0)         /* L3_BANK6_CNT_TYPE为BANK6的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK7_EVENT_TYPE_REG          (MC_CACHE_BASE + 0x1F0)         /* L3_BANK7_CNT_TYPE为BANK7的事件类型配置寄存器。 */
+#define MC_CACHE_L3_BANK0_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x200)         /* L3_BANK0_INT_CNT0为BANK0的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK0_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x204)         /* L3_BANK0_INT_CNT1为BANK0的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK0_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x208)         /* L3_BANK0_INT_CNT2为BANK0的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK0_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x20C)         /* L3_BANK0_INT_CNT3为BANK0的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK1_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x210)         /* L3_BANK1_INT_CNT0为BANK1的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK1_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x214)         /* L3_BANK1_INT_CNT1为BANK1的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK1_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x218)         /* L3_BANK1_INT_CNT2为BANK1的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK1_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x21C)         /* L3_BANK1_INT_CNT3为BANK1的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK2_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x220)         /* L3_BANK2_INT_CNT0为BANK2的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK2_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x224)         /* L3_BANK2_INT_CNT1为BANK2的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK2_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x228)         /* L3_BANK2_INT_CNT2为BANK2的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK2_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x22C)         /* L3_BANK2_INT_CNT3为BANK2的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK3_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x230)         /* L3_BANK3_INT_CNT0为BANK3的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK3_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x234)         /* L3_BANK3_INT_CNT1为BANK3的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK3_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x238)         /* L3_BANK3_INT_CNT2为BANK3的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK3_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x23C)         /* L3_BANK3_INT_CNT3为BANK3的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK4_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x240)         /* L3_BANK4_INT_CNT0为BANK4的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK4_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x244)         /* L3_BANK4_INT_CNT1为BANK4的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK4_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x248)         /* L3_BANK4_INT_CNT2为BANK4的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK4_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x24C)         /* L3_BANK4_INT_CNT3为BANK4的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK5_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x250)         /* L3_BANK5_INT_CNT0为BANK5的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK5_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x254)         /* L3_BANK5_INT_CNT1为BANK5的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK5_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x258)         /* L3_BANK5_INT_CNT2为BANK5的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK5_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x25C)         /* L3_BANK5_INT_CNT3为BANK5的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK6_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x260)         /* L3_BANK6_INT_CNT0为BANK6的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK6_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x264)         /* L3_BANK6_INT_CNT1为BANK6的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK6_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x268)         /* L3_BANK6_INT_CNT2为BANK6的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK6_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x26C)         /* L3_BANK6_INT_CNT3为BANK6的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK7_EVENT_CNT0_REG          (MC_CACHE_BASE + 0x270)         /* L3_BANK7_INT_CNT0为BANK7的事件统计寄存器0。 */
+#define MC_CACHE_L3_BANK7_EVENT_CNT1_REG          (MC_CACHE_BASE + 0x274)         /* L3_BANK7_INT_CNT1为BANK7的事件统计寄存器1。 */
+#define MC_CACHE_L3_BANK7_EVENT_CNT2_REG          (MC_CACHE_BASE + 0x278)         /* L3_BANK7_INT_CNT2为BANK7的事件统计寄存器2。 */
+#define MC_CACHE_L3_BANK7_EVENT_CNT3_REG          (MC_CACHE_BASE + 0x27C)         /* L3_BANK7_INT_CNT3为BANK7的事件统计寄存器3。 */
+#define MC_CACHE_L3_BANK0_TRAM_ECC_REG            (MC_CACHE_BASE + 0x300)         /* L3_BANK0_TRAM_ECC为BANK0 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK0_DRAM_ECC_REG            (MC_CACHE_BASE + 0x304)         /* L3_BANK0_DRAM_ECC为 BANK0 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK0_ECC_INJECT_REG          (MC_CACHE_BASE + 0x308)         /* L3_BANK0_ECC_INJECT为BANK0的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK1_TRAM_ECC_REG            (MC_CACHE_BASE + 0x310)         /* L3_BANK1_TRAM_ECC为BANK1 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK1_DRAM_ECC_REG            (MC_CACHE_BASE + 0x314)         /* L3_BANK1_DRAM_ECC为 BANK1 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK1_ECC_INJECT_REG          (MC_CACHE_BASE + 0x318)         /* L3_BANK1_ECC_INJECT为BANK1的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK2_TRAM_ECC_REG            (MC_CACHE_BASE + 0x320)         /* L3_BANK2_TRAM_ECC为BANK2 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK2_DRAM_ECC_REG            (MC_CACHE_BASE + 0x324)         /* L3_BANK2_DRAM_ECC为 BANK2 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK2_ECC_INJECT_REG          (MC_CACHE_BASE + 0x328)         /* L3_BANK2_ECC_INJECT为BANK2的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK3_TRAM_ECC_REG            (MC_CACHE_BASE + 0x330)         /* L3_BANK3_TRAM_ECC为BANK3 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK3_DRAM_ECC_REG            (MC_CACHE_BASE + 0x334)         /* L3_BANK3_DRAM_ECC为 BANK3 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK3_ECC_INJECT_REG          (MC_CACHE_BASE + 0x338)         /* L3_BANK3_ECC_INJECT为BANK3的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK4_TRAM_ECC_REG            (MC_CACHE_BASE + 0x340)         /* L3_BANK4_TRAM_ECC为BANK4 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK4_DRAM_ECC_REG            (MC_CACHE_BASE + 0x344)         /* L3_BANK4_DRAM_ECC为 BANK4 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK4_ECC_INJECT_REG          (MC_CACHE_BASE + 0x348)         /* L3_BANK4_ECC_INJECT为BANK4的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK5_TRAM_ECC_REG            (MC_CACHE_BASE + 0x350)         /* L3_BANK5_TRAM_ECC为BANK5 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK5_DRAM_ECC_REG            (MC_CACHE_BASE + 0x354)         /* L3_BANK5_DRAM_ECC为 BANK5 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK5_ECC_INJECT_REG          (MC_CACHE_BASE + 0x358)         /* L3_BANK5_ECC_INJECT为BANK5的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK6_TRAM_ECC_REG            (MC_CACHE_BASE + 0x360)         /* L3_BANK6_TRAM_ECC为BANK6 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK6_DRAM_ECC_REG            (MC_CACHE_BASE + 0x364)         /* L3_BANK6_DRAM_ECC为 BANK6 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK6_ECC_INJECT_REG          (MC_CACHE_BASE + 0x368)         /* L3_BANK6_ECC_INJECT为BANK6的ECC错误注入寄存器。 */
+#define MC_CACHE_L3_BANK7_TRAM_ECC_REG            (MC_CACHE_BASE + 0x370)         /* L3_BANK7_TRAM_ECC为BANK7 Tag Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK7_DRAM_ECC_REG            (MC_CACHE_BASE + 0x374)         /* L3_BANK7_DRAM_ECC为 BANK7 Data Ram最近一次ECC出错位置信息。 */
+#define MC_CACHE_L3_BANK7_ECC_INJECT_REG          (MC_CACHE_BASE + 0x378)         /* L3_BANK7_ECC_INJECT为BANK7的ECC错误注入寄存器。 */
+
+
+/*LMEM 寄存器配置*/
+
+#define MC_LMEM_OFFSET  (0x4000)
+
+#define MC_LMEM_CFG_128BIT0_WORD0     (MC_SPPE_REG_BASE  + 0x04000000)
+#define MC_LMEM_CFG_128BIT0_WORD1     (MC_SPPE_REG_BASE  + 0x04000004)
+#define MC_LMEM_CFG_128BIT0_WORD2     (MC_SPPE_REG_BASE  + 0x04000008)
+#define MC_LMEM_CFG_128BIT0_WORD3     (MC_SPPE_REG_BASE  + 0x0400000C)
+
+#define MC_LMEM_GP_32BIT_RW0          (MC_SPPE_REG_BASE  + 0x05200000)
+#define MC_LMEM_GP_32BIT_CAR0         (MC_SPPE_REG_BASE  + 0x05400000)
+#define MC_LMEM_GP_64BIT_RW0_WORD0    (MC_SPPE_REG_BASE  + 0x05600000)
+#define MC_LMEM_GP_64BIT_RW0_WORD1    (MC_SPPE_REG_BASE  + 0x05600004)
+
+#define MC_LMEM_GP_64BIT_CAR0_WORD0   (MC_SPPE_REG_BASE  + 0x05800000)
+
+#define MC_LMEM_GP_128BIT_RW0_WORD0   (MC_SPPE_REG_BASE  + 0x05A00000)
+#define MC_LMEM_GP_128BIT_RW0_WORD1   (MC_SPPE_REG_BASE  + 0x05A00004)
+#define MC_LMEM_GP_128BIT_RW0_WORD2   (MC_SPPE_REG_BASE  + 0x05A00008)
+#define MC_LMEM_GP_128BIT_RW0_WORD3   (MC_SPPE_REG_BASE  + 0x05A0000C)
+
+#define MC_LMEM_GP_128BIT_CAR_WORD0   (MC_SPPE_REG_BASE  + 0x05C00000)
+
+
+#define MC_LMEM_INT_ENABLE               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000808)
+#define MC_LMEM_INT_STATUS               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000804)
+#define MC_LMEM_INT_SET                  (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x0000080C)
+#define MC_LMEM_IERR_F_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000820)
+#define MC_LMEM_IERR_L_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000824)
+#define MC_LMEM_IERR_U_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000828)
+#define MC_LMEM_IERR_C_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x0000082C)
+#define MC_LMEM_BAD_CMD_INFO             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000830)
+#define MC_LMEM_PH_ERR_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000834)
+#define MC_LMEM_FS_ERR_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000838)
+#define MC_LMEM_Q_OVFL_INFO              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x0000083C)
+#define MC_LMEM_NCP_OVFL_INFO            (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000840)
+#define MC_LMEM_IERR_L_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000850)
+#define MC_LMEM_IERR_U_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000854)
+#define MC_LMEM_IERR_C_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000858)
+#define MC_LMEM_BAD_CMD_CNT              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x0000085C)
+#define MC_LMEM_PH_ERR_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000860)
+#define MC_LMEM_FS_ERR_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000864)
+#define MC_LMEM_Q_OVFL_CNT               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000868)
+#define MC_LMEM_SE_OVFL_CNT              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x0000086C)
+#define SRE_LMEM_TM_OVFL_CNT              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000870)
+#define MC_LMEM_NCP_OVFL_CNT             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000874)
+#define MC_LMEM_ABORT_ERR_CNT            (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000878)
+#define MC_LMEM_IERR_U_DATA              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000880)
+#define MC_LMEM_RAM_INIT_START           (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008A0)
+#define MC_LMEM_RAM_INIT_STATUS          (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008A4)
+#define MC_LMEM_CFG_MEM_OFFSET           (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008B0)
+#define MC_LMEM_CFG_MEM_IND_OFFSET       (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008B4)
+#define MC_LMEM_CFG_MEM_POL_OFFSET       (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008B8)
+#define MC_LMEM_CFG_MEM_Q_OFFSET         (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008BC)
+#define MC_LMEM_CFG_MEM_SEM_OFFSET       (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008C0)
+#define MC_LMEM_POL_SYS_TIMER            (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008D0)
+#define MC_LMEM_POL_TICK_CNT             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008D8)
+#define MC_LMEM_POL_VIRTUAL_TH           (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008DC)
+#define MC_LMEM_STAT_TS_DIV              (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x000008F0)
+#define MC_LMEM_ADDNCP_ADDR_MOD          (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000900)
+#define MC_LMEM_CLEARBIT_ADDR_MOD        (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000904)
+#define MC_LMEM_MS0_EMEM_NCP_ADDR_MOD    (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000910)
+#define MC_LMEM_DBG_BP_CFG               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B00)
+#define MC_LMEM_DBG_FIFO_TH0             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B04)
+#define MC_LMEM_DBG_FIFO_TH1             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B08)
+#define MC_LMEM_DBG_FIFO_TH2             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B0C)
+#define MC_LMEM_DBG_FIFO_OVFL            (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B10)
+#define MC_LMEM_DBG_STATUS               (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B14)
+#define MC_LMEM_DBG_NCF_FIFO             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000B18)
+#define MC_LMEM_DIAG_CTL                 (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C00)
+#define MC_LMEM_DIAG_INTRV_R             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C04)
+#define MC_LMEM_DIAG_INTRV_W             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C08)
+#define MC_LMEM_DIAG_CNT_RBA_REQ         (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C0C)
+#define MC_LMEM_DIAG_CNT_RBA_RSP         (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C10)
+#define MC_LMEM_DIAG_CNT_EMEM_REQ        (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C14)
+#define MC_LMEM_DIAG_CNT_SE_REQ          (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C18)
+#define SRE_LMEM_DIAG_CNT_TM_REQ          (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C1C)
+#define MC_LMEM_DIAG_CNT_MS0             (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C20)
+#define MC_LMEM_TIMING                   (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C40)
+#define MC_LMEM_POWER1                   (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C44)
+#define MC_LMEM_POWER2                   (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C48)
+#define MC_LMEM_ICG                      (MC_SPPE_REG_BASE + MC_LMEM_OFFSET + 0x00000C4C)
+
+/* TM 模块寄存器基地址 */
+#if 0         /* z00202052 */
+#define SRE_TM_BASE                             (0x11800000)
+#else
+#define SRE_TM_BASE                             (0xe1800000)
+#endif        /* z00202052 */
+
+/******************************************************************************/
+/*                      TM 寄存器定义                                      */
+/******************************************************************************/
+#define SRE_TM_RSV0_REG                         (SRE_TM_BASE + 0x0)              /* TM预留寄存器0 */
+#define SRE_TM_RSV1_REG                         (SRE_TM_BASE + 0x4)              /* TM预留寄存器1 */
+#define SRE_TM_RSV2_REG                         (SRE_TM_BASE + 0x8)              /* TM预留寄存器2 */
+#define SRE_TM_RSV3_REG                         (SRE_TM_BASE + 0xC)              /* TM预留寄存器3 */
+#define SRE_TM_CFG_OK_REG                       (SRE_TM_BASE + 0x10)             /* TM配置结束寄存器 */
+#define SRE_TM_DROP_FIFO_THR_REG                (SRE_TM_BASE + 0x14)             /* TM丢弃FIFO溢出和回读水线 */
+#define SRE_TM_ENDIEN_CTRL_REG                  (SRE_TM_BASE + 0x18)             /* TM访问DDR大小端模式控制寄存器 */
+#define SRE_TM_RAM_CFG_ERR_INST_REG             (SRE_TM_BASE + 0x1C)             /* TM_RAM_CFG模块错误植入寄存器 */
+#define SRE_TM_OTHER_ERR_INST_REG               (SRE_TM_BASE + 0x20)             /* TM_OTHER 模块错误植入寄存器 */
+#define SRE_TM_CF_OUT_DEPTH_REG                 (SRE_TM_BASE + 0x24)             /* TM MST口outstanding深度寄存器 */
+#define SRE_TM_CF_INTER_CNT_REG                 (SRE_TM_BASE + 0x28)             /* TM MST口AXI总线ERROR重传时间配置寄存器 */
+#define SRE_TM_CF_FAIL_CNT_REG                  (SRE_TM_BASE + 0x2C)             /* TM MST口AXI总线重传配置次数上报中断寄存器 */
+#define SRE_TM_CF_TIMEOUT_REG                   (SRE_TM_BASE + 0x30)             /* TM MST重传次数过多中断上报未清除超时时间配置寄存器 */
+#define SRE_TM_TOKEN_BS_MODE_REG                (SRE_TM_BASE + 0x34)             /* 令牌桶初始化模式寄存器 */
+#define SRE_TM_RFS_MEM_TIMING_CTRL_REG          (SRE_TM_BASE + 0x38)             /* TM RFS类 MEM时序控制信号 */
+#define SRE_TM_RAS_MEM_TIMING_CTRL_REG          (SRE_TM_BASE + 0x3C)             /* TM_RAS类 MEM时序控制信号 */
+#define SRE_TM_RAS_HD_POWER_CTRL_REG            (SRE_TM_BASE + 0x40)             /* TM RAS_HD类MEM电源控制信号 */
+#define SRE_TM_STORE_CFG_SPACE_REG              (SRE_TM_BASE + 0x44)             /* TM 缓存描述符空间配置寄存器 */
+#define SRE_TM_WRED_TS_SEL_REG                  (SRE_TM_BASE + 0x48)             /* TM WRED表查找索引选择配置寄存器 */
+#define SRE_TM_HAC_USER_REG                     (SRE_TM_BASE + 0x4C)             /* TM发送给其他加速器时使用USER */
+#define SRE_TM_OWEN_USER_REG                    (SRE_TM_BASE + 0x50)             /* TM内部自己使用USER */
+#define SRE_TM_ECC_BYPASS_REG                   (SRE_TM_BASE + 0x54)             /* TM_ECC_BYPASS寄存器 */
+#define SRE_TM_SLV_OTD_CHK_BYPASS_REG           (SRE_TM_BASE + 0x58)             /* TM内部SLV口OUT */
+#define SRE_TM_VM_BYPASS_REG                    (SRE_TM_BASE + 0x5C)             /* TM_虚拟化BYPASS寄存器 */
+#define SRE_TM_ACK_SPPE_BP_MODE_REG             (SRE_TM_BASE + 0x60)             /* TM响应SPPE统计反压控制寄存器 */
+#define SRE_TM_VMID_MAP_TAB1_REG                (SRE_TM_BASE + 0x100)            /* 虚拟化VMID映射表1 */
+#define SRE_TM_VMID_MAP_TAB2_REG                (SRE_TM_BASE + 0x104)            /* 虚拟化VMID映射表2 */
+#define SRE_TM_VM_QID_MAP_TAB_0_REG             (SRE_TM_BASE + 0x108)            /* 虚拟化VM对应队列配置信息表 */
+#define SRE_TM_VM_QID_MAP_TAB_1_REG             (SRE_TM_BASE + 0x10C)            /* 虚拟化VM对应队列配置信息表 */
+#define SRE_TM_VM_QERR_INTMSK_REG               (SRE_TM_BASE + 0x148)            /* 虚拟化队列号产生错误中断屏蔽寄存器 */
+#define SRE_TM_VM_QERR_RINT_REG                 (SRE_TM_BASE + 0x14C)            /* 虚拟化队列号产生错误原始中断寄存器 */
+#define SRE_TM_VM_QERR_INTSTS_REG               (SRE_TM_BASE + 0x150)            /* 虚拟化队列号产生错误中断状态寄存器 */
+#define SRE_TM_VM_QERR_ID_0_REG                 (SRE_TM_BASE + 0x154)            /* 虚拟化队列号产生错误中断错误队列ID号寄存器 */
+#define SRE_TM_VM_QERR_ID_1_REG                 (SRE_TM_BASE + 0x158)            /* 虚拟化队列号产生错误中断错误队列ID号寄存器 */
+#define SRE_TM_RSV4_REG                         (SRE_TM_BASE + 0x200)            /* TM预留寄存器4 */
+#define SRE_TM_RSV5_REG                         (SRE_TM_BASE + 0x204)            /* TM预留寄存器5 */
+#define SRE_TM_RSV6_REG                         (SRE_TM_BASE + 0x208)            /* TM预留寄存器6 */
+#define SRE_TM_RSV7_REG                         (SRE_TM_BASE + 0x20C)            /* TM预留寄存器7 */
+#define SRE_TM_FQ_RLS_CNT_REG                   (SRE_TM_BASE + 0x25C)            /* TM FQ级别 释放空调度个数计数器 */
+#define SRE_TM_COM_RLS_CNT_REG                  (SRE_TM_BASE + 0x260)            /* TM COM级别 释放空调度个数计数器 */
+#define SRE_TM_LOC_RLS_CNT_REG                  (SRE_TM_BASE + 0x264)            /* TM LOC级别 释放空调度个数计数器 */
+#define SRE_TM_QUEUE_SHAP_FSM3_PRB_REG          (SRE_TM_BASE + 0x268)            /* QUEUE_SHAP状态机探针3 */
+#define SRE_TM_QUEUE_SHAP_FSM2_PRB_REG          (SRE_TM_BASE + 0x26C)            /* QUEUE_SHAP状态机探针2 */
+#define SRE_TM_QUEUE_SHAP_FSM1_PRB_REG          (SRE_TM_BASE + 0x270)            /* QUEUE_SHAP状态机探针1 */
+#define SRE_TM_QUEUE_DROP_FSM_PRB_REG           (SRE_TM_BASE + 0x274)            /* TM_SLV状态机探针 */
+#define SRE_TM_QUEUE_TK_FSM_PRB_REG             (SRE_TM_BASE + 0x278)            /* QUEUE_TK状态机探针 */
+#define SRE_TM_SLV_FSM_PRB_REG                  (SRE_TM_BASE + 0x27C)            /* TM_SLV状态机探针 */
+#define SRE_TM_QUEUE_STA_FSM1_PRB_REG           (SRE_TM_BASE + 0x280)            /* QUEUE_STA状态机探针1 */
+#define SRE_TM_QUEUE_STA_FSM2_PRB_REG           (SRE_TM_BASE + 0x284)            /* QUEUE_STA状态机探针2 */
+#define SRE_TM_QUEUE_SCH_FSM_PRB_REG            (SRE_TM_BASE + 0x288)            /* QUEUE_SCH状态机探针 */
+#define SRE_TM_QUEUE_M_FSM_PRB_REG              (SRE_TM_BASE + 0x28C)            /* QUEUE_M状态机探针 */
+#define SRE_TM_FREE_PTR_CNT_REG                 (SRE_TM_BASE + 0x290)            /* TM剩余FREE BUF指针计数器 */
+#define SRE_TM_MST_CNT_EN_REG                   (SRE_TM_BASE + 0x294)            /* MST口内部通道统计使能标志 */
+#define SRE_TM_MST_CNT_CLR_REG                  (SRE_TM_BASE + 0x298)            /* MST口内部通道统计清除信号 */
+#define SRE_TM_MST_LATENCY_AVG_REG              (SRE_TM_BASE + 0x29C)            /* MST口平均延时寄存器 */
+#define SRE_TM_MST_LATENCY_MAX_REG              (SRE_TM_BASE + 0x2A0)            /* MST口最大延时寄存器 */
+#define SRE_TM_MST_RD_ACC_REG                   (SRE_TM_BASE + 0x2A4)            /* MST口读计数器 */
+#define SRE_TM_MST_WR_ACC_REG                   (SRE_TM_BASE + 0x2A8)            /* MST口写计数器 */
+#define SRE_TM_MST_RD_OTD_1_REG                 (SRE_TM_BASE + 0x2AC)            /* MST口读outstanding计数器1 */
+#define SRE_TM_MST_RD_OTD_2_REG                 (SRE_TM_BASE + 0x2B0)            /* MST口读outstanding计数器2 */
+#define SRE_TM_MST_WR_OTD_1_REG                 (SRE_TM_BASE + 0x2B4)            /* MST口写outstanding计数器1 */
+#define SRE_TM_MST_WR_OTD_2_REG                 (SRE_TM_BASE + 0x2B8)            /* MST口写outstanding计数器2 */
+#define SRE_TM_PORT_SEND_DATA_DFX_0_REG         (SRE_TM_BASE + 0x2BC)            /* TM PORT发送数据探针 */
+#define SRE_TM_PORT_SEND_DATA_DFX_1_REG         (SRE_TM_BASE + 0x2C0)            /* TM PORT发送数据探针 */
+#define SRE_TM_SPPE_BP_REG                      (SRE_TM_BASE + 0x2FC)            /* SPPE给TM反压探针寄存器 */
+#define SRE_TM_MPE_BP_REG                       (SRE_TM_BASE + 0x300)            /* MPE给TM反压探针寄存器 */
+#define SRE_TM_PPE_BP_REG                       (SRE_TM_BASE + 0x304)            /* PPE给TM反压探针寄存器 */
+#define SRE_TM_POE_BP_REG                       (SRE_TM_BASE + 0x308)            /* POE给TM反压探针信号 */
+#define SRE_TM_CPU_ADD_WORD0_REG                (SRE_TM_BASE + 0x30C)            /* CPU写TM模块msg WORD0 */
+#define SRE_TM_CPU_ADD_WORD1_REG                (SRE_TM_BASE + 0x310)            /* CPU写TM模块msg WORD1 */
+#define SRE_TM_CPU_ADD_WORD2_REG                (SRE_TM_BASE + 0x314)            /* CPU写TM模块msg WORD2 */
+#define SRE_TM_CPU_ADD_WORD3_REG                (SRE_TM_BASE + 0x318)            /* CPU写TM模块msg WORD3 */
+#define SRE_TM_ACC_ADD_WORD0_REG                (SRE_TM_BASE + 0x31C)            /* 加速器写TM模块msg WORD0 */
+#define SRE_TM_ACC_ADD_WORD1_REG                (SRE_TM_BASE + 0x320)            /* 加速器写TM模块msg WORD1 */
+#define SRE_TM_ACC_ADD_WORD2_REG                (SRE_TM_BASE + 0x324)            /* 加速器写TM模块msg WORD2 */
+#define SRE_TM_ACC_ADD_WORD3_REG                (SRE_TM_BASE + 0x328)            /* 加速器写TM模块msg WORD3 */
+#define SRE_TM_MST_SEND_TIMES_INTMSK_REG        (SRE_TM_BASE + 0x32C)            /* MST推送次数超过配置值中断掩码寄存器 */
+#define SRE_TM_MST_SEND_TIMES_RINT_REG          (SRE_TM_BASE + 0x330)            /* MST推送次数超过配置值原始中断寄存器 */
+#define SRE_TM_MST_SEND_TIMES_INTSTS_REG        (SRE_TM_BASE + 0x334)            /* MST推送次数超过配置值中断状态寄存器 */
+#define SRE_TM_BIND_ERR_INTMSK_REG              (SRE_TM_BASE + 0x338)            /* 端口不在绑定关系中断屏蔽寄存器 */
+#define SRE_TM_BIND_ERR_RINT_REG                (SRE_TM_BASE + 0x33C)            /* 端口不在绑定关系原始中断寄存器 */
+#define SRE_TM_BIND_ERR_INTSTS_REG              (SRE_TM_BASE + 0x340)            /* 端口不在绑定关系中断寄存器状态寄存器 */
+#define SRE_TM_BIND_TK_ERR_STS1_REG             (SRE_TM_BASE + 0x344)            /* 端口不在绑定关系对应TK端口寄存器1 */
+#define SRE_TM_BIND_TK_ERR_STS2_REG             (SRE_TM_BASE + 0x348)            /* 端口不在绑定关系对应TK端口寄存器2 */
+#define SRE_TM_PORT_FIFO_INTMSK_REG             (SRE_TM_BASE + 0x350)            /* TM_PORT_FIFO模块中断屏蔽寄存器 */
+#define SRE_TM_PORT_FIFO_RINT_REG               (SRE_TM_BASE + 0x354)            /* TM_PORT_FIFO原始中断寄存器 */
+#define SRE_TM_PORT_FIFO_INTSTS_REG             (SRE_TM_BASE + 0x358)            /* TM_PORT_FIFO屏蔽后中断状态寄存器 */
+#define SRE_TM_FIFO1_INTMSK_REG                 (SRE_TM_BASE + 0x35C)            /* TM_FIFO第一部分模块中断屏蔽寄存器 */
+#define SRE_TM_FIFO1_RINT_REG                   (SRE_TM_BASE + 0x360)            /* TM_FIFO第一部分原始中断寄存器 */
+#define SRE_TM_FIFO1_INTSTS_REG                 (SRE_TM_BASE + 0x364)            /* TM_FIFO第一部分屏蔽后中断状态寄存器 */
+#define SRE_TM_FIFO2_INTMSK_REG                 (SRE_TM_BASE + 0x368)            /* TM_FIFO第二部分模块中断屏蔽寄存器 */
+#define SRE_TM_FIFO2_RINT_REG                   (SRE_TM_BASE + 0x36C)            /* TM_FIFO第二部分原始中断寄存器 */
+#define SRE_TM_FIFO2_INTSTS_REG                 (SRE_TM_BASE + 0x370)            /* TM_FIFO第二部分屏蔽后中断状态寄存器 */
+#define SRE_TM_FIFO3_INTMSK_REG                 (SRE_TM_BASE + 0x374)            /* TM_FIFO第三部分模块中断屏蔽寄存器 */
+#define SRE_TM_FIFO3_RINT_REG                   (SRE_TM_BASE + 0x378)            /* TM_FIFO第三部分原始中断寄存器 */
+#define SRE_TM_FIFO3_INTSTS_REG                 (SRE_TM_BASE + 0x37C)            /* TM_FIFO第三部分屏蔽后中断状态寄存器 */
+#define SRE_TM_QUEUE_M_FIFO_DFX_REG             (SRE_TM_BASE + 0x380)            /* QUEUE_M 模块FIFO DFX寄存器 */
+#define SRE_TM_QUEUE_SHAP_FIFO_DFX_REG          (SRE_TM_BASE + 0x384)            /* QUEUE SHAP模块FIFO DFX寄存器 */
+#define SRE_TM_SLV_FIFO_DFX_REG                 (SRE_TM_BASE + 0x388)            /* AXI SLV模块FIFO DFX寄存器 */
+#define SRE_TM_QUEUE_TK_FIFO_DFX_REG            (SRE_TM_BASE + 0x38C)            /* QUEUE_TK 模块FIFO DFX寄存器 */
+#define SRE_TM_PORT_FIFO_DFX_REG                (SRE_TM_BASE + 0x390)            /* TM_PORT_FIFO DFX寄存器 */
+#define SRE_TM_QUEUE_SCH_FIFO_DFX_REG           (SRE_TM_BASE + 0x394)            /* QUEUE_SCH 模块FIFO DFX寄存器 */
+#define SRE_TM_QUEUE_STA_FIFO_DFX_REG           (SRE_TM_BASE + 0x398)            /* QUEUE_STA 模块FIFO DFX寄存器 */
+#define SRE_TM_OTHER_FIFO_DFX_REG               (SRE_TM_BASE + 0x39C)            /* TM OTHER模块FIFO DFX寄存器 */
+#define SRE_TM_CPU_ADDPKT_CNT_REG               (SRE_TM_BASE + 0x3A0)            /* TM CPU成功添加包任务个数计数器 */
+#define SRE_TM_ACC_ADDPKT_CNT_REG               (SRE_TM_BASE + 0x3A4)            /* TM 加速器成功添加包任务个数计数器 */
+#define SRE_TM_QM2TK_PKT_CNT_REG                (SRE_TM_BASE + 0x3A8)            /* TM队列管理模块输出给Trunk模块包个数计数器 */
+#define SRE_TM_NOTEN_DROP_CNT_REG               (SRE_TM_BASE + 0x3AC)            /* TM 队列不使能丢弃包个数统计计数器 */
+#define SRE_TM_WRED_DROP_CNT_REG                (SRE_TM_BASE + 0x3B0)            /* TM 队列WRED/TAIL丢弃包个数统计计数器 */
+#define SRE_TM_NOBUF_DROP_CNT_REG               (SRE_TM_BASE + 0x3B4)            /* TM 队列缓存空间满丢弃包个数统计计数器 */
+#define SRE_TM_OUTPORT_DROP_CNT_REG             (SRE_TM_BASE + 0x3B8)            /* TM 队列指定端口丢弃个数统计寄存器 */
+#define SRE_TM_SPPE_PPE_DROP_CNT_REG            (SRE_TM_BASE + 0x3BC)            /* TM 队列SPPE/PPE丢弃包个数统计计数器 */
+#define SRE_TM_PORT0_SEND_CNT_REG               (SRE_TM_BASE + 0x3C0)            /* TM PORT0发送包数寄存器 */
+#define SRE_TM_PORT1_SEND_CNT_REG               (SRE_TM_BASE + 0x3C4)            /* TM PORT1发送包数寄存器 */
+#define SRE_TM_PORT2_SEND_CNT_REG               (SRE_TM_BASE + 0x3C8)            /* TM PORT2发送包数寄存器 */
+#define SRE_TM_PORT3_SEND_CNT_REG               (SRE_TM_BASE + 0x3CC)            /* TM PORT3发送包数寄存器 */
+#define SRE_TM_PORT4_SEND_CNT_REG               (SRE_TM_BASE + 0x3D0)            /* TM PORT4发送包数寄存器 */
+#define SRE_TM_PORT5_SEND_CNT_REG               (SRE_TM_BASE + 0x3D4)            /* TM PORT5发送包数寄存器 */
+#define SRE_TM_PORT6_SEND_CNT_REG               (SRE_TM_BASE + 0x3D8)            /* TM PORT6发送包数寄存器 */
+#define SRE_TM_PORT7_SEND_CNT_REG               (SRE_TM_BASE + 0x3DC)            /* TM PORT7发送包数寄存器 */
+#define SRE_TM_PORT8_SEND_CNT_REG               (SRE_TM_BASE + 0x3E0)            /* TM PORT8发送包数寄存器 */
+#define SRE_TM_PORT9_SEND_CNT_REG               (SRE_TM_BASE + 0x3E4)            /* TM PORT9发送包数寄存器 */
+#define SRE_TM_PORT10_SEND_CNT_REG              (SRE_TM_BASE + 0x3E8)            /* TM PORT10发送包数寄存器 */
+#define SRE_TM_PORT11_SEND_CNT_REG              (SRE_TM_BASE + 0x3EC)            /* TM PORT11发送包数寄存器 */
+#define SRE_TM_PORT12_SEND_CNT_REG              (SRE_TM_BASE + 0x3F0)            /* TM PORT12发送包数寄存器 */
+#define SRE_TM_PORT13_SEND_CNT_REG              (SRE_TM_BASE + 0x3F4)            /* TM PORT13发送包数寄存器 */
+#define SRE_TM_PORT14_SEND_CNT_REG              (SRE_TM_BASE + 0x3F8)            /* TM PORT14发送包数寄存器 */
+#define SRE_TM_PORT15_SEND_CNT_REG              (SRE_TM_BASE + 0x3FC)            /* TM PORT15发送包数寄存器 */
+#define SRE_TM_STA_CNT_CLR_REG                  (SRE_TM_BASE + 0x414)            /* TM读清寄存器清除信号配置寄存器 */
+#define SRE_TM_RAM_INIT_DONE_REG                (SRE_TM_BASE + 0x418)            /* TM内部RAM初始化完成指示寄存器 */
+#define SRE_TM_TOKEN_INIT_DONE_REG              (SRE_TM_BASE + 0x41C)            /* TM剩余令牌桶初始化完毕指示寄存器 */
+#define SRE_TM_PKT_VLD_CORE_0_REG               (SRE_TM_BASE + 0x420)            /* Core添加是否成功寄存器 */
+#define SRE_TM_PKT_VLD_CORE_1_REG               (SRE_TM_BASE + 0x424)            /* Core添加是否成功寄存器 */
+#define SRE_TM_SOLE_CNT_REG                     (SRE_TM_BASE + 0x530)            /* TM队列独享空间大小寄存器 */
+#define SRE_TM_ACTIVE_USE_REG                   (SRE_TM_BASE + 0x534)            /* TM使用队列数寄存器 */
+#define SRE_TM_DROP_OVERFLOW_ADDR_REG           (SRE_TM_BASE + 0x538)            /* TM丢弃队列溢出DDR基地址寄存器 */
+#define SRE_TM_DROP_QDEPTH_REG                  (SRE_TM_BASE + 0x53C)            /* TM丢弃队列溢出深度 */
+#define SRE_TM_WRED_RANDOM_INIT_REG             (SRE_TM_BASE + 0x540)            /* TM WRED随机数初始值 */
+#define SRE_TM_PORT_DROP_EN_REG                 (SRE_TM_BASE + 0x544)            /* TM指定端口丢包寄存器 */
+#define SRE_TM_BMU_BUF_REG                      (SRE_TM_BASE + 0x548)            /* TM 基于释放BMU BUFFER基地址寄存器 */
+#define SRE_TM_WEIGHT_OFFSET_REG                (SRE_TM_BASE + 0x54C)            /* TM权重偏移寄存器 */
+#define SRE_TM_TK_BIND_TAB_0_REG                (SRE_TM_BASE + 0x550)            /* TRUNK绑定表 */
+#define SRE_TM_TK_BIND_TAB_1_REG                (SRE_TM_BASE + 0x554)            /* TRUNK绑定表 */
+#define SRE_TM_PORT_WADDR_0_REG                 (SRE_TM_BASE + 0x590)            /* TM发送端口地址寄存器 */
+#define SRE_TM_PORT_WADDR_1_REG                 (SRE_TM_BASE + 0x594)            /* TM发送端口地址寄存器 */
+#define SRE_TM_PORT_PART_DESC_0_REG             (SRE_TM_BASE + 0x5D0)            /* TM发送端口描述符域段配置寄存器寄存器 */
+#define SRE_TM_PORT_PART_DESC_1_REG             (SRE_TM_BASE + 0x5D4)            /* TM发送端口描述符域段配置寄存器寄存器 */
+#define SRE_TM_PORT_SEND_TYPE_0_REG             (SRE_TM_BASE + 0x610)            /* TM端口发送特性表 */
+#define SRE_TM_PORT_SEND_TYPE_1_REG             (SRE_TM_BASE + 0x614)            /* TM端口发送特性表 */
+#define SRE_TM_TK_IR_TAB_0_REG                  (SRE_TM_BASE + 0x650)            /* Trunk端口速率参数表 */
+#define SRE_TM_TK_IR_TAB_1_REG                  (SRE_TM_BASE + 0x654)            /* Trunk端口速率参数表 */
+#define SRE_TM_WRED_OFFSET_REG                  (SRE_TM_BASE + 0x690)            /* WRED参数偏移寄存器 */
+#define SRE_TM_DEF_PORT_0_REG                   (SRE_TM_BASE + 0x694)            /* TM默认端口寄存器 */
+#define SRE_TM_DEF_PORT_1_REG                   (SRE_TM_BASE + 0x698)            /* TM默认端口寄存器 */
+#define SRE_TM_TK_SOFT_BP_REG                   (SRE_TM_BASE + 0x6D4)            /* TM软件基于TK口配置反压寄存器 */
+#define SRE_TM_NODE_CODE_REG                    (SRE_TM_BASE + 0x6DC)            /* TM消息源设备号 */
+#define SRE_TM_RAM_CFG_INTMSK_REG               (SRE_TM_BASE + 0x700)            /* TM_RAM_CFG模块中断屏蔽寄存器 */
+#define SRE_TM_RAM_CFG_RINT_REG                 (SRE_TM_BASE + 0x704)            /* TM_RAM_CFG原始中断寄存器 */
+#define SRE_TM_RAM_CFG_INTSTS_REG               (SRE_TM_BASE + 0x708)            /* TM_OTHER屏蔽后中断状态寄存器 */
+#define SRE_TM_OTHER_INTMSK_REG                 (SRE_TM_BASE + 0x70C)            /* TM_OTHER模块中断屏蔽寄存器 */
+#define SRE_TM_OTHER_RINT_REG                   (SRE_TM_BASE + 0x710)            /* TM_OTHER原始中断寄存器 */
+#define SRE_TM_OTHER_INTSTS_REG                 (SRE_TM_BASE + 0x714)            /* TM_OTHER屏蔽后中断状态寄存器 */
+#define SRE_TM_ANOTHER_INTMSK_REG               (SRE_TM_BASE + 0x718)            /* TM_ANOTHER模块中断屏蔽寄存器 */
+#define SRE_TM_ANOTHER_RINT_REG                 (SRE_TM_BASE + 0x71C)            /* TM_ANOTHER原始中断寄存器 */
+#define SRE_TM_ANOTHER_INTSTS_REG               (SRE_TM_BASE + 0x720)            /* TM_ANOTHER屏蔽后中断状态寄存器 */
+#define SRE_TM_TK_CNT_0_REG                     (SRE_TM_BASE + 0x730)            /* Trunk端口缓存队列统计计数器 */
+#define SRE_TM_TK_CNT_1_REG                     (SRE_TM_BASE + 0x734)            /* Trunk端口缓存队列统计计数器 */
+#define SRE_TM_POOL_RLS_CNT_0_REG               (SRE_TM_BASE + 0x770)            /* TM释放BMU Buffer基于Pool计数器 */
+#define SRE_TM_POOL_RLS_CNT_1_REG               (SRE_TM_BASE + 0x774)            /* TM释放BMU Buffer基于Pool计数器 */
+#define SRE_TM_POOL_RLS_CNT_CLR_REG             (SRE_TM_BASE + 0x7F0)            /* TM释放BMU Buffer基于Pool计数器 */
+#define SRE_TM_QINF_TABLE_0_REG                 (SRE_TM_BASE + 0x800)            /* 队列信息表 */
+#define SRE_TM_QINF_TABLE_1_REG                 (SRE_TM_BASE + 0x804)            /* 队列信息表 */
+#define SRE_TM_WRED_TABLE_0_REG                 (SRE_TM_BASE + 0x8800)           /* 流队列WRED表 */
+#define SRE_TM_WRED_TABLE_1_REG                 (SRE_TM_BASE + 0x8804)           /* 流队列WRED表 */
+#define SRE_TM_COM_LINK_TABLE_0_REG             (SRE_TM_BASE + 0xC800)           /* 小区到逻辑端口链接表 */
+#define SRE_TM_COM_LINK_TABLE_1_REG             (SRE_TM_BASE + 0xC804)           /* 小区到逻辑端口链接表 */
+#define SRE_TM_LOC_LINK_TABLE_0_REG             (SRE_TM_BASE + 0xD800)           /* 逻辑端口到Trunk端口连接表 */
+#define SRE_TM_LOC_LINK_TABLE_1_REG             (SRE_TM_BASE + 0xD804)           /* 逻辑端口到Trunk端口连接表 */
+#define SRE_TM_LOC_MAP_TAB_0_REG                (SRE_TM_BASE + 0xDD18)           /* 逻辑端口映射表 */
+#define SRE_TM_LOC_MAP_TAB_1_REG                (SRE_TM_BASE + 0xDD1C)           /* 逻辑端口映射表 */
+#define SRE_TM_COM_MAP_TAB_0_REG                (SRE_TM_BASE + 0xE518)           /* 小区端口映射表 */
+#define SRE_TM_COM_MAP_TAB_1_REG                (SRE_TM_BASE + 0xE51C)           /* 小区端口映射表 */
+#define SRE_TM_FQ_WEIGHT_TAB_0_REG              (SRE_TM_BASE + 0x10818)          /* 流队列权重表 */
+#define SRE_TM_FQ_WEIGHT_TAB_1_REG              (SRE_TM_BASE + 0x1081C)          /* 流队列权重表 */
+#define SRE_TM_COM_WEIGHT_TAB_0_REG             (SRE_TM_BASE + 0x18818)          /* 小区权重表 */
+#define SRE_TM_COM_WEIGHT_TAB_1_REG             (SRE_TM_BASE + 0x1881C)          /* 小区权重表 */
+#define SRE_TM_LOC_WEIGHT_TAB_0_REG             (SRE_TM_BASE + 0x19358)          /* 逻辑端口权重表 */
+#define SRE_TM_LOC_WEIGHT_TAB_1_REG             (SRE_TM_BASE + 0x1935C)          /* 逻辑端口权重表 */
+#define SRE_TM_LOC_CIR_TAB_0_REG                (SRE_TM_BASE + 0x19870)          /* 逻辑端口C桶shaping参数表 */
+#define SRE_TM_LOC_CIR_TAB_1_REG                (SRE_TM_BASE + 0x19874)          /* 逻辑端口C桶shaping参数表 */
+#define SRE_TM_LOC_PIR_TAB_0_REG                (SRE_TM_BASE + 0x19D88)          /* 逻辑端口P桶shaping参数表 */
+#define SRE_TM_LOC_PIR_TAB_1_REG                (SRE_TM_BASE + 0x19D8C)          /* 逻辑端口P桶shaping参数表 */
+#define SRE_TM_COM_CIR_TAB_0_REG                (SRE_TM_BASE + 0x1A2A0)          /* 小区端口C桶shaping参数表 */
+#define SRE_TM_COM_CIR_TAB_1_REG                (SRE_TM_BASE + 0x1A2A4)          /* 小区端口C桶shaping参数表 */
+#define SRE_TM_COM_PIR_TAB_0_REG                (SRE_TM_BASE + 0x1ADE0)          /* 小区端口P桶shaping参数表 */
+#define SRE_TM_COM_PIR_TAB_1_REG                (SRE_TM_BASE + 0x1ADE4)          /* 小区端口P桶shaping参数表 */
+#define SRE_TM_FQ_SCH_TYPE_TAB_0_REG            (SRE_TM_BASE + 0x1B920)          /* FQ队列调度属性表 */
+#define SRE_TM_FQ_SCH_TYPE_TAB_1_REG            (SRE_TM_BASE + 0x1B924)          /* FQ队列调度属性表 */
+#define SRE_TM_FQ_ST_BYTE_TAB_0_REG             (SRE_TM_BASE + 0x1C920)          /* 流队字节列缓存统计表 */
+#define SRE_TM_FQ_ST_BYTE_TAB_1_REG             (SRE_TM_BASE + 0x1C924)          /* 流队字节列缓存统计表 */
+#define SRE_TM_FQ_ST_NUM_TAB_0_REG              (SRE_TM_BASE + 0x24920)          /* 流队列包个数缓存统计表 */
+#define SRE_TM_FQ_ST_NUM_TAB_1_REG              (SRE_TM_BASE + 0x24924)          /* 流队列包个数缓存统计表 */
+#define SRE_TM_COM_ST_NUM_TAB_0_REG             (SRE_TM_BASE + 0x2C920)          /* 小区队列缓存统计表 */
+#define SRE_TM_COM_ST_NUM_TAB_1_REG             (SRE_TM_BASE + 0x2C924)          /* 小区队列缓存统计表 */
+#define SRE_TM_LOC_ST_NUM_TAB_0_REG             (SRE_TM_BASE + 0x2D920)          /* 逻辑端口缓存队列个数统计表 */
+#define SRE_TM_LOC_ST_NUM_TAB_1_REG             (SRE_TM_BASE + 0x2D924)          /* 逻辑端口缓存队列个数统计表 */
+#define SRE_TM_LOC_ST_BYTE_TAB_0_REG            (SRE_TM_BASE + 0x2DE38)          /* 逻辑端口缓存队列字节数统计表 */
+#define SRE_TM_LOC_ST_BYTE_TAB_1_REG            (SRE_TM_BASE + 0x2DE3C)          /* 逻辑端口缓存队列字节数统计表 */
+#define SRE_TM_LOC_SD_NUM_TAB_0_REG             (SRE_TM_BASE + 0x2E350)          /* 逻辑端口发送队列个数统计表 */
+#define SRE_TM_LOC_SD_NUM_TAB_1_REG             (SRE_TM_BASE + 0x2E354)          /* 逻辑端口发送队列个数统计表 */
+#define SRE_TM_LOC_SD_BYTE_TAB_0_REG            (SRE_TM_BASE + 0x2E868)          /* 逻辑端口发送队列字节数统计表 */
+#define SRE_TM_LOC_SD_BYTE_TAB_1_REG            (SRE_TM_BASE + 0x2E86C)          /* 逻辑端口发送队列字节数统计表 */
+#define SRE_TM_PKT_WORD0_CORE_0_REG             (SRE_TM_BASE + 0x100000)         /* Core写TM模块的msg WORD0 */
+#define SRE_TM_PKT_WORD0_CORE_1_REG             (SRE_TM_BASE + 0x100010)         /* Core写TM模块的msg WORD0 */
+#define SRE_TM_PKT_WORD1_CORE_0_REG             (SRE_TM_BASE + 0x100004)         /* Core写TM模块的msg WORD1 */
+#define SRE_TM_PKT_WORD1_CORE_1_REG             (SRE_TM_BASE + 0x100014)         /* Core写TM模块的msg WORD1 */
+#define SRE_TM_PKT_WORD2_CORE_0_REG             (SRE_TM_BASE + 0x100008)         /* Core写TM模块的msg WORD2 */
+#define SRE_TM_PKT_WORD2_CORE_1_REG             (SRE_TM_BASE + 0x100018)         /* Core写TM模块的msg WORD2 */
+#define SRE_TM_PKT_WORD3_CORE_0_REG             (SRE_TM_BASE + 0x10000C)         /* Core写TM模块的msg WORD3 */
+#define SRE_TM_PKT_WORD3_CORE_1_REG             (SRE_TM_BASE + 0x10001C)         /* Core写TM模块的msg WORD3 */
+#define SRE_TM_PKT_WORD0_ACC_REG                (SRE_TM_BASE + 0x100400)         /* 加速器写TM模块msg WORD0 */
+#define SRE_TM_PKT_WORD1_ACC_REG                (SRE_TM_BASE + 0x100404)         /* 加速器写TM模块msg WORD1 */
+#define SRE_TM_PKT_WORD2_ACC_REG                (SRE_TM_BASE + 0x100408)         /* 加速器写TM模块msg WORD2 */
+#define SRE_TM_PKT_WORD3_ACC_REG                (SRE_TM_BASE + 0x10040C)         /* 加速器写TM模块msg WORD3 */
+
+/* AQM 模块寄存器表单 */
+#define SRE_AQM_BASE                            (SRE_TM_BASE + 0x200000)         /* 使用TM后2M空间 */
+
+/******************************************************************************/
+/*                      MC AQM 寄存器定义                                     */
+/******************************************************************************/
+#define SRE_AQM_VER_DATE_REG                       (SRE_AQM_BASE + 0x0)                 /* AQM 版本寄存器 */
+#define SRE_AQM_RFS_EMA_CTRL_REG                   (SRE_AQM_BASE + 0x4)                 /* TM RFS MEM时序控制信号 */
+#define SRE_AQM_RAS_EMA_CTRL_REG                   (SRE_AQM_BASE + 0x8)                 /* TM RAS MEM时序控制信号 */
+#define SRE_AQM_HD_EMA_CTRL_REG                    (SRE_AQM_BASE + 0xC)                 /* AQM RAM 功耗模式控制 */
+#define SRE_AQM_INIT_DONE_REG                      (SRE_AQM_BASE + 0x10)                /* AQM内部初始化完成标识 */
+#define SRE_AQM_CFG_OK_REG                         (SRE_AQM_BASE + 0x14)                /* 软件配置AQM完成寄存器 */
+#define SRE_AQM_LINKTABLE_INIT_DONE_REG            (SRE_AQM_BASE + 0x18)                /* AQM内部链表初始完成标识 */
+#define SRE_AQM_INFO_BASE_ADDR_REG                 (SRE_AQM_BASE + 0x20)                /* AQM队列信息表基地址 */
+#define SRE_AQM_LINK_BASE_ADDR_REG                 (SRE_AQM_BASE + 0x24)                /* AQM队列链表基地址 */
+#define SRE_AQM_DESCPT_BASE_ADDR_REG               (SRE_AQM_BASE + 0x28)                /* AQM存储描述符基地址 */
+#define SRE_AQM_TIME_BASE_ADDR_REG                 (SRE_AQM_BASE + 0x2C)                /* AQM 超时扫描溢出基地址 */
+#define SRE_AQM_SEND_PORT_ADDR_REG                 (SRE_AQM_BASE + 0x30)                /* AQM发送端口寄存器 */
+#define SRE_AQM_SEND_NODE_CODE_REG                 (SRE_AQM_BASE + 0x34)                /* AQM使用NODE CODE */
+#define SRE_AQM_USER_REG                           (SRE_AQM_BASE + 0x38)                /* AQM使用USER */
+#define SRE_AQM_RAND_INTT_REG                      (SRE_AQM_BASE + 0x3C)                /* AQM丢弃算法初始随机数 */
+#define SRE_AQM_RED_TYPE_IND_REG                   (SRE_AQM_BASE + 0x40)                /* AQM丢弃算法依据方式 */
+#define SRE_AQM_SCH_TYPE_IND_REG                   (SRE_AQM_BASE + 0x44)                /* AQM调度依据方式 */
+#define SRE_AQM_LINK_THR_REG                       (SRE_AQM_BASE + 0x48)                /* AQM内部链表fifo溢出和回读门限 */
+#define SRE_AQM_LINK_DEPTH_REG                     (SRE_AQM_BASE + 0x4C)                /* AQM链表深度配置寄存器 */
+#define SRE_AQM_TIME_INTERVAL_REG                  (SRE_AQM_BASE + 0x50)                /* AQM 超时扫描间隔 */
+#define SRE_AQM_TIME_FIFO_THR_REG                  (SRE_AQM_BASE + 0x54)                /* AQM 超时扫描FIFO溢出回读门限 */
+#define SRE_AQM_TIME_DEPTH_REG                     (SRE_AQM_BASE + 0x58)                /* AQM超时回读溢出深度配置寄存器 */
+#define SRE_AQM_TIME_SCAN_SWITCH_REG               (SRE_AQM_BASE + 0x5C)                /* AQM 超时扫描控制开关 */
+#define SRE_AQM_MST_CFG_REG                        (SRE_AQM_BASE + 0x60)                /* AQM 操作AXI总线配置寄存器 */
+#define SRE_AQM_CF_TIMEOUT_REG                     (SRE_AQM_BASE + 0x64)                /* AQM MST重传次数过多中断上报未清除超时时间配置寄存器 */
+#define SRE_AQM_MST_CNT_CTRL_REG                   (SRE_AQM_BASE + 0x68)                /* AQM MST口内部通道统计控制寄存器 */
+#define SRE_AQM_MST_LATENCY_AVG_REG                (SRE_AQM_BASE + 0x6C)                /* AQM MST口平均延时寄存器 */
+#define SRE_AQM_MST_LATENCY_MAX_REG                (SRE_AQM_BASE + 0x70)                /* AQM MST口最大延时寄存器 */
+#define SRE_AQM_AXI_INT_MASK_REG                   (SRE_AQM_BASE + 0x74)                /* AQM 读写AXI总线中断屏蔽寄存器 */
+#define SRE_AQM_AXI_RINT_REG                       (SRE_AQM_BASE + 0x78)                /* AQM 读写AXI总线原始中断 */
+#define SRE_AQM_AXI_INT_REG                        (SRE_AQM_BASE + 0x7C)                /* AQM 读写AXI总线中断信号 */
+#define SRE_AQM_ERR_INST_REG                       (SRE_AQM_BASE + 0x80)                /* AQM错误植入寄存器 */
+#define SRE_AQM_ERR_MASK_REG                       (SRE_AQM_BASE + 0x84)                /* AQM中断屏蔽寄存器 */
+#define SRE_AQM_FIFO_ERR_MASK0_REG                 (SRE_AQM_BASE + 0x88)                /* AQM FIFO中断屏蔽寄存器0 */
+#define SRE_AQM_FIFO_ERR_MASK1_REG                 (SRE_AQM_BASE + 0x8C)                /* AQM FIFO中断屏蔽寄存器1 */
+#define SRE_AQM_ERR_RINT_REG                       (SRE_AQM_BASE + 0x90)                /* AQM 错误植入原始中断寄存器 */
+#define SRE_AQM_FIFO_ERR_RINT0_REG                 (SRE_AQM_BASE + 0x94)                /* AQM FIFO原始中断寄存器0 */
+#define SRE_AQM_FIFO_ERR_RINT1_REG                 (SRE_AQM_BASE + 0x98)                /* AQM FIFO原始中断寄存器1 */
+#define SRE_AQM_ERR_INT_REG                        (SRE_AQM_BASE + 0x9C)                /* AQM错误植入中断寄存器 */
+#define SRE_AQM_FIFO_ERR_INT0_REG                  (SRE_AQM_BASE + 0xA0)                /* AQM FIFO中断寄存器0 */
+#define SRE_AQM_FIFO_ERR_INT1_REG                  (SRE_AQM_BASE + 0xA4)                /* AQM FIFO中断寄存器1 */
+#define SRE_AQM_FIFO_DFX0_REG                      (SRE_AQM_BASE + 0xA8)                /* AQM FIFO DFX寄存器0 */
+#define SRE_AQM_FIFO_DFX1_REG                      (SRE_AQM_BASE + 0xAC)                /* AQM FIFO DFX寄存器1 */
+#define SRE_AQM_INQ_PKT_CNT_REG                    (SRE_AQM_BASE + 0xB0)                /* AQM 入队描述符统计 */
+#define SRE_AQM_INQ_PKT_OK_CNT_REG                 (SRE_AQM_BASE + 0xB4)                /* AQM入队成功描述符统计 */
+#define SRE_AQM_OUTQ_CARRY_CNT_REG                 (SRE_AQM_BASE + 0xB8)                /* AQM 承载出队指令统计 */
+#define SRE_AQM_SWITCH_CARRY_CNT_REG               (SRE_AQM_BASE + 0xBC)                /* AQM承载切换指令统计 */
+#define SRE_AQM_DROP_CARRY_CNT_REG                 (SRE_AQM_BASE + 0xC0)                /* AQM承载丢弃指令统计 */
+#define SRE_AQM_DROP_DESCPT_CNT_REG                (SRE_AQM_BASE + 0xC4)                /* AQM丢弃描述符统计 */
+#define SRE_AQM_OUTQ_DESCPT_CNT_REG                (SRE_AQM_BASE + 0xC8)                /* AQM出队描述符统计 */
+#define SRE_AQM_FQ_PKT_CNT_REG                     (SRE_AQM_BASE + 0xCC)                /* AQM 快速出队描述符统计 */
+#define SRE_AQM_DIS_DROP_CNT_REG                   (SRE_AQM_BASE + 0xD0)                /* AQM 队列未使能丢弃统计 */
+#define SRE_AQM_BUF_DROP_CNT_REG                   (SRE_AQM_BASE + 0xD4)                /* AQM 缓存申请失败丢弃统计 */
+#define SRE_AQM_WRED_DROP_CNT_REG                  (SRE_AQM_BASE + 0xD8)                /* AQM WRED丢弃描述符统计 */
+#define SRE_AQM_LINK_FREE_PTR_CNT_REG              (SRE_AQM_BASE + 0xDC)                /* AQM 链表空指针计数寄存器 */
+#define SRE_AQM_MST_CNT_RD_ACC_REG                 (SRE_AQM_BASE + 0xE0)                /* AQM MST口读计数器 */
+#define SRE_AQM_MST_CNT_WR_ACC_REG                 (SRE_AQM_BASE + 0xE4)                /* AQM MST口写计数器 */
+#define SRE_AQM_CREDIT_PKT_CNT_REG                 (SRE_AQM_BASE + 0xE8)                /* AQM 欠权重快速出队描述符统计 */
+#define SRE_AQM_INTER_FSM0_REG                     (SRE_AQM_BASE + 0xF0)                /* AQM 内部状态机状态监控寄存器0 */
+#define SRE_AQM_INTER_FSM1_REG                     (SRE_AQM_BASE + 0xF4)                /* AQM 内部状态机状态监控寄存器1 */
+#define SRE_AQM_RED_MAX_THR_0_REG                  (SRE_AQM_BASE + 0x100)               /* AQM RED丢弃模板最大门限 */
+#define SRE_AQM_RED_MAX_THR_1_REG                  (SRE_AQM_BASE + 0x104)               /* AQM RED丢弃模板最大门限 */
+#define SRE_AQM_RED_MIN_THR_0_REG                  (SRE_AQM_BASE + 0x200)               /* AQM RED丢弃模板最小门限 */
+#define SRE_AQM_RED_MIN_THR_1_REG                  (SRE_AQM_BASE + 0x204)               /* AQM RED丢弃模板最小门限 */
+#define SRE_AQM_RED_DROP_SLOP_0_REG                (SRE_AQM_BASE + 0x300)               /* AQM RED丢弃模板斜率 */
+#define SRE_AQM_RED_DROP_SLOP_1_REG                (SRE_AQM_BASE + 0x304)               /* AQM RED丢弃模板斜率 */
+#define SRE_AQM_SCH_WEIGHT_0_REG                   (SRE_AQM_BASE + 0x400)               /* AQM 调度权重模板 */
+#define SRE_AQM_SCH_WEIGHT_1_REG                   (SRE_AQM_BASE + 0x404)               /* AQM 调度权重模板 */
+#define SRE_AQM_TIMEOUT_DROP_0_REG                 (SRE_AQM_BASE + 0x500)               /* AQM 超时丢弃模板 */
+#define SRE_AQM_TIMEOUT_DROP_1_REG                 (SRE_AQM_BASE + 0x504)               /* AQM 超时丢弃模板 */
+#define SRE_AQM_FQ_SCH_TYPE_0_REG                  (SRE_AQM_BASE + 0x600)               /* AQM调度属性表 */
+#define SRE_AQM_FQ_SCH_TYPE_1_REG                  (SRE_AQM_BASE + 0x604)               /* AQM调度属性表 */
+#define SRE_AQM_INTER_TEST0_REG                    (SRE_AQM_BASE + 0x680)               /* AQM 内部测试寄存器0 */
+#define SRE_AQM_INTER_TEST1_REG                    (SRE_AQM_BASE + 0x684)               /* AQM 内部测试寄存器1 */
+#define SRE_AQM_INTER_TEST2_REG                    (SRE_AQM_BASE + 0x688)               /* AQM 内部测试寄存器2 */
+#define SRE_AQM_INTER_TEST3_REG                    (SRE_AQM_BASE + 0x68C)               /* AQM 内部测试寄存器3 */
+#define SRE_AQM_INTER_CFG0_REG                     (SRE_AQM_BASE + 0x690)               /* AQM 内部配置寄存器0 */
+#define SRE_AQM_INTER_CFG1_REG                     (SRE_AQM_BASE + 0x694)               /* AQM 内部配置寄存器1 */
+#define SRE_AQM_INTER_CFG2_REG                     (SRE_AQM_BASE + 0x698)               /* AQM 内部配置寄存器2 */
+#define SRE_AQM_INTER_CFG3_REG                     (SRE_AQM_BASE + 0x69C)               /* AQM 内部配置寄存器3 */
+#define SRE_AQM_PKT_VLD_CORE_0_REG                 (SRE_AQM_BASE + 0x700)               /* Core添加是否成功寄存器 */
+#define SRE_AQM_PKT_VLD_CORE_1_REG                 (SRE_AQM_BASE + 0x704)               /* Core添加是否成功寄存器 */
+#define SRE_AQM_FQ_EN_0_REG                        (SRE_AQM_BASE + 0x800)               /* AQM 队列使能表 */
+#define SRE_AQM_FQ_EN_1_REG                        (SRE_AQM_BASE + 0x804)               /* AQM 队列使能表 */
+#define SRE_AQM_SCH_TYPE_ID_0_REG                  (SRE_AQM_BASE + 0x20800)             /* AQM调度属性表索引号 */
+#define SRE_AQM_SCH_TYPE_ID_1_REG                  (SRE_AQM_BASE + 0x20804)             /* AQM调度属性表索引号 */
+#define SRE_AQM_PKT_WORD0_CORE_0_REG               (SRE_AQM_BASE + 0x100000)            /* Core写TM模块的msg WORD0 */
+#define SRE_AQM_PKT_WORD0_CORE_1_REG               (SRE_AQM_BASE + 0x100010)            /* Core写TM模块的msg WORD0 */
+#define SRE_AQM_PKT_WORD1_CORE_0_REG               (SRE_AQM_BASE + 0x100004)            /* Core写TM模块的msg WORD1 */
+#define SRE_AQM_PKT_WORD1_CORE_1_REG               (SRE_AQM_BASE + 0x100014)            /* Core写TM模块的msg WORD1 */
+#define SRE_AQM_PKT_WORD2_CORE_0_REG               (SRE_AQM_BASE + 0x100008)            /* Core写TM模块的msg WORD2 */
+#define SRE_AQM_PKT_WORD2_CORE_1_REG               (SRE_AQM_BASE + 0x100018)            /* Core写TM模块的msg WORD2 */
+#define SRE_AQM_PKT_WORD3_CORE_0_REG               (SRE_AQM_BASE + 0x10000C)            /* Core写TM模块的msg WORD3 */
+#define SRE_AQM_PKT_WORD3_CORE_1_REG               (SRE_AQM_BASE + 0x10001C)            /* Core写TM模块的msg WORD3 */
+#define SRE_AQM_PKT_WORD0_ACC_REG                  (SRE_AQM_BASE + 0x100400)            /* 加速器写TM模块msg WORD0 */
+#define SRE_AQM_PKT_WORD1_ACC_REG                  (SRE_AQM_BASE + 0x100404)            /* 加速器写TM模块msg WORD1 */
+#define SRE_AQM_PKT_WORD2_ACC_REG                  (SRE_AQM_BASE + 0x100408)            /* 加速器写TM模块msg WORD2 */
+#define SRE_AQM_PKT_WORD3_ACC_REG                  (SRE_AQM_BASE + 0x10040C)            /* 加速器写TM模块msg WORD3 */
+#define SRE_AQM_CARRY_WORD_0_REG                   (SRE_AQM_BASE + 0x100800)            /* AQM承载指令添加寄存器 */
+#define SRE_AQM_CARRY_WORD_1_REG                   (SRE_AQM_BASE + 0x100804)            /* AQM承载指令添加寄存器 */
+
+#define DDRC0_CTRL_REG               0x1302c000
+#define DDRC1_CTRL_REG               0x1302d000
+
+#define DDRC_CFG_PERF_REG            (0x270+DDRC0_CTRL_REG)
+
+/* DDR性能统计的命令ID配置寄存器  0x274+0x800*chs */
+#define DDRC_CFG_STAID_REG           (0x274+DDRC0_CTRL_REG)
+
+/* DDRC中断屏蔽寄存器 0x278+0x800*chs */
+#define DDRC_CFG_STAIDMSK_REG        (0x278+DDRC0_CTRL_REG)
+
+/* DDRC性能统计使能寄存器 0x010+0x800*chs */
+#define DDRC_CTRL_PERF_REG           (0x010+DDRC0_CTRL_REG)
+
+/* DDRC所有写命令流量统计寄存器 0x380+0x800*chs*/
+#define DDRC_HIS_FLUX_WR_REG         (0x380+DDRC0_CTRL_REG)
+
+/* DDRC所有读命令流量统计寄存器 0x384+0x800*chs */
+#define DDRC_HIS_FLUX_RD_REG         (0x384+DDRC0_CTRL_REG)
+
+/* DDRC所有写命令数目寄存器  0x388+0x800*chs */
+#define DDRC_HIS_FLUX_WCMD_REG       (0x388+DDRC0_CTRL_REG)
+
+/* DDRC所有读命令数目寄存器  0x38c+0x800*chs */
+#define DDRC_HIS_FLUX_RCM_REG        (0x38c+DDRC0_CTRL_REG)
+
+/* DDRC指定ID写流量统计寄存器 0x390+0x800*chs */
+#define DDRC_HIS_FLUXID_WR_REG       (0x390+DDRC0_CTRL_REG)
+
+/* DDRC指定ID读流量统计寄存器 0x394+0x800*chs */
+#define DDRC_HIS_FLUXID_RD_REG       (0x394+DDRC0_CTRL_REG)
+
+/* DDRC所有写命令数目统计寄存器 0x398+0x800*chs */
+#define DDRC_HIS_FLUXID_WCMD_REG     (0x398+DDRC0_CTRL_REG)
+
+/* DDRC所有读命令数目统计寄存器 0x039c+0x800*chs */
+#define DDRC_HIS_FLUXID_RCMD_REG     (0x39c+DDRC0_CTRL_REG)
+#define DDRC_HIS_WLATCNT0_REG        (0x3A0+DDRC0_CTRL_REG)
+#define DDRC_HIS_WLATCNT1_REG        (0x3A4+DDRC0_CTRL_REG)
+#define DDRC_HIS_RLATCNT0_REG        (0x3A8+DDRC0_CTRL_REG)
+#define DDRC_HIS_RLATCNT1_REG        (0x3AC+DDRC0_CTRL_REG)
+#define DDRC_HIS_INHERE_RLAT_CNT_REG (0x3B0+DDRC0_CTRL_REG)
+
+#define SCH_FTE_BASE            0x13032000
+
+#define FTE_AR_MODE_REG        (0x0080 + SCH_FTE_BASE)
+#define FTE_AR_PYLD0_REG       (0x0084 + SCH_FTE_BASE)
+#define FTE_AR_PYLD1_REG       (0x0088 + SCH_FTE_BASE)
+
+#define FTE_AW_MODE_REG        (0x0090 + SCH_FTE_BASE)
+#define FTE_AW_PYLD0_REG       (0x0094 + SCH_FTE_BASE)
+#define FTE_AW_PYLD1_REG       (0x0098 + SCH_FTE_BASE)
+
+#define FTE_AR_CNUM_REG        (0x0100 + SCH_FTE_BASE)
+#define FTE_AR_RNUM_REG        (0x0104 + SCH_FTE_BASE)
+#define FTE_AR_DAVG_REG        (0x0108 + SCH_FTE_BASE)
+#define FTE_AR_DMAX_REG        (0x010c + SCH_FTE_BASE)
+
+#define FTE_AW_CNUM_REG        (0x0110 + SCH_FTE_BASE)
+#define FTE_AW_RNUM_REG        (0x0114 + SCH_FTE_BASE)
+#define FTE_AW_DAVG_REG        (0x0118 + SCH_FTE_BASE)
+#define FTE_AW_DMAX_REG        (0x011c + SCH_FTE_BASE)
+
+/******************************************************************************/
+/*                       SPI 寄存器定义                                   */
+/******************************************************************************/
+#define SPI_REG_BASE_ADDR                             (0xe400a000)
+
+/******************************************************************************/
+/*                       IOCONFIG 寄存器定义                                   */
+/******************************************************************************/
+#define IOCONFIG_REG_BASE_ADDR                        0xe400c000
+
+/* BEGIN: Modified by g00198889, 2012-9-25   问题单号:SRIO 移植*/
+/******************************************************************************/
+/*                       SRIO 寄存器定义                                    */
+/******************************************************************************/
+#if 0         /* z00202052 */
+#define OS_SRE_SRIO_BASE_ADDR                         0x18000000UL
+#else
+#define OS_SRE_SRIO_BASE_ADDR                         0xe8000000UL
+#endif        /* z00202052 */
+/* 其他寄存器定义见srio_rabreg.h srio_offsetaddr.h */
+
+/******************************************************************************/
+/*                       MPE 寄存器定义                                    */
+/******************************************************************************/
+#if 0         /* z00202052 */
+#define OS_SRE_MPE_BASE_ADDR                          0x19000000UL
+#else
+#define OS_SRE_MPE_BASE_ADDR                          0xe9000000UL
+#endif        /* z00202052 */
+/* 其他寄存器定义见srio_mpe_reg.h */
+/* END:   Modified by g00198889, 2012-9-25 */
+
+/******************************************************************************/
+/*                       SERDES3 寄存器定义                                   */
+/******************************************************************************/
+#define SERDES3_BASE_ADDR                            (0xe8001000)
+
+/******************************************************************************/
+/*                       IOCTRL1 寄存器定义                                   */
+/******************************************************************************/
+#define IOCTRL1_BASE_ADDR                            (0xe8002000)
+
+/******************************************************************************/
+/*                       SERDES2 寄存器定义                                   */
+/******************************************************************************/
+#define SERDES2_BASE_ADDR                            (0xeb000000)
+
+/******************************************************************************/
+/*                       PM 寄存器定义                                    */
+/******************************************************************************/
+#define SRE_PM_BASE     (0x13029000)
+
+#define SRE_PM_SRST_REQ                             (SRE_PM_BASE + 0x0)
+#define SRE_PM_SCLK_EN                              (SRE_PM_BASE + 0x4)
+#define SRE_PM_SISO_EN                              (SRE_PM_BASE + 0x8)
+#define SRE_PM_SMTCMOS_EN                           (SRE_PM_BASE + 0xC)
+#define SRE_PM_SMTCMOS_STAT                         (SRE_PM_BASE + 0x10)
+#define SRE_PM_PD_REQ                               (SRE_PM_BASE + 0x14)
+#define SRE_PM_PD_STAT                              (SRE_PM_BASE + 0x18)
+#define SRE_PM_SEC1_IDLE_DLY                        (SRE_PM_BASE + 0x1C)
+#define SRE_PM_SEC0_IDLE_DLY                        (SRE_PM_BASE + 0x20)
+#define SRE_PM_MTCMOS_STAT                          (SRE_PM_BASE + 0x24)
+#define SRE_PM_SEC_PG_FSM_STAT                      (SRE_PM_BASE + 0x28)
+#define SRE_PMU_IMVP_CFG                            (SRE_PM_BASE + 0x88)
+
+#define SRE_GPIO_REG_BASE_ADDR 0xe4000000
+
+#define SRE_URAT_REG_BASEADDR           0xe4007000
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+#endif /* _SRE_MEMMAP_H */
diff --git a/drivers/misc/serdes/SRE_phydrv.c b/drivers/misc/serdes/SRE_phydrv.c
new file mode 100644
index 0000000..dd9917a
--- /dev/null
+++ b/drivers/misc/serdes/SRE_phydrv.c
@@ -0,0 +1,1675 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : SRE_phydrv.c
+  版 本 号   : 初稿
+  作    者   : w00146306
+  生成日期   : 2010年10月27日
+  最近修改   :
+  功能描述   : SRE PHY驱动模块
+  函数列表   :
+              SRE_InitPhy
+  修改历史   :
+  1.日    期   : 2010年10月27日
+    作    者   : w00146306
+    修改内容   : 创建文件
+
+******************************************************************************/
+
+/* 头文件包含 ----------------------------------*/
+#include "SRE_phydrv.h"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+#define OS_MDIO_ID_0      0x1
+#define OS_MDIO_ID_1      0x1
+#ifndef OS_MDIO_ID
+#define OS_MDIO_ID        OS_MDIO_ID_1
+#endif
+
+#if 0
+/*****************************************************************************
+ 函 数 名  : MDIO_Hi1381_Write
+ 功能描述  : MDIO写函数，往PHY寄存器写值
+ 输入参数  : UINT32 ulMdioPort
+             UINT32 ulPhyAddr
+             UINT32 ulRegAddr
+             UINT32 ulValue
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年6月5日
+    作    者   : g00198889
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 MDIO_Hi1381_Write(UINT32 ulMdioPort, UINT32 ulPhyAddr, UINT32 ulRegAddr, UINT32 ulValue)
+{
+    SRE_MDIO_CMD_REG_U      unMdioCmdReg;
+    MDIO_WDATA_REG_U        unMdioWDataReg;
+
+    UINT32                  ulTimeCnt     = 1000;
+    UINT32                   uwRet          = OS_FAIL;
+
+    if (ulMdioPort > 2)
+    {
+        SRE_printf("Wrong mdio port: ulMdioPort(%x)\n", ulMdioPort);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (ulPhyAddr > MDIO_MAX_PHY_ADDR)
+    {
+        SRE_printf("Wrong phy address\n");
+        return uwRet;
+    }
+
+    if (ulRegAddr > MDIO_MAX_PHY_REG_ADDR)
+    {
+        SRE_printf("Wrong reg address\n");
+        return uwRet;
+    }
+/*SRE_printf("%s %d; "" LeoGao mdio0 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    /* Step 1; 先判断MDIO_COMMAND_REG的mdio_start位是否为0，因为只有为0的时候，才可以进行读写操作  */
+    MDIO_REG_READ(ulMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+
+    while (unMdioCmdReg.bits.Mdio_Start)     /* 表示此时正在进行MDIO访问，需要等待50us  */
+    {
+        SRE_DelayCycle(1000);
+        //MC_PhyDelayUs(1000);        /* 延时50us,  650 FPGA下该时间不够，所以这里提高了二十倍的延时      */
+        ulTimeCnt--;
+        MDIO_REG_READ(ulMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+        if (0 == ulTimeCnt)         /* 表示已经超时，此时应该报错  */
+        {
+            SRE_printf(" Timeout! MDIO is always busy! MDIO_COMMAND_REG(0x%x) \n", unMdioCmdReg.u32);
+            return uwRet;
+        }
+    }
+/*SRE_printf("%s %d; "" LeoGao mdio1 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    /* Step 2; 将需要写入的值先写入写访问数据寄存器  */
+    MDIO_REG_READ(ulMdioPort, MDIO_WDATA_REG, unMdioWDataReg.u32);
+    unMdioWDataReg.bits.Mdio_Wdata = ulValue;
+    //SRE_printf("%s %d; "" LeoGao mdio2 Here; ulValue = 0x%x ! \n", __FUNCTION__, __LINE__, ulValue);
+    MDIO_REG_WRITE(ulMdioPort, MDIO_WDATA_REG, unMdioWDataReg.u32);
+    //SRE_printf("%s %d; "" LeoGao mdio3 Here ! \n", __FUNCTION__, __LINE__);
+
+    /* Step 3; 配置写操作命令  */
+    unMdioCmdReg.bits.Mdio_St    = MDIO_ST_CLAUSE_22;       /* 配置当前的mdio为clause22  */
+    unMdioCmdReg.bits.Mdio_Op    = MDIO_CLAUSE_22_WRITE;    /* 配置当前的操作为写操作  */
+    unMdioCmdReg.bits.Mdio_Prtad = (UINT16)ulPhyAddr;        /* 当mdio_st为2’b01时，表示要访问的外部的PHY地址  */
+    unMdioCmdReg.bits.Mdio_Devad = ulRegAddr;                /* 当mdio_st为2’b01时，表示要访问的外部PHY的寄存器地址  */
+    unMdioCmdReg.bits.Mdio_Start = 1;                       /* 启动操作  */
+/*SRE_printf("%s %d; "" LeoGao mdio4 Here ! \n", __FUNCTION__, __LINE__);  */
+    MDIO_REG_WRITE(ulMdioPort, MDIO_COMMAND_REG, unMdioCmdReg.u32);
+/*SRE_printf("%s %d; "" LeoGao mdio5 Here ! \n", __FUNCTION__, __LINE__);  */
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_PhyWriteReg(UINT32 ulMdioPort, UINT32 ulPhyAddr, UINT32 ulRegPage, UINT32 ulRegAddr, UINT32 ulValue)
+{
+    if((ulRegPage > 28) || (ulRegPage == 22))
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    MDIO_Hi1381_Write(ulMdioPort, ulPhyAddr, 22, ulRegPage);
+    MDIO_Hi1381_Write(ulMdioPort, ulPhyAddr, ulRegAddr, ulValue);
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 SRE_PhyTestWrite(UINT32 ulRegPage, UINT32 ulRegAddr, UINT32 ulValue)
+{
+    UINT32 ulMdioPort = 0;
+    UINT32 ulPhyAddr = 0;
+
+    SRE_PhyWriteReg(ulMdioPort, ulPhyAddr, ulRegPage, ulRegAddr, ulValue);
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 SRE_GeFpgaAdapt(UINT32 uwPort)
+{
+        SRE_SetPortMode(uwPort, GMAC_100M_SGMII);
+
+        SRE_PhyTestWrite(18, 20, 1);
+        SRE_PhyTestWrite(18, 20, 0x8001);
+
+        SRE_GMAC_WRITE_REG(uwPort, SRE_GMAC_TRANSMIT_CONTROL_REG, 0x60);
+
+        return OS_SUCCESS;
+}
+#endif
+
+UINT32 SRE_PhyDelayUs(UINT32 uwTime);
+extern UINT32 SRE_MdioRead(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 *puwRegValue);
+extern UINT32 SRE_MdioWrite(UINT32 uwMdioID, UINT32 uwPhyAddr, UINT32 uwPhyRegNum, UINT32 uwWriteValue);
+extern UINT32 MAR1512_PHY_Reset (UINT32 uwPhy);
+extern UINT32 MAR1512_PHY_SelfTest(UINT32 uwPhy);
+
+UINT32 MAR1512_SelectPage(UINT32 uwPort, UINT32 uwPhyAddr, UINT32 uwPage)
+{
+    UINT32 uwRet;
+
+    if ((uwPage > 28) || (uwPage == MII_PAGE_ADDR_REG))
+    {
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = SRE_MdioWrite(uwPort, uwPhyAddr, MII_PAGE_ADDR_REG, uwPage);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 MAR1512_Write(UINT32 uwRegAddr, UINT32 uwPage, UINT32 uwVal)
+{
+    UINT32 uwPort    = 0;
+    UINT32 uwPhyAddr = 0;
+    UINT32 uwRet;
+
+    uwRet = MAR1512_SelectPage(uwPort, uwPhyAddr, uwPage);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    uwRet = SRE_MdioWrite(uwPort, uwPhyAddr, uwRegAddr, uwVal);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 MAR1512_Read(UINT32 uwRegAddr, UINT32 uwPage, UINT32 *puwVal)
+{
+    UINT32 uwPort    = 0;
+    UINT32 uwPhyAddr = 0;
+    UINT32 uwRet;
+
+    uwRet = MAR1512_SelectPage(uwPort, uwPhyAddr, uwPage);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    uwRet = SRE_MdioRead(uwPort, uwPhyAddr, uwRegAddr, puwVal);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 MAR1512_Dump(UINT32 uwPage, UINT32 uwRegAddr)
+{
+    UINT32 uwVal;
+    UINT32 uwRet;
+
+    uwRet = MAR1512_Read(uwPage, uwRegAddr, &uwVal);
+    if (uwRet != OS_SUCCESS)
+    {
+        return uwRet;
+    }
+
+    SRE_printf("PAGE %#x REG %#x VALUE %#x\n", uwPage, uwRegAddr, uwVal);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_Init
+ Description  : Initial the phy module
+ Input        : UINT32 uwPhy
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/18
+    Author       : l100057
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_Init(UINT32 uwPhy )
+{
+    //UINT32 uwRegValue = 0;
+    //UINT32 uwRet;
+//    if (0 == g_ulMarPhyInitFlag)
+//    {
+//        if (0 == (g_ulMarPhyMutex = semMCreate(SEM_Q_FIFO | SEM_DELETE_SAFE)))
+//        {
+//            SRE_PHY_ERROR( "Error initilizing Phy Mutex!\n");
+//            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+//        }
+//    }
+//
+//    g_ulMarPhyInitFlag = 1;
+
+    if (OS_SUCCESS != MAR1512_PHY_Reset(uwPhy))
+    {
+        SRE_PHY_ERROR( "MAR1512_PHY_Init:Error reset Phy!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+	printk("MAR1512_PHY_Init uwphy : %d\n", uwPhy);
+
+    if (OS_SUCCESS != MAR1512_PHY_SelfTest(uwPhy))
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_Init:Error selftest Phy!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+#if 0
+    uwRet = MAR1512_ReadPhyReg(uwPhy, 21, 2,&uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_Init:Error MAR1512_ReadPhyReg!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    uwRegValue |= 1<<5;
+    uwRet = MAR1512_WritePhyReg(uwPhy,21, 2,uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_Init:Error MAR1512_WritePhyReg!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+#endif
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_WritePhyReg
+ Description  : 写寄存器
+ Input        : UINT32 uwPhy
+                UINT16 usRegAddr
+                UINT8 ucWindow
+                UINT32 ulFlag
+                UINT16 usWrData
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/17
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_ReadPhyReg( UINT32 uwPhy, UINT32 uwReg, UINT32 uwPage, UINT32 *puwValue)
+{
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+//    if (OS_SUCCESS != semTake(g_ulMarPhyMutex, WAIT_FOREVER))    /**/
+//    {
+//        SRE_PHY_ERROR("MAR1512_WritePhyReg: semTake ERROR!\n");
+//        goto erro_exit;
+//    }
+
+
+    if (OS_SUCCESS != SRE_MdioWrite(OS_MDIO_ID, uwPhy, MII_PAGE_ADDR_REG, uwPage&0xFF))
+    {
+        SRE_PHY_ERROR("[MAR_PHY_WRITE]phy_write() called return is fail at %x\n",uwReg);
+        goto erro_exit;
+    }
+
+   //printk("dingtianhong test param :%d,%d,%d,%p\n ", uwPhy, uwReg, uwPage, puwValue);
+
+    if (OS_SUCCESS != SRE_MdioRead(OS_MDIO_ID, uwPhy, uwReg & 0x1F, puwValue))
+    {
+        SRE_PHY_ERROR("[MAR_PHY_WRITE]phy_read() called return is fail at %x\n",uwReg);
+        goto erro_exit;
+    }
+
+//    semGive(g_ulMarPhyMutex);
+
+    return OS_SUCCESS;
+
+erro_exit:
+//    semGive(g_ulMarPhyMutex);
+
+    RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_WritePhyReg
+ Description  : 写寄存器
+ Input        : UINT32 uwPhy
+                UINT16 usRegAddr
+                UINT8 ucWindow
+                UINT32 ulFlag
+                UINT16 usWrData
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/17
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_WritePhyReg( UINT32 uwPhy, UINT32 uwReg, UINT32 uwPage, UINT32 uwValue)
+{
+
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+//    if (OS_SUCCESS != semTake(g_ulMarPhyMutex, WAIT_FOREVER))    /**/
+//    {
+//        SRE_PHY_ERROR("MAR1512_WritePhyReg: semTake ERROR!\n");
+//        goto erro_exit;
+//    }
+
+
+    if (OS_SUCCESS != SRE_MdioWrite(OS_MDIO_ID, uwPhy, MII_PAGE_ADDR_REG, uwPage&0xFF))
+    {
+        SRE_PHY_ERROR("[MAR_PHY_WRITE]phy_write() called return is fail at %x\n",MII_PAGE_ADDR_REG);
+        goto erro_exit;
+    }
+
+    if (OS_SUCCESS != SRE_MdioWrite(OS_MDIO_ID, uwPhy, uwReg & 0x1F, uwValue))
+    {
+        SRE_PHY_ERROR("[MAR_PHY_WRITE]phy_write() called return is fail at %x\n",uwReg);
+        goto erro_exit;
+    }
+
+//    semGive(g_ulMarPhyMutex);
+    return OS_SUCCESS;
+
+erro_exit:
+//    semGive(g_ulMarPhyMutex);
+
+    RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+}
+
+/*****************************************************************************
+ 函 数 名  : MAR1512_PHY_MAR5464_InterfaceSet
+ 功能描述  : 设置MAR1512 接口模式
+ 输入参数  : UINT32 uwPhy
+             MAR_PHY_INTERFACE_ENUM uwMode
+ 输出参数  : 无
+ 返 回 值  : UINT32
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2007年10月9日
+    作    者   : 罗健锋 100057
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_InterfaceSet( UINT32 uwPhy, MAR_PHY_INTERFACE_ENUM uwMode )
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+
+    switch (uwMode)
+    {
+        case SGMII_COPPER :
+            uwRet = MAR1512_ReadPhyReg(uwPhy,20, 18,&uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~0x7;
+            uwRegValue |= 0x1;
+            uwRegValue |= 1<<15;
+            uwRet = MAR1512_WritePhyReg(uwPhy,20, 18,uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            break;
+        case RGMII_COPPER :
+            uwRet = MAR1512_ReadPhyReg(uwPhy,20, 18,&uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~0x7;
+            uwRegValue |= (UINT32)uwMode & 7;
+            uwRet = MAR1512_WritePhyReg(uwPhy,20, 18,uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            break;
+        default:
+            SRE_PHY_ERROR("interfacemode is error\n");
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetPhyid
+ Description  : Get the chip's phyid
+ Input        : UINT32 uwPhy
+ Output       : None
+ Return Value : PHYID (UINT32)
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/10
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetPhyid (UINT32 uwPhy ,UINT32 *puwId)
+{
+    UINT32 uwIdLow = 0;
+    UINT32 uwIdHigh = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_PHY_ID0_REG, 0, &uwIdHigh);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_PHY_ID1_REG, 0, &uwIdLow);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    *puwId = ((uwIdHigh << 16) | uwIdLow);
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetChipVersion
+ Description  : Get the version of the phy chip
+ Input        : UINT32 uwPhy
+                UINT32 *puwChipVersion
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/10
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetChipVersion(UINT32 uwPhy,UINT32 *puwChipVersion)
+{
+    UINT32 uwId;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwChipVersion)
+    {
+        SRE_PHY_ERROR("NULL point\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_GetPhyid(uwPhy,&uwId);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 get phy id error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+
+    *puwChipVersion = uwId & 0xF;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_Reset
+ Description  : phy reset function
+ Input        : UINT32 uwPhy
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/10
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_Reset (UINT32 uwPhy)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg (uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRegValue |= 1<<15;/*复位*/
+    uwRet = MAR1512_WritePhyReg (uwPhy, MII_CTRL_REG, 0, uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    /* 延时至少1ms, 等待MII Control Register reset位变为0 */
+    //SRE_DelayMs(2);
+    SRE_PhyDelayUs(3000);
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_SelfTest
+ Description  : selftest for phy chip
+ Input        : UINT32 uwPhy
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/10
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_SelfTest(UINT32 uwPhy)
+{
+    UINT32 uwRet;
+    UINT32 uwId;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    printk("mdio addr is :%x, len is %x",MDIO_BASE_ADDR, MDIO_REG_ADDR_LEN);
+    uwRet = MAR1512_PHY_GetPhyid(uwPhy, &uwId);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("fail to read phy id\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    printk("uwid is %x\n", uwId);
+
+    if (MARVELL1512_ID != (uwId & 0xFFFFFF0))
+    {
+        SRE_PHY_ERROR("Phy id 0x%08x unmatch\n",uwId);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+	
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_SetAutoNeg
+ Description  : set auto negotiation,100FX do not have autonegotiation.
+ Input        : UINT32 uwPhy
+                UINT32 uwMaxspeed
+                UINT32 uwEnable
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_SetAutoNeg (UINT32 uwPhy, UINT32 uwMaxspeed, UINT32 uwEnable)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+
+    if (uwPhy > MAR_PHY_MAX_ADDR)
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (uwEnable > 1)
+    {
+        SRE_PHY_ERROR("Enable value is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (uwMaxspeed > PHY_SPEED_1000M)
+    {
+        SRE_PHY_ERROR("uwMaxspeed %d value is error\n",uwMaxspeed);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    uwRegValue &= ~(1<<12);
+    uwRegValue |= (uwEnable<<12);
+    uwRet = MAR1512_WritePhyReg(uwPhy, MII_CTRL_REG, 0, uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (1 == uwEnable)
+    {
+        if (PHY_SPEED_1000M == uwMaxspeed)
+        {
+            /*set 10&100M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_ANA_REG, 0, &uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue |= ( MII_ANA_FD_10 | MII_ANA_FD_100 | MII_ANA_PAUSE | MII_ANA_ASYM_PAUSE);
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_ANA_REG, 0, uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            /*set 1000M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_GB_CTRL_REG, 0, &uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue |= MII_GB_CTRL_ADV_1000FD;
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_GB_CTRL_REG, 0, uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+        }
+        else if (PHY_SPEED_100M == uwMaxspeed)
+        {
+            /*set 10&100M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_ANA_REG, 0, &uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue |= ( MII_ANA_FD_10 | MII_ANA_FD_100 | MII_ANA_PAUSE | MII_ANA_ASYM_PAUSE);
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_ANA_REG, 0,  uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+
+            /*set no 1000M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_GB_CTRL_REG, 0, &uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~MII_GB_CTRL_ADV_1000FD;
+            uwRegValue &= ~MII_GB_CTRL_ADV_1000HD;
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_GB_CTRL_REG, 0, uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+        }
+        else if (PHY_SPEED_10M == uwMaxspeed)
+        {
+            /*set no 1000M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_GB_CTRL_REG, 0, &uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~MII_GB_CTRL_ADV_1000FD;
+            uwRegValue &= ~MII_GB_CTRL_ADV_1000HD;
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_GB_CTRL_REG, 0, uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            /*set no 100M ,set  10M*/
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_ANA_REG, 0, &uwRegValue);
+            uwRegValue &= ~MII_ANA_HD_100;
+            uwRegValue &= ~MII_ANA_FD_100;
+            /*set  10M*/
+            uwRegValue |= ( MII_ANA_FD_10 | MII_ANA_PAUSE | MII_ANA_ASYM_PAUSE);
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_ANA_REG, 0, uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+        }
+
+        /*启动自协商*/
+        uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        uwRegValue |= (1 << 9);
+        uwRet = MAR1512_WritePhyReg(uwPhy, MII_CTRL_REG, 0, uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetAutoNeg
+ Description  : Get the autoneg mode and maxspeed
+ Input        : UINT32 uwPhy
+                UINT32 *puwMaxspeed  10(10M),100(100M),1000(1000M).
+                UINT32 *puwEnable    enable 1,disable 0.
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetAutoNeg (UINT32 uwPhy,UINT32 *puwMaxspeed, UINT32 *puwEnable)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwMaxspeed)
+    {
+        SRE_PHY_ERROR("NULL point of puwMaxspeed\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwEnable)
+    {
+        SRE_PHY_ERROR("NULL point of puwEnable\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    *puwEnable = (uwRegValue >> 12) & 0x1;
+
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_GB_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (uwRegValue & MII_GB_CTRL_ADV_1000FD)
+    {
+        *puwMaxspeed = PHY_SPEED_1000M;
+    }
+    else
+    {
+        uwRet = MAR1512_ReadPhyReg(uwPhy, MII_ANA_REG, 0, &uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        if (uwRegValue & MII_ANA_FD_100)
+        {
+            *puwMaxspeed = PHY_SPEED_100M;
+        }
+        else if (uwRegValue & MII_ANA_FD_10)
+        {
+            *puwMaxspeed = PHY_SPEED_10M;
+        }
+        else
+        {
+            SRE_PHY_ERROR("unknown phy negtiation\n");
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_SetSpeed
+ Description  : set the speed of lineinterface
+ Input        : UINT32 uwPhy
+                UINT32 ulSpeed  10(10M),100(100M),1000(1000M).
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_SetSpeed (UINT32 uwPhy, UINT32 ulSpeed)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    switch (ulSpeed)
+    {
+        case PHY_SPEED_10M:
+            uwRegValue &= ~MII_CTRL_SS_LSB;
+            uwRegValue &= ~MII_CTRL_SS_MSB;
+            break;
+        case PHY_SPEED_100M :
+            uwRegValue |= MII_CTRL_SS_LSB;
+            uwRegValue &= ~MII_CTRL_SS_MSB;
+            break;
+        case PHY_SPEED_1000M :
+            uwRegValue |= MII_CTRL_SS_MSB;
+            uwRegValue &= ~MII_CTRL_SS_LSB;
+            break;
+        default:
+            SRE_PHY_ERROR("mode error\n");
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_WritePhyReg(uwPhy, MII_CTRL_REG, 0, uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_Reset(uwPhy);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 reset error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetSpeed
+ Description  : get the speed configuration
+ Input        : UINT32 uwPhy
+                UINT32 *puwSpeed
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetSpeed (UINT32 uwPhy, UINT32 *puwSpeed)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwSpeed)
+    {
+        SRE_PHY_ERROR("NULL point\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    uwRegValue = (uwRegValue >> 13) & 0x1;
+    uwRegValue |= (uwRegValue >> 5) & 0x2;
+    switch (uwRegValue)
+    {
+        case 0 :
+            *puwSpeed = PHY_SPEED_10M;
+            break;
+        case 1 :
+            *puwSpeed = PHY_SPEED_100M;
+            break;
+        case 2 :
+            *puwSpeed = PHY_SPEED_1000M;
+            break;
+        default:
+            SRE_PHY_ERROR("error speed mode\n");
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_SetDuplex
+ Description  : set the lineinterface duplex
+ Input        : UINT32 uwPhy
+                UINT32 uwEnable
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_SetDuplex (UINT32 uwPhy,UINT32 uwEnable)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (uwEnable > 1)
+    {
+        SRE_PHY_ERROR("uwEnable is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    uwRegValue &= ~(1<<8);
+    uwRegValue |= uwEnable<<8;
+
+    uwRet = MAR1512_WritePhyReg(uwPhy,MII_CTRL_REG, 0, uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_Reset(uwPhy);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 reset error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetDuplex
+ Description  : get the configration of the duplex
+ Input        : UINT32 uwPhy
+                UINT32 *puwEnable  enable 1,disable 0.
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/11
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetDuplex (UINT32 uwPhy,UINT32 *puwEnable)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwEnable)
+    {
+        SRE_PHY_ERROR("null point!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    *puwEnable = (uwRegValue >> 8) & 0x1;
+
+    return OS_SUCCESS;
+}
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_QrySpeed
+ Description  :
+ Input        : None
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/9/4
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32  MAR1512_PHY_QrySpeed( UINT32 uwPhy,UINT32 *puwSpeed,UINT32 *puwDuplex)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwSpeed)
+    {
+        SRE_PHY_ERROR("null pointer!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy,MII_COPPER_SPEC_STATUS_1, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    //if (0 == (uwRegValue & (1<<11)))
+    //{
+    //    RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    //}
+
+    *puwSpeed = (uwRegValue >> 14) & 0x3;
+    *puwDuplex = (uwRegValue >> 13) & 0x1;
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_QryLinkStatus
+ Description  :
+ Input        : None
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/9/4
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32  MAR1512_PHY_QryLinkStatus( UINT32 uwPhy,UINT32 *puwStatus)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 uwRet;
+
+    if ( uwPhy > MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == puwStatus)
+    {
+        SRE_PHY_ERROR("null pointer!\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+
+    uwRet = MAR1512_ReadPhyReg(uwPhy, MII_COPPER_SPEC_STATUS_1, 0, &uwRegValue);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    *puwStatus = (uwRegValue & 1<<10)>>10;
+
+    return OS_SUCCESS;
+}
+
+UINT32 MAR1512_PHY_Show(UINT32 uwPhy)
+{
+    UINT32 uwId;
+    UINT32 uwChipVersion;
+    UINT32 uwMaxspeed;
+    UINT32 uwEnable;
+    UINT32 uwSpeed;
+    UINT32 uwDuplex;
+    UINT32 uwLinkStatus;
+
+    UINT32 uwRet;
+    UINT32 uwMdioId;
+
+    uwMdioId = OS_MDIO_ID;
+
+    SRE_printf(" ==== mdio %d phy %d ==== \n",uwMdioId,uwPhy);
+
+    SRE_printf(" ==== chip info ==== \n");
+    uwRet = MAR1512_PHY_GetPhyid (uwPhy ,&uwId);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 GetPhyid error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    SRE_printf("chip id = 0x%x\n",uwId);
+
+    uwRet = MAR1512_PHY_GetChipVersion (uwPhy ,&uwChipVersion);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 GetChipVersion error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    SRE_printf("chip version = 0x%x\n",uwChipVersion);
+
+    SRE_printf(" ==== AutoNeg ==== \n");
+    uwRet = MAR1512_PHY_GetAutoNeg (uwPhy ,&uwMaxspeed, &uwEnable);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 GetAutoNeg error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    SRE_printf("uwMaxspeed = 0x%x\n",uwMaxspeed);
+    SRE_printf("AutoNeg enable = 0x%x\n",uwEnable);
+
+    SRE_printf(" ==== currunt speed &duplex ==== \n");
+    uwRet = MAR1512_PHY_QrySpeed (uwPhy ,&uwSpeed, &uwDuplex);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 QrySpeed error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    SRE_printf("speed = 0x%x\n",uwSpeed);
+    SRE_printf("uwDuplex = 0x%x\n",uwDuplex);
+
+    SRE_printf(" ==== uwLinkStatus  ==== \n");
+    uwRet = MAR1512_PHY_QryLinkStatus (uwPhy ,&uwLinkStatus);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR("[%s %d]:MAR1512 QryLinkStatus error!\n",__FUNCTION__, __LINE__);
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    SRE_printf("uwLinkStatus = 0x%x\n",uwLinkStatus);
+    SRE_printf("======================\n");
+    return OS_SUCCESS;
+}
+
+UINT32 gaulPageReg[40];
+
+UINT32 MAR1512_PHY_PAGE_DUMP(void)
+{
+    UINT32 uwPhy =0;
+    UINT32 uwRet;
+    UINT32 uwPage = 0;
+    UINT32 uwTimeOut = 10000;
+    UINT32 uwLinkStatus;
+
+    UINT32 uwRegIndex = 0;
+
+    while((uwTimeOut > 0)&&(uwRegIndex<=26))
+    {
+        uwRet = MAR1512_PHY_QryLinkStatus (uwPhy ,&uwLinkStatus);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR("[%s %d]:MAR1512 QryLinkStatus error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        if(0 == uwLinkStatus)
+        {
+            MAR1512_ReadPhyReg(0,uwRegIndex,uwPage,&gaulPageReg[uwRegIndex]);
+            uwRegIndex++;
+        }
+        uwTimeOut--;
+    }
+
+    SRE_printf("uwRegIndexd =%d\n",uwRegIndex);
+    SRE_printf("uwTimeOut =%d\n",uwTimeOut);
+
+    return OS_SUCCESS;
+}
+UINT32 MAR1512_PHY_PAGE_CLEAN(void)
+{
+    UINT32 i;
+    for(i = 0;i<30;i++)
+    {
+        gaulPageReg[i] = 0;
+    }
+    return OS_SUCCESS;
+}
+UINT32 MAR1512_PHY_PAGE_SHOW(void)
+{
+    UINT32 i;
+    for(i = 0;i<30;i++)
+    {
+        SRE_printf("reg %d = 0x%x\n",i,gaulPageReg[i]);
+    }
+    return OS_SUCCESS;
+}
+UINT32 MAR1512_PHY_PAGE_SHOW_NULL(void)
+{
+    //UINT32 i;
+    return OS_SUCCESS;
+}
+
+
+#if 0
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_SetLoop
+ Description  : set loopmode ,linkside and macside
+                    In the 1000baseX link side loopmode the auto-negotiation must be off
+ Input        : UINT32 uwPhy
+                UINT32 uwMode
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/16
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_SetLoop (UINT32 uwPhy,PHY_LOOP_E uwMode)
+{
+    UINT32 uwRegValue = 0;
+    UINT32 ulLink = 0;
+    UINT32 uwRet;
+    UINT32 ulSpeed = 0;
+    UINT32 ulDuplex = 0;
+    PHY_LOOP_E enLoopState = PHY_LOOP_MODE_OFF;
+    if (uwPhy >= PHY_MAX_ADDR)
+    {
+        SRE_PHY_ERROR("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (uwMode > PHY_LOOP_MODE_LINE)
+    {
+        SRE_PHY_ERROR("uwMode is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_GetLoop(uwPhy, &enLoopState);
+    if (OS_SUCCESS != uwRet)
+    {
+        SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 get loop error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+    if (PHY_LOOP_MODE_OFF == enLoopState)
+    {
+        if (PHY_LOOP_MODE_OFF == uwMode)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_INFO, \
+                    "[%s %d]:MAR1512 loop already off!\n",__FUNCTION__, __LINE__);
+            return OS_SUCCESS;
+        }
+    }
+    else
+    {
+        if (PHY_LOOP_MODE_OFF != uwMode)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_INFO, \
+                    "[%s %d]:MAR1512 already in loop  %d!\n",__FUNCTION__, __LINE__,(UINT32)enLoopState,0);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+    if (PHY_LOOP_MODE_OFF == uwMode)
+    {
+        if (PHY_LOOP_MODE_LINE == enLoopState)
+        {
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_MAC_SPEC_CTRL_2, 2,&uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~(1<<14);/*关闭 LINE LOOP*/
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_MAC_SPEC_CTRL_2, 2,uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+        }
+        else/*PHY_LOOP_MODE_SYS*/
+        {
+
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0,&uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~(1<<14); /*关闭 SYS LOOP*/
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_CTRL_REG, 0,uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+
+            uwRet = MAR1512_ReadPhyReg(uwPhy, MII_COPPER_SPEC_CTRL_1, 0,&uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRegValue &= ~(1<<10); /*关闭强制LINK UP*/
+            uwRet = MAR1512_WritePhyReg(uwPhy, MII_COPPER_SPEC_CTRL_1, 0,uwRegValue);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+            uwRet = MAR1512_PHY_GetAutoNeg(uwPhy, &g_ulMarPhyAutoNegSpeedBeforeLoop[uwPhy], &g_ulMarPhyAutoNegStateBeforeLoop[uwPhy]);
+            if (OS_SUCCESS != uwRet)
+            {
+                SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                    "[%s %d]:MAR1512 get auto neg error!\n",__FUNCTION__, __LINE__);
+                RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+            }
+        }
+    }
+    else if (PHY_LOOP_MODE_LINE == uwMode)
+    {
+        uwRet = MAR1512_PHY_QryLinkStatus(uwPhy, &ulLink);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 QryLinkStatus error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        if (PHY_LINK_UP != ulLink)
+        {
+            SRE_PHY_ERROR("ERROR to set line loop,link is down!\n");
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        uwRet = MAR1512_ReadPhyReg(uwPhy, MII_MAC_SPEC_CTRL_2, 2, &uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        uwRegValue |= (1<<14);/*LINE LOOP*/
+        uwRet = MAR1512_WritePhyReg(uwPhy, MII_MAC_SPEC_CTRL_2, 2, uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR(TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+    else /*PHY_LOOP_MODE_SYS*/
+    {
+        uwRet = MAR1512_PHY_GetAutoNeg(uwPhy, &g_ulMarPhyAutoNegSpeedBeforeLoop[uwPhy], &g_ulMarPhyAutoNegStateBeforeLoop[uwPhy]);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 get auto neg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        /*获取当前速度*/
+        uwRet = MAR1512_PHY_QrySpeed(uwPhy, &ulSpeed, &ulDuplex);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 qry speed error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        /*关闭自协商*/
+        uwRet = MAR1512_PHY_SetAutoNeg(uwPhy, ulSpeed, 0);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 set auto neg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        /*设置速度*/
+        uwRet = MAR1512_PHY_SetSpeed(uwPhy, ulSpeed);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 set speed error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        /*设置全双工*/
+        uwRet = MAR1512_PHY_SetDuplex(uwPhy, PHY_DUPLEX_FULL);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 set duplex error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+
+        uwRet = MAR1512_ReadPhyReg(uwPhy, MII_COPPER_SPEC_CTRL_1, 0,&uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        uwRegValue |= (1<<10); /*强制LINK UP*/
+        uwRet = MAR1512_WritePhyReg(uwPhy, MII_COPPER_SPEC_CTRL_1, 0,uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+
+        uwRet = MAR1512_ReadPhyReg(uwPhy, MII_CTRL_REG, 0,&uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 read reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+        uwRegValue |= (1<<14);/*SYS LOOP*/
+        uwRet = MAR1512_WritePhyReg(uwPhy, MII_CTRL_REG, 0,uwRegValue);
+        if (OS_SUCCESS != uwRet)
+        {
+            SRE_PHY_ERROR (TRANDRV_ETH_CODEBASE, g_lFeModuId, OUTPUT_LEVEL_ERROR, \
+                "[%s %d]:MAR1512 write reg error!\n",__FUNCTION__, __LINE__);
+            RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+        }
+    }
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************************
+ Prototype    : MAR1512_PHY_GetLoop
+ Description  : get loopback mode
+ Input        : UINT32 uwPhy
+                UINT32 *puwMode
+ Output       : None
+ Return Value :
+ Calls        :
+ Called By    :
+
+  History        :
+  1.Date         : 2007/7/16
+    Author       : T56444
+    Modification : Created function
+
+*****************************************************************************/
+UINT32 MAR1512_PHY_GetLoop (UINT32 uwPhy,PHY_LOOP_E *pulLoop)
+{
+    if ( uwPhy >= MAR_PHY_MAX_ADDR )
+    {
+        SRE_PHY_ERROR ("uwPhy is error\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    if (NULL == pulLoop)
+    {
+        SRE_PHY_ERROR ("puwMode is NULL\n");
+        RETURN_ERROR(__LINE__, OS_FAIL, 0, 0);
+    }
+
+    *pulLoop = (PHY_LOOP_E)g_ulMarPhyLoopState[uwPhy];
+    return OS_SUCCESS;
+}
+#endif
+
+UINT32 SRE_StdPhySet(UINT32 uwPort)
+{
+    UINT32 uwRet;
+    UINT32 uwPhy  = uwPort;
+
+    //wuyin 的镜像通过如此命令，在fpga 上 1000m link up
+    //SreShell 0 "MAR1512_PHY_Init 0"
+    //SreShell 0 "MAR1512_PHY_InterfaceSet 0,0"
+    //SreShell 0 "MAR1512_Write 21,2,0x5076"
+
+    /* 配置PHY */
+    uwRet = MAR1512_PHY_Init(uwPhy);
+    if (uwRet !=  OS_SUCCESS)
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_Init fail\n");
+        RETURN_ERROR(__LINE__, uwRet, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_InterfaceSet(uwPhy, SGMII_COPPER);
+    if (uwRet !=  OS_SUCCESS)
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_InterfaceSet fail\n");
+        RETURN_ERROR(__LINE__, uwRet, 0, 0);
+    }
+
+    uwRet = MAR1512_PHY_SetAutoNeg(uwPhy, PHY_SPEED_1000M, PHY_AUTONEG_ENABLE);
+    if (uwRet !=  OS_SUCCESS)
+    {
+        SRE_PHY_ERROR("MAR1512_PHY_SetAutoNeg fail\n");
+        RETURN_ERROR(__LINE__, uwRet, 0, 0);
+    }
+
+    return OS_SUCCESS;
+}
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif
+
diff --git a/drivers/misc/serdes/SRE_phydrv.h b/drivers/misc/serdes/SRE_phydrv.h
new file mode 100644
index 0000000..9523d4c
--- /dev/null
+++ b/drivers/misc/serdes/SRE_phydrv.h
@@ -0,0 +1,201 @@
+/******************************************************************************
+
+                  版权所有 (C), 2001-2011, 华为技术有限公司
+
+ ******************************************************************************
+  文 件 名   : SRE_phydrv.inc
+  版 本 号   : 初稿
+  作    者   : w00146306
+  生成日期   : 2010年10月28日
+  最近修改   :
+  功能描述   : SRE PHY驱动模块 头文件
+  函数列表   :
+  修改历史   :
+  1.日    期   : 2010年10月28日
+    作    者   : w00146306
+    修改内容   : 创建文件
+
+******************************************************************************/
+#ifndef _SRE_PHYDRV_INC
+#define _SRE_PHYDRV_INC
+
+#include "SRE_drv.h"
+//#include "SRE_ge.h"
+#include "SRE_memmap.h"
+//#include "ge/SRE_ge.inc"
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+/*----------------------------------------------*
+ * 外部变量说明                                 *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 外部函数原型说明                             *
+ *----------------------------------------------*/
+UINT32 SRE_StdPhySet(UINT32 uwPort);
+/*----------------------------------------------*
+ * 宏定义                                       *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 内部函数原型说明                             *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 全局变量                                     *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 模块级变量                                   *
+ *----------------------------------------------*/
+
+/*----------------------------------------------*
+ * 常量定义                                     *
+ *----------------------------------------------*/
+#define SRE_PHY_ERROR(fmt, arg...)   OS_DBG_PRINT(fmt, ##arg) //OS_DBG_PRINT(fmt, ##arg)//SRE_printf(fmt, arg...)
+
+#define MARVELL1512_ID  0x01410dd0
+
+#define SRE_MDIO_REG_ADDR_LEN    0x10000
+
+#define SRE_MDIO_PHY_GRP_LEN       0x100
+#define SRE_MDIO_REG_LEN       0x10
+
+/* 表示的是clause 22  */
+#define MDIO_ST_CLAUSE_22           (0x01)
+
+/* 定义MDIO clause 22的操作  */
+#define MDIO_CLAUSE_22_READ         (0x02)
+#define MDIO_CLAUSE_22_WRITE        (0x01)
+
+#define MDIO_REG_ADDR_LEN            0x1000
+#define MDIO_PHY_GRP_LEN             0x100
+#define MDIO_REG_LEN                 0x10
+#define MDIO_PHY_ADDR_NUM            5
+#define MDIO_MAX_PHY_ADDR            0x1F   /* 每个clause 22 MDIO下面最多只有32个PHY  */
+#define MDIO_MAX_PHY_REG_ADDR        0x1F   /* Clause45 MDIO支持的PHY寄存器偏移地址最多只到0x1F  */
+
+#define MDIO_REG_ADDR(port, offset)      (MDIO_BASE_ADDR + (port) * MDIO_REG_ADDR_LEN + (offset))
+
+#define MDIO_REG_READ(port,offset,data)  \
+        ( (data) = OS_READ_REG(MDIO_REG_ADDR(port, offset), 0))
+
+#define MDIO_REG_WRITE(port,offset,data)  \
+        (OS_WRITE_REG(MDIO_REG_ADDR(port, offset), 0, data))
+
+
+
+#define MAR_PHY_MAX_ADDR 0x1F
+
+#define PHY_SPEED_10M        0
+#define PHY_SPEED_100M       1
+#define PHY_SPEED_1000M      2
+
+#define PHY_LINK_UNKNOW      2
+#define PHY_LINK             1
+#define PHY_UNLINK           0
+#define PHY_LOOP             1
+#define PHY_UNLOOP           0
+
+#define PHY_AUTONEG_ENABLE   1
+#define PHY_AUTONEG_DISABLE  0
+
+
+/* Standard MII Registers */
+#define MII_CTRL_REG            0x00    /* MII Control Register : r/w */
+#define MII_STAT_REG            0x01    /* MII Status Register: ro */
+#define MII_PHY_ID0_REG         0x02    /* MII PHY ID register: r/w */
+#define MII_PHY_ID1_REG         0x03    /* MII PHY ID register: r/w */
+#define MII_ANA_REG             0x04    /* MII Auto-Neg Advertisement: r/w */
+#define MII_ANP_REG             0x05    /* MII Auto-Neg Link Partner: ro */
+#define MII_AN_EXP_REG          0x06    /* MII Auto-Neg Expansion: ro */
+#define MII_GB_CTRL_REG         0x09    /* MII 1000Base-T control register */
+#define MII_GB_STAT_REG         0x0a    /* MII 1000Base-T Status register */
+#define MII_SGB_CTRL_REG        0x0b    /* SGMII/1000-X Control Register */
+#define MII_ESR_REG             0x0f    /* MII Extended Status register */
+
+/* Non-standard MII Registers */
+
+/*page any*/
+#define MII_PAGE_ADDR_REG          0x16
+
+/*page 0*/
+#define MII_COPPER_SPEC_CTRL_1     0x10
+#define MII_COPPER_SPEC_STATUS_1   0x11
+
+/*page 2*/
+#define MII_MAC_SPEC_CTRL_2        0x15
+
+/* MII Control Register: bit definitions */
+
+#define MII_CTRL_SS_MSB         (1 << 6)  /* Speed select, MSb */
+#define MII_CTRL_CST            (1 << 7)  /* Collision Signal test */
+#define MII_CTRL_FD             (1 << 8)  /* Full Duplex */
+#define MII_CTRL_RAN            (1 << 9)  /* Restart Autonegotiation */
+#define MII_CTRL_IP             (1 << 10) /* Isolate Phy */
+#define MII_CTRL_PD             (1 << 11) /* Power Down */
+#define MII_CTRL_AE             (1 << 12) /* Autonegotiation enable */
+#define MII_CTRL_SS_LSB         (1 << 13) /* Speed select, LSb */
+#define MII_CTRL_LE             (1 << 14) /* Loopback enable */
+#define MII_CTRL_RESET          (1 << 15) /* PHY reset */
+
+/*
+ * MII Link Advertisment
+ */
+#define MII_ANA_ASF             (1 << 0)  /* Advertise Selector Field */
+#define MII_ANA_HD_10           (1 << 5)  /* Half duplex 10Mb/s supported */
+#define MII_ANA_FD_10           (1 << 6)  /* Full duplex 10Mb/s supported */
+#define MII_ANA_HD_100          (1 << 7)  /* Half duplex 100Mb/s supported */
+#define MII_ANA_FD_100          (1 << 8)  /* Full duplex 100Mb/s supported */
+#define MII_ANA_T4              (1 << 9)  /* T4 */
+#define MII_ANA_PAUSE           (1 << 10) /* Pause supported */
+#define MII_ANA_ASYM_PAUSE      (1 << 11) /* Asymmetric pause supported */
+#define MII_ANA_RF              (1 << 13) /* Remote fault */
+#define MII_ANA_NP              (1 << 15) /* Next Page */
+
+/*
+ * 1000Base-T Control Register
+ */
+#define MII_GB_CTRL_ADV_1000FD  (1 << 9)  /* Advertise 1000Base-T FD */
+#define MII_GB_CTRL_ADV_1000HD  (1 << 8)  /* Advertise 1000Base-T HD */
+
+
+typedef enum MAR_PHY_INTERFACE
+{
+    SGMII_COPPER = 0,
+    RGMII_COPPER,
+    RTBI_COPPER,
+    RGMII_FIBER,
+    RTBI_FIBER,
+    SGMII_100BASE_FX = 5,
+    RGMII_100BASE_FX,
+    GBIC/*fiber to copper*/
+}MAR_PHY_INTERFACE_ENUM;
+
+typedef enum PHY_LOOPMODE
+{
+    PHY_LOOP_MODE_OFF = 0,      /*链路无环回*/
+    PHY_LOOP_MODE_LINE,         /*链路线路环回*/
+    PHY_LOOP_MODE_SYS,          /*链路系统环回*/
+    PHY_LOOP_MODE_UNKNOWN       /*未知的链路环回模式*/
+}PHY_LOOPMODE_ENUM;
+
+
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* _SRE_PHYDRV_INC */
+
+
+
+
diff --git a/drivers/misc/serdes/SRE_rawmutex.h b/drivers/misc/serdes/SRE_rawmutex.h
new file mode 100644
index 0000000..29c9135
--- /dev/null
+++ b/drivers/misc/serdes/SRE_rawmutex.h
@@ -0,0 +1,373 @@
+
+ /******************************************************************************
+  文 件 名   : sre_rawmutex.h
+  版 本 号   : 初稿
+  作    者   : z00202155
+  生成日期   : 2012年1月11日
+  最近修改   :
+  功能描述   : SRESS 原生互斥体管理 模块 API
+  函数列表   :
+  修改历史   :
+  1.日    期   : 2012年1月11日
+    作    者   : z00202155
+    修改内容   : 创建文件
+
+******************************************************************************/
+
+#ifndef __SRE_RAWMUTEX_H__
+#define __SRE_RAWMUTEX_H__
+
+//#include "SRE_drv.h"
+
+
+#ifdef __cplusplus
+#if __cplusplus
+extern "C"{
+#endif
+#endif /* __cplusplus */
+
+
+/*
+ * 本模块错误码定义
+ */
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：原生互斥体最大参数输入错误
+ * 值: 0x02003100
+ * 解决方法: 调用SRE_InitRawMutex函数时，确保uwMaxItem参数正确
+ */
+#define OS_ERRNO_RAWMUTEX_MaxItem_ERR                   SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x00)
+
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：锁入队失败
+ * 值: 0x02003101
+ * 解决方法: 检查函数参数输入
+ */
+#define OS_ERRNO_RAWMUTEX_DESCPUSH_ERR                   SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x01)
+
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：出队失败
+ * 值: 0x02003102
+ * 解决方法: 检查函数参数输入
+ */
+#define OS_ERRNO_RAWMUTEX_DescPop_ERR                   SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x02)
+
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：输入原生互斥体序号不合法
+ * 值: 0x02003103
+ * 解决方法: 检查函数参数输入
+ */
+#define OS_ERRNO_RAWMUTEX_INDEX_ERR                   SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x03)
+
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：输入原生互斥体配置结构体指针为空
+ * 值: 0x02003104
+ * 解决方法: 检查函数参数输入
+ */
+#define OS_ERRNO_RAWMUTEX_PTRNULL_ERR                   SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x04)
+
+/**
+ * @ingroup SRE_RawMutex
+ * 日志错误码：原生互斥体初始化清空队列失败
+ * 值: 0x02003105
+ * 解决方法:
+ */
+#define OS_ERRNO_RAWMUTEX_EMPTYQUE_FAIL_ERROR            SRE_ERRNO_OS_ERROR(OS_MID_RAWMUTEX, 0x05)
+
+
+/* 原生互斥体结构 */
+typedef struct tagMcRawMutex
+{
+    volatile UINT32 stRawSpin;      /* 原生自旋锁的值 */
+    volatile UINT32 uwFlag;         /* 初始化完成标志 */
+} SRE_RAWMUTEX_S;
+
+/* 需要申请使用一个原生锁的时候，就在这里添加一个宏定义就可以了，*/
+/* 使用的时候用这个宏定义的数值作为数组的下标作索引就好了。*/
+typedef enum tagRawMutexId
+{
+    MOD_TBL_INITSAFE_LOCK_SYS_1,                /* 0 */
+    MOD_TBL_INITSAFE_LOCK_SYS_2,
+    MOD_REGISTER_INITSAFE_LOCK,
+    MEM_POOL_HW_INIT_LOCK,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL0,
+
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL1,             /* 5 */
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL2,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL3,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL4,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL5,
+
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL6,             /* 10 */
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL7,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL8,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL9,
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL10,
+
+    BLOCK_MEM_HEAD_INIT_LOCK_POOL11,            /* 15 */
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL0,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL1,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL2,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL3,
+
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL4,         /* 20 */
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL5,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL6,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL7,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL8,
+
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL9,         /* 25 */
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL10,
+    BLOCK_MEM_PUB_POOL_INIT_LOCK_POOL11,
+    BYTE_MEM_MONITOR_STRUCT_INIT_LOCK,
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL0,
+
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL1,  /* 30 */
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL2,
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL3,
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL4,
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL5,
+
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL6,  /* 35 */
+    PUB_BYTE_MEM_ADMIN_STRUCT_INIT_LOCK_POOL7,
+    SPINLOCK_INIT_LOCK,
+    SPINLOCK_INIT_LOCK_SYS_1,
+    SPINLOCK_INIT_LOCK_SYS_2,
+
+    NETWORK_PORT_INIT_LOCK,                     /* 40 */
+    NETWORK_PORT_INIT_LOCK_1,
+    NETWORK_PORT_INIT_LOCK_2,
+    SRE_FAU_INITSAFE_LOCK,
+    SRE_LOCAL_MEMEORY_INITSAFE_LOCK,
+
+    SRE_SYSLOG_INITSAFE_LOCK,                    /* 45 */
+    SRE_TIMER_INITSAFE_LOCK,
+    SRE_CRC_INITSAFE_LOCK,
+    SRE_CACHE_INITSAFE_LOCK,
+    SRE_CLUSTER0_CACHE_INITSAFE_LOCK,
+
+    SRE_CLUSTER1_CACHE_INITSAFE_LOCK,            /* 50 */
+    SRE_TIMEBASE_INITSAFE_LOCK,
+    SRE_POEINIT_INITSAFE_LOCK,
+    SRE_GIC_INITSAFE_LOCK,
+    SRE_BLACKBOX_INITSAFE_LOCK,
+
+    SRE_POETEST_INITSAFE_LOCK,                   /* 55 */
+    SRE_QMUINIT_INITSAFE_LOCK,
+    SRE_QMUTEST_INITSAFE_LOCK,
+    SRE_SYSSNAP_INITSAFE_LOCK,
+    SRE_STAT_INITSAFE_LOCK,
+
+    SRE_HDCP_INITSAFE_LOCK,                      /* 60 */
+    SRE_SYSCTL_INITSAFE_LOCK,
+    SRE_BLKMEM_ALARM_INITSAFE_LOCK,
+    SRE_BLKBOX_INITSAFE_LOCK,
+    SRE_TIMER_INIT_LOCK_CLUSTER_A,
+
+    SRE_TIMER_INIT_LOCK_CLUSTER_B,               /* 65 */
+    SRE_DWTH_INITSAFE_LOCK,
+    SRE_BLOG_INIT_LOCK,
+    SRE_DMA_INIT_LOCK,
+    SRE_DYNAMIC_INITSAGE_LOCK,
+
+    SRE_TIMER_HW_INITSAFE_LOCK,                  /* 70 */
+    SRE_GMAC_ENABLE_ALL_INITSAFE_LOCK,
+    SRE_GDB_INITSAFE_LOCK,
+    SRE_QTIMER_INITSAFE_LOCK_CLUSTER_A,
+    SRE_QTIMER_INITSAFE_LOCK_CLUSTER_B,
+
+    SRE_DMA_INITSAFE_LOCK,                       /* 75 */
+    SRE_HWTIMER_INITSAFE_A_LOCK,
+    SRE_HWTIMER_INITSAFE_B_LOCK,
+    SRE_SEC_INITSAFE_LOCK,
+    SRE_ROHC_INITSAFE_LOCK,
+
+    SRE_POU_INIT_LOCK,                          /* 80 */
+    SRE_CLUSTER0_MF_INITSAFE_LOCK,
+    SRE_CLUSTER1_MF_INITSAFE_LOCK,
+    SRE_CPU_STATUS_RESET_LOCK,
+    SRE_CPU_RATE_INIT_LOCK,
+
+    SRE_CPU_HEARTBEAT_INIT_LOCK,                /* 85 */
+    SRE_PRINT_INIT_LOCK,
+    SRE_BLKMEM_SNAP_INIT_LOCK,
+    SRE_NETDRV_SNAP_INIT_LOCK,
+    SRE_SPINLOCK_SNAP_INIT_LOCK,
+
+    SRE_BMU_SETUPPOOL_LOCK,                       /* 90 */
+    SRE_TM_INITSAFE_LOCK,
+    SRE_SCH_INITSAFE_LOCK,
+    SRE_DLHDCP_INITSAFE_LOCK,
+	SRE_AQM_INITSAFE_LOCK,
+
+    SRE_ULHDCP_INITSAFE_LOCK,                   /* 95 */
+/* BEGIN: Added by wangming 2012/11/14 */
+    SRE_BPSS_INITSAFE_LOCK,
+    SRE_MACE_INITSAFE_LOCK,
+    SRE_FP_INITSAFE_LOCK,
+    SRE_PDM_INITSAFE_LOCK,
+    SRE_PMM_INITSAFE_LOCK,
+    SRE_SORT_INITSAFE_LOCK,
+    SRE_JSPCPF_INITSAFE_LOCK,
+    SRE_JSPCPC_INITSAFE_LOCK,
+    SRE_VMIMO_INITSAFE_LOCK,
+    SRE_RESM_INITSAFE_LOCK,
+    SRE_CQI_INITSAFE_LOCK,
+    SRE_DRX_INITSAFE_LOCK,
+    SRE_TRACE_INITSAFE_LOCK,
+    SRE_PDCFG_INITSAFE_LOCK,
+    SRE_BDM_INITSAFE_LOCK,
+    SRE_SERDES_INITSAFE_LOCK,
+    SRE_SPI_INITSAFE_LOCK,
+    SRE_SPPEINIT_INITSAFE_LOCK,
+    SRE_TSINIT_INITSAFE_LOCK,
+    SRE_MPE_INITSAFE_LOCK,                  /*115 */
+
+/* END: Added by wangming 2012/11/14 */
+    /* MAX_RAWMUTEX_LOCK_NUMBER 必须放在最后，作为整个枚举变量个数的统计 */
+    MAX_RAWMUTEX_LOCK_NUMBER = 128
+
+}SRE_RAWMUTEX_ID_ENUM;
+
+/*原生互斥体配置结构体*/
+typedef struct tagMcRawMutexHwQueueCfg
+{
+    void *pBaseMem;     /* 管理内存基址 */
+    UINT32 ulMaxItem;  /* 管理最大索引 */
+} SRE_RAWMUTEX_HW_QUEUE_CFG_S;
+
+#if 0
+/*
+* 对外接口函数
+*/
+/*****************************************************************************
+ 函 数 名  : SRE_RawMutexRegister
+ 功能描述  : RawMutex模块配置注册函数
+ 输入参数  : SRE_RAWMUTEX_HW_QUEUE_CFG_S *stRawMutesQueCfg
+ 输出参数  :
+ 返 回 值  : OS_SUCCESS 成功
+             其他 失败
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年1月11日
+    作    者   : z00202155
+    修改内容   : 新生成函数
+*****************************************************************************/
+extern UINT32 SRE_RawMutexRegister(SRE_RAWMUTEX_HW_QUEUE_CFG_S *stRawMutesQueCfg);
+
+/*****************************************************************************
+ 函 数 名  : SRE_InitRawMutex
+ 功能描述  : RawMutex模块配置初始化
+ 输入参数  : 无
+ 输出参数  : 无
+ 返 回 值  : OS_SUCCESS 成功
+             其他 失败
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2011年1月11日
+    作    者   : z00202155
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+extern UINT32 SRE_InitRawMutex(void);
+#endif
+/*****************************************************************************
+ 函 数 名  : SRE_RawMutexProtect
+ 功能描述  : 获取原生互斥体保护
+ 输入参数  : UINT32 uwRawMutexIndex
+ 输出参数  : 无
+ 返 回 值  : OS_SUCCESS 成功
+             其他 失败
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年1月11日
+    作    者   : z00202155
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+//extern UINT32 SRE_RawMutexProtect(UINT32 uwRawMutexIndex);
+#define SRE_RawMutexProtect(uwRawMutexIndex) 0  /* 以下定义仅用于规避对SRE原有代码的修改，无实际意义 */
+
+/*****************************************************************************
+ 函 数 名  : SRE_RawMutexUnProtect
+ 功能描述  : 释放原生互斥体保护
+ 输入参数  : UINT32 uwRawMutexIndex
+ 输出参数  : 无
+ 返 回 值  : OS_SUCCESS 成功
+             其他 失败
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年1月11日
+    作    者   : z00202155
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+//extern UINT32 SRE_RawMutexUnProtect(UINT32 uwRawMutexIndex);
+#define SRE_RawMutexUnProtect(uwRawMutexIndex) 0    /* 以下定义仅用于规避对SRE原有代码的修改，无实际意义 */
+
+/*****************************************************************************
+ 函 数 名  : SRE_RawMutexSetFlag
+ 功能描述  : 设置原生互斥体初始化完成标志
+ 输入参数  : UINT32 uwRawMutexIndex
+ 输出参数  : 无
+ 返 回 值  : OS_SUCCESS 成功
+             其他 失败
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史      :
+  1.日    期   : 2012年1月11日
+    作    者   : z00202155
+    修改内容   : 新生成函数
+
+*****************************************************************************/
+//extern UINT32 SRE_RawMutexSetFlag(UINT32 uwRawMutexIndex);
+#define SRE_RawMutexSetFlag(uwRawMutexIndex) 0  /* 以下定义仅用于规避对SRE原有代码的修改，无实际意义 */
+
+/*****************************************************************************
+ 函 数 名  : SRE_RawMutexGetFlag
+ 功能描述  : 获取原生互斥体初始化完成标志
+ 输入参数  : UINT32 uwRawMutexIndex
+ 输出参数  : 无
+ 返 回 值  : 0 -- 互斥体未使用
+             1 -- 互斥体已使用
+ 调用函数  :
+ 被调函数  :
+
+ 修改历史  :
+   1.日    期   : 2012年1月11日
+     作    者   : z00202155
+     修改内容   : 新生成函数
+
+
+*****************************************************************************/
+//extern UINT32 SRE_RawMutexGetFlag(UINT32 uwRawMutexIndex);
+#define SRE_RawMutexGetFlag(uwRawMutexIndex) 0  /* 以下定义仅用于规避对SRE原有代码的修改，无实际意义 */
+
+#define SRE_RawMutexClearFlag(uwRawMutexIndex) 0    /* 以下定义仅用于规避对SRE原有代码的修改，无实际意义 */
+
+#if 0
+/* 本模块编译宏,在极度追求效率的情形下可去掉 */
+#define SRE_RAWMUTEX_CHECK
+#endif
+
+#ifdef __cplusplus
+#if __cplusplus
+}
+#endif
+#endif /* __cplusplus */
+
+
+#endif /* __SRE_RAWMUTEX_H__ */
diff --git a/drivers/misc/serdes/SRE_serdes.c b/drivers/misc/serdes/SRE_serdes.c
new file mode 100644
index 0000000..28554c3
--- /dev/null
+++ b/drivers/misc/serdes/SRE_serdes.c
@@ -0,0 +1,10568 @@
+/*******************************************************************
+              Copyright 2007 - 2011, Huawei Tech. Co., Ltd.
+                      ALL RIGHTS RESERVED
+
+Filename      : SRE_serdes.c
+Author        : z00228490
+Creation time : 2012/12/27
+Description   :
+                    serdes 驱动
+Version       : 1.0
+********************************************************************/
+
+#include "SRE_serdes.h"
+#include "SRE_rawmutex.h"
+#include "SRE_memmap.h"
+
+
+/*基地址包含文件定义。*/
+#define SYSCTRL_BASE_ADDR                 SRE_SYS_REG_BASEADDR
+
+extern UINT32 osSerdes0InitGe1g25(void);
+extern UINT32 osSerdes0InitGe1g25Xaui3g125(void);
+extern UINT32 osSerdes0InitGe1g25Xge10g125(void);
+extern UINT32 osSerdes1InitGe1G25Srio1g25(void);
+extern UINT32 osSerdes1InitXaui3g125(void);
+extern UINT32 osSerdes1InitXge10g3125(void);
+extern UINT32 osSerdes1InitPcie2g5(void);
+extern UINT32 osSerdes1InitPcie5g(void);
+extern UINT32 osSerdes1InitPcie8g(void);
+extern UINT32 osSerdes2InitGe1g25Srio1g25(void);
+extern UINT32 osSerdes2InitSrio2g5(void);
+extern UINT32 osSerdes2InitSrio3g125(void);
+extern UINT32 osSerdes2InitSrio5g(void);
+extern UINT32 osSerdes2InitSrio6g25(void);
+extern UINT32 osSerdes2InitPcie2g5(void);
+extern UINT32 osSerdes2InitPcie5g(void);
+extern UINT32 osSerdes2InitPcie8g(void);
+extern UINT32 osSerdes2InitSata1g5(void);
+extern UINT32 osSerdes2InitSata3g(void);
+extern UINT32 osSerdes2InitSata6g(void);
+extern UINT32 osSerdes3InitSrio1g25(void);
+extern UINT32 osSerdes3InitSrio2g5(void);
+extern UINT32 osSerdes3InitSrio3g125(void);
+extern UINT32 osSerdes3InitSrio5g(void);
+extern UINT32 osSerdes3InitSrio6g25(void);
+extern UINT32 osSerdes3InitPcie5g(void);
+extern UINT32 osSerdes0ComCfg(void);
+extern UINT32 osSerdes0WaitForPllCfg(void);
+extern UINT32 osSerdesWrite( UINT32 ulAddr, UINT32 ulIndex, UINT32 ulMask, UINT32 ulType );
+extern void osSerdesBitWrite( UINT32 ulAddr, UINT32 ulOrMask, UINT32 ulAndMask );
+extern void osSerdesWait( UINT32 ulLoop );
+extern UINT32 osSerdes1PmaLp( UINT32 ulLane, UINT32 ulLpMode );
+extern UINT32 osSerdes2PmaLp( UINT32 ulLane, UINT32 ulLpMode );
+extern void osSerdes0LowWrite( UINT32 ulAddr, UINT32 ulValue );
+extern void osSerdes0HighWrite( UINT32 ulAddr, UINT32 ulValue );
+extern void osSerdes1Write( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset, UINT32 ulValue );
+extern UINT32 osSerdes1Read( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset );
+extern void osSerdes2Write( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset, UINT32 ulValue );
+extern UINT32 osSerdes2Read( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset );
+extern void    OS_SDS_WRITE_REG ( UINT32 pRegBase, UINT32 ulRegIndex, UINT32  ulValue );
+
+
+/*宏定义*/
+#define SERDES_WART_TIME    0x100000
+
+#define SREDES_LOOP_TIME    0x100000
+
+#define SERDES_DEBUG_OPEN     (0)
+
+UINT32 gulDebugOpen  = 0x0;
+
+#if 0
+UINT32 SRE_SerdesInit(void)
+{
+    UINT32 ulRet = OS_SUCCESS;
+    /*
+    *该复用关系如下:
+    *serdes0-->liane0-->GE4
+    *serdes0-->liane1-->GE5
+    *serdes0-->liane2-->GE6
+    *serdes0-->liane3-->GE7
+    *serdes0-->liane4-->GE0
+    *serdes0-->liane5-->GE8
+    *serdes0-->liane6-->GE2
+    *serdes0-->liane7-->GE3
+    *serdes1-->liane0-->GE1
+    *serdes2-->liane0~3-->srio
+    *serdes3-->不用
+    */
+    (VOID)SRE_RawMutexProtect(SRE_SERDES_INITSAFE_LOCK);
+
+    if (0 == SRE_RawMutexGetFlag(SRE_SERDES_INITSAFE_LOCK))
+    {
+#if 1
+        SRE_printf("==========bugin mutil use===========\n");
+        /*1、配置ioctrl0 选择GE复用*/
+        OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR, 0, 0x0 );
+        /*2、配置serdes1复用关系*/
+        OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x4, 0, 0x0 );
+        /*3、配置serdes2复用关系*/
+        OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR, 0, 0x00002222 );
+        /*4、serdes3暂时不用*/
+        /*5、配置GE复用*/
+        OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x8, 0, 0x1ff );
+        /*6、配置SRIO复用*/
+        OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x8, 0, 0x22 );
+        /*配置serdes0apb接口*/
+        OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x10, 0, 0x11 );
+#endif
+
+        SRE_printf("==========bugin osSerdes0InitGe1g25===========\n");
+        /*将 serdes0 line0 ~ 7全部初始化为ge/1.25g*/
+        ulRet = osSerdes0InitGe1g25();
+        //ulRet = osSerdes0InitGe1g25Xge10g125();
+        if ( OS_SUCCESS != ulRet )
+        {
+            SRE_printf( "serdes0 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+            return OS_FAIL;
+        }
+        SRE_printf("==========bugin osSerdes1InitGe1G25Srio1g25===========\n");
+        /*将serdes1 line0 初始化为ge/1.25g*/
+        ulRet = osSerdes1InitGe1G25Srio1g25();
+        if ( OS_SUCCESS != ulRet )
+        {
+            SRE_printf( "serdes1 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+            return OS_FAIL;
+        }
+        SRE_printf("==========bugin osSerdes2InitGe1g25Srio1g25===========\n");
+        /*将serdes2初始化为srio/1.25g*/
+        //ulRet = osSerdes2InitGe1g25Srio1g25();
+        //ulRet = osSerdes2InitSrio3g125();
+        ulRet = osSerdes2InitSrio6g25();
+        //ulRet = osSerdes2InitSrio5g();
+        if ( OS_SUCCESS != ulRet )
+        {
+            SRE_printf( "serdes2 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+            return OS_FAIL;
+        }
+
+        (VOID)SRE_RawMutexSetFlag(SRE_SERDES_INITSAFE_LOCK);
+    }
+    (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+
+    return ulRet;
+}
+#endif
+
+#if 1
+/*
+      NOTE: serdes 复用关系配置，仅配置 serdes0，注意物理连线。
+ */
+SRE_SERDES_CFG gstrSerdesCfg =
+{
+	/*.enSerdes0InitType = GE,
+	  .enSerdes1InitType = GE,
+	  .enSerdes2InitType = SRIO,
+	  .enSerdes3InitType = NOT_USED,
+	  .enSerdes0Speed = S1G25,
+	  .enSerdes1Speed = S1G25,
+	  .enSerdes2Speed = S6G25,//S3G125,
+	  .enSerdes3Speed = S5G,
+	 */
+	.enSerdes0InitType = GE,
+	.enSerdes1InitType = NOT_USED,
+	.enSerdes2InitType = NOT_USED,
+	.enSerdes3InitType = NOT_USED,
+	.enSerdes0Speed = S1G25,
+	.enSerdes1Speed = S1G25,
+	.enSerdes2Speed = S6G25,//S3G125,
+	.enSerdes3Speed = S5G,
+
+};
+
+
+
+UINT32 SRE_SerdesInit(VOID)
+{
+    UINT32 ulRet = OS_SUCCESS;
+    (VOID)SRE_RawMutexProtect(SRE_SERDES_INITSAFE_LOCK);
+
+    if (0 == SRE_RawMutexGetFlag(SRE_SERDES_INITSAFE_LOCK))
+    {
+        /*设置默认参数*/
+        OS_SDS_WRITE_REG(IOCTRL0_BASE_ADDR,0x0,0x0);
+        OS_SDS_WRITE_REG(IOCTRL0_BASE_ADDR + 0x4,0x0,0x0);
+        OS_SDS_WRITE_REG(IOCTRL0_BASE_ADDR + 0x8 ,0x0,0x10000000);
+	//OS_SDS_WRITE_REG(IOCTRL1_BASE_ADDR,0x0,0x2222);
+	//OS_SDS_WRITE_REG(IOCTRL1_BASE_ADDR + 0x4,0x0,0x0);
+	//OS_SDS_WRITE_REG(IOCTRL1_BASE_ADDR + 0x8 ,0x0,0x2E);
+        /*配置serdes0apb接口*/
+        OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x10, 0, 0x11 );
+        switch(gstrSerdesCfg.enSerdes0InitType)
+        {
+            case GE:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR,0x0,0x0);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x1FD,0xefffffff);
+                if(gstrSerdesCfg.enSerdes0Speed == S1G25)
+                {
+                    ulRet = osSerdes0InitGe1g25();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes0InitGe1g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf("Unsupport Speed! at  GE Speed[%d]\n",gstrSerdesCfg.enSerdes0Speed);
+                }
+           break;
+           case XGE_XAUI:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR,0x11110000,0x1111FFFF);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x1000F0,0xEEFFFEF2);
+                if(gstrSerdesCfg.enSerdes0Speed == S3G125)
+                {
+                    ulRet = osSerdes0InitGe1g25Xaui3g125();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes0InitGe1g25Xaui3g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf("Unsupport Speed! at  XGE-XAUI Speed[%d]\n",gstrSerdesCfg.enSerdes0Speed);
+                }
+           break;
+           case XGE_SFI:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR,0x22000000,0x22FFFFFF);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0xC0000,0xeFFFFFF3);
+                if(gstrSerdesCfg.enSerdes0Speed == S10G3125)
+                {
+                    ulRet = osSerdes0InitGe1g25Xge10g125();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes0InitGe1g25Xge10g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf("Unsupport Speed! at  XGE-XAUI Speed[%d]\n",gstrSerdesCfg.enSerdes0Speed);
+                }
+           break;
+           case NOT_USED:
+           break;
+           default:
+                SRE_printf("serdes0 unsupport init type\n");
+            break;
+        }
+        switch(gstrSerdesCfg.enSerdes1InitType)
+        {
+            case GE:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x4,0x0,0xfffffff0);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x2,0xFFFFFFFF);
+                if(gstrSerdesCfg.enSerdes1Speed == S1G25)
+                {
+                    ulRet = osSerdes1InitGe1G25Srio1g25();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes1InitGe1G25Srio1g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf( "unspport speed at GE serdes1 at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                    (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                    return OS_FAIL;
+                }
+                break;
+            case XGE_XAUI:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x4,0x1111,0xffff1111);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x200000,0xeFFFFFFF);
+                if(gstrSerdesCfg.enSerdes1Speed == S3G125)
+                {
+                    ulRet = osSerdes1InitXaui3g125();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes1InitXaui3g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf("Unsupport Speed! at  XGE-XAUI Speed[%d]\n",gstrSerdesCfg.enSerdes1Speed);
+                }
+            break;
+            case XGE_SFI:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x4,0x22,0xffffff22);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x30000,0xeFFFFFFF);
+                if(gstrSerdesCfg.enSerdes1Speed == S10G3125)
+                {
+                    ulRet = osSerdes1InitXge10g3125();
+                    if ( OS_SUCCESS != ulRet )
+                    {
+                        SRE_printf( "osSerdes1InitXge10g3125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    }
+                }else
+                {
+                    SRE_printf("Unsupport Speed! at  XGE-XFI Speed[%d]\n",gstrSerdesCfg.enSerdes1Speed);
+                }
+            break;
+            case PCIE:
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x4,0x0,0xffffffff);
+                osSerdesBitWrite(IOCTRL0_BASE_ADDR + 0x8 ,0x10000000,0xFFFFFFFF);
+                switch(gstrSerdesCfg.enSerdes1Speed)
+                {
+                    case S2G5:
+                        ulRet = osSerdes1InitPcie2g5();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes1InitPcie2g5 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S5G:
+                        ulRet = osSerdes1InitPcie5g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes1InitPcie5g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S8G:
+                        ulRet = osSerdes1InitPcie8g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes1InitPcie8g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    default:
+                        SRE_printf( "serdes 1 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                }
+            break;
+            case NOT_USED:
+            break;
+            default:
+                SRE_printf( "serdes 1 unsupport init type\n");
+                (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                return OS_FAIL;
+        }
+        switch(gstrSerdesCfg.enSerdes2InitType)
+        {
+            case SRIO:
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR ,0x2222,0xffff2222);
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x8 ,0x2,0xFFFFFFEF);
+                switch(gstrSerdesCfg.enSerdes2Speed)
+                {
+                    case S1G25:
+                        ulRet = osSerdes2InitGe1g25Srio1g25();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitGe1g25Srio1g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S2G5:
+                        ulRet = osSerdes2InitSrio2g5();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSrio2g5 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S3G125:
+                        ulRet = osSerdes2InitSrio3g125();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSrio3g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S5G:
+                        ulRet = osSerdes2InitSrio5g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSrio5g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S6G25:
+                        ulRet = osSerdes2InitSrio6g25();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSrio6g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    default:
+                        SRE_printf( "serdes 2 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                }
+            break;
+            case PCIE:
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR ,0x0,0xffffffff);
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x8 ,0x0,0xFFFFFFDF);
+                switch(gstrSerdesCfg.enSerdes2Speed)
+                {
+                    case S2G5:
+                        ulRet = osSerdes2InitPcie2g5();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitPcie2g5 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S5G:
+                        ulRet = osSerdes2InitPcie5g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitPcie5g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S8G:
+                        ulRet = osSerdes2InitPcie8g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitPcie8g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    default:
+                        SRE_printf( "serdes 1 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                }
+            break;
+            case SATA:
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR ,0x1111,0xffff1111);
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x8 ,0x1,0xFFFFFFFF);
+                switch(gstrSerdesCfg.enSerdes2Speed)
+                {
+                    case S1G5:
+                        ulRet = osSerdes2InitSata1g5();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSata1g5 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S3G:
+                        ulRet = osSerdes2InitSata3g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSata3g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    case S6G:
+                        ulRet = osSerdes2InitSata6g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes2InitSata6g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    default:
+                        SRE_printf( "serdes 1 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                }
+            break;
+            case NOT_USED:
+            break;
+            default:
+                SRE_printf( "serdes 1 unsupport init type\n");
+                (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                return OS_FAIL;
+        }
+
+        switch(gstrSerdesCfg.enSerdes3InitType)
+        {
+            case SRIO:
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR ,0x11,0xffffff11);
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x8 ,0x12,0xFFFFFFFF);
+                switch(gstrSerdesCfg.enSerdes3Speed)
+                {
+                    case S1G25:
+                        ulRet = osSerdes3InitSrio1g25();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitSrio1g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                     break;
+                     case S2G5:
+                        ulRet = osSerdes3InitSrio2g5();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitSrio2g5 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                     break;
+                     case S3G125:
+                        ulRet = osSerdes3InitSrio3g125();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitSrio3g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                     break;
+                     case S5G:
+                        ulRet = osSerdes3InitSrio5g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitSrio3g125 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                     break;
+                     case S6G25:
+                        ulRet = osSerdes3InitSrio6g25();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitSrio6g25 init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                     break;
+                     default:
+                        SRE_printf( "serdes 1 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                }
+            break;
+            case PCIE:
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR ,0x0,0xffffff00);
+                osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x8 ,0x2C,0xFFFFFFFF);
+                switch(gstrSerdesCfg.enSerdes3Speed)
+                {
+                    case S5G:
+                        ulRet = osSerdes3InitPcie5g();
+                        if ( OS_SUCCESS != ulRet )
+                        {
+                            SRE_printf( "osSerdes3InitPcie5g init error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+                            (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                            return OS_FAIL;
+                        }
+                    break;
+                    default:
+                        SRE_printf( "serdes 3 unsupport speed\n");
+                        (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                        return OS_FAIL;
+                    break;
+                }
+            break;
+            case NOT_USED:
+            break;
+            default:
+                SRE_printf( "serdes 1 unsupport init type\n");
+                (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+                return OS_FAIL;
+        }
+      (VOID)SRE_RawMutexSetFlag(SRE_SERDES_INITSAFE_LOCK);
+    }
+    (VOID)SRE_RawMutexUnProtect(SRE_SERDES_INITSAFE_LOCK);
+    return OS_SUCCESS;
+}
+
+#endif
+
+
+/*****************************************************************
+函数名 :  osSerdes0InitGe1g25
+输入参数    :   None
+输出参数      :
+Description   :  2.2.1  Macro0 Lane0~7 初始化为1000BASE-KX
+                      初始化GE/1.25G
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes0InitGe1g25(void)
+{
+    //UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    UINT32 ulRet = OS_SUCCESS;
+
+    /*前四步配置统一*/
+    ulRet = osSerdes0ComCfg();
+    if ( OS_SUCCESS != ulRet )
+    {
+        return OS_FAIL;
+    }
+    osSerdes0LowWrite( 0x0, 0x36 );
+    osSerdes0LowWrite( 0x4 , 0x26 );
+    osSerdes0LowWrite( 0x100 ,0x20010c );
+
+
+    osSerdes0HighWrite( 0x0, 0x36 );
+    osSerdes0HighWrite( 0x4 , 0x26 );
+    osSerdes0HighWrite( 0x100 , 0x20010c );
+#if 0
+    /*Pcie_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x4],data[bit8=0]*/
+    osSerdesWrite( SERDES0_LOW_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+
+    /*Addr[serdes0_high_base_addr+0x4] ,data[bit8=0]*/
+    osSerdesWrite( SERDES0_HIGHT_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+#endif
+    /*Lane0~3配置chx_tx/rxdatawidth_sel=2, chx_tx/rx_rate_sel=2, */
+    /*Lane4~7配置chx_tx/rxdatawidth_sel=1, chx_tx/rx_rate_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b11]*/
+    /*Addr[serdes0_low_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b11]*/
+    /*Addr[serdes0_high_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b11] */
+    /*Addr[serdes0_high_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b11]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x98, 0xFFFFFF9F );
+
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x98, 0xFFFFFF9F );
+
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x98, 0xFFFFFF9F );
+
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x98, 0xFFFFFF9F );
+
+    }
+/*
+SRE_WriteReg 0xe28f2838,0x1b
+SRE_WriteReg 0xe28f28b8,0x1b
+SRE_WriteReg 0xe28f2938,0x1b
+SRE_WriteReg 0xe28f29b8,0x1b
+SRE_WriteReg 0xe28f3838,0x1b
+SRE_WriteReg 0xe28f38b8,0x1b
+SRE_WriteReg 0xe28f3938,0x1b
+SRE_WriteReg 0xe28f39b8,0x1b
+
+devmem 0xe28f2838 32 0x1b000000
+devmem 0xe28f29b8 32 0x1b000000
+*/
+	/*osSerdesBitWrite(0xe28f2838, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f28b8, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f2938, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f29b8, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f3838, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f38b8, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f3938, 0x1b, 0xffffffff);
+	osSerdesBitWrite(0xe28f39b8, 0x1b, 0xffffffff);
+	*/
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2804,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2884,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2904,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2984,0x0,0xfffffffd);
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3804,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3884,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3904,0x0,0xfffffffd);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3984,0x0,0xfffffffd);
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2800,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2880,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2900,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2980,0x5b0f30, 0x5b0f30);
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3800,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3880,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3900,0x5b0f30, 0x5b0f30);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3980,0x5b0f30, 0x5b0f30);
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2808,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2888,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2908,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x2988,0x4503030f, 0x4503030f);
+
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3808,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3888,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3908,0x4503030f, 0x4503030f);
+    osSerdesBitWrite(MDIO_BASE_ADDR + 0x3988,0x4503030f, 0x4503030f);
+
+    for(ulLoop = 0;ulLoop<0x4;ulLoop++)
+    {
+        osSerdes0LowWrite(0x804 + 0x80 * ulLoop,0xf0001);
+    }
+    for(ulLoop = 0;ulLoop<0x4;ulLoop++)
+    {
+        osSerdes0HighWrite(0x804 + 0x80 * ulLoop,0xf0001);
+    }
+    /*等100ns*/
+    osSerdesWait( 0x1000000);
+
+    /*等待复位撤离信号*/
+    ulRet = osSerdes0WaitForPllCfg();
+    if ( OS_SUCCESS != ulRet )
+    {
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes0InitGe1g25Xaui3g125
+输入参数    :   None
+输出参数      :
+Description   :  Macro0 Lane0~3 初始化为1000BASE-KX，
+                    Lane4~7初始化为XAUI
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes0InitGe1g25Xaui3g125(void)
+{
+    //UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    UINT32 ulRet = OS_SUCCESS;
+    /*前四步配置统一*/
+    ulRet = osSerdes0ComCfg();
+    if ( ulRet != OS_SUCCESS )
+    {
+        return OS_FAIL;
+    }
+    /*Pcie_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x4],data[bit8=0]*/
+    osSerdesWrite( SERDES0_LOW_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+
+    /*Addr[serdes0_high_base_addr+0x4] ,data[bit8=0]*/
+    osSerdesWrite( SERDES0_HIGHT_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+
+    /*Lane0~3配置chx_tx/rxdatawidth_sel=2, chx_tx/rx_rate_sel=2, */
+    /*Lane4~7配置chx_tx/rxdatawidth_sel=1, chx_tx/rx_rate_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b10]*/
+    /*Addr[serdes0_low_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b10]*/
+    /*Addr[serdes0_high_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b01] */
+    /*Addr[serdes0_high_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b01]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+
+    }
+    /*Lane0~3配置Pll_prediv=5’h1,pll_postdiv=8’d20*/
+    /*Lane4~7配置Pll_prediv=5’h1,pll_postdiv=8’d25*/
+    /*Addr[serdes0_low_base_addr+0x100],data[bit12-8=5’h1,bit23-16=8’d20]*/
+    /*Addr[serdes0_high_base_addr+0x100],data[bit12-8=5’h1,bit23-16=8’d25]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x100, 0x140100, 0xFF14E1FF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x100, 0x190100, 0xFF19E1FF );
+
+    /*Lane0~3配置Vcofreq=8’h7*/
+    /*Lane4~7配置Vcofreq=8’h6*/
+    /*Addr[serdes0_low_base_addr+0x108],data[bit31-24=8’h7]*/
+    /*Addr[serdes0_high_base_addr+0x108],data[bit31-24=8’h6]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x108, 0x7000000, 0x7FFFFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x108, 0x60000000, 0xFFFFFF );
+
+    /*等100ns*/
+    osSerdesWait( 0x1000 );
+
+    /*等待复位撤离信号*/
+    ulRet = osSerdes0WaitForPllCfg();
+    if ( ulRet != OS_SUCCESS )
+    {
+        return OS_FAIL;
+    }
+    return ulRet;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes0InitGe1g25Xge10g125
+输入参数    :   None
+输出参数      :
+Description   :  Macro0 Lane0~3 初始化为1000BASE-KX，
+                    Lane6~7初始化为XGE2，XGE3
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes0InitGe1g25Xge10g125(void)
+{
+    //UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    UINT32 ulRet = OS_SUCCESS;
+    /*前四步配置统一*/
+    ulRet = osSerdes0ComCfg();
+    if ( ulRet != OS_SUCCESS )
+    {
+        return OS_FAIL;
+    }
+    /*Pcie_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x4],data[bit8=0]*/
+    osSerdesWrite( SERDES0_LOW_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+
+    /*Addr[serdes0_high_base_addr+0x4] ,data[bit8=0]*/
+    osSerdesWrite( SERDES0_HIGHT_BASE_ADDR + 0x4, 0, 0xFFFFFEFF, 1 );
+
+    /*Lane0~3配置chx_tx/rxdatawidth_sel=2, chx_tx/rx_rate_sel=2, */
+    /*Lane4~7配置chx_tx/rxdatawidth_sel=1, chx_tx/rx_rate_sel=0*/
+    /*Addr[serdes0_low_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b10]*/
+    /*Addr[serdes0_low_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b10,bit5-3=3’b10]*/
+    /*Addr[serdes0_high_base_addr+0x81c+0x80*0~3],data[bit7-6=2’b01,bit5-3=3’b0] */
+    /*Addr[serdes0_high_base_addr+0x82c+0x80*0~3],data[bit7-6=2’b01,bit5-3=3’b0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x40, 0xFFFFFF47 );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x40, 0xFFFFFF47 );
+
+    }
+    /*Lane0~3配置Pll_prediv=5’h1,pll_postdiv=8’d20*/
+    /*Lane4~7配置Pll_prediv=5’h1,pll_postdiv=8’d33*/
+    /*Addr[serdes0_low_base_addr+0x100],data[bit12-8=5’h1,bit23-16=8’d20]*/
+    /*Addr[serdes0_high_base_addr+0x100],data[bit12-8=5’h1,bit23-16=8’d33]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x100, 0x140100, 0xFF14E1FF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x100, 0x210100, 0xFF21E1FF );
+
+    /*Lane0~3配置Vcofreq=8’h7*/
+    /*Lane4~7配置Vcofreq=8’h0*/
+    /*Addr[serdes0_low_base_addr+0x108],data[bit31-24=8’h7]*/
+    /*Addr[serdes0_high_base_addr+0x108],data[bit31-24=8’h0]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x108, 0x7000000, 0x7FFFFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x108, 0x0, 0xFFFFFF );
+
+    /*等100ns*/
+    osSerdesWait( 0x1000 );
+
+    /*等待复位撤离信号*/
+    ulRet = osSerdes0WaitForPllCfg();
+    if ( ulRet != OS_SUCCESS )
+    {
+        return OS_FAIL;
+    }
+    return ulRet;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitGe1G25Srio1g25
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为1000BASE-KX /SRIO 1.25G
+
+Author        :  z00228490
+Creation time :  2013/1/4
+*****************************************************************/
+UINT32 osSerdes1InitGe1G25Srio1g25(void)
+{
+
+
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = 0x10000000;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    //*********************************************************
+    //serdes1  initialization
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_REQ1_REG,0x200,0xffffffff);
+
+    //1(1) set multi-mode:
+    osSerdesBitWrite (MDIO_BASE_ADDR + 0x4060,0x1400,0xFFFFF7FF);
+
+    //1(2) set pcie-mode:
+    //osSerdesBitWrite (MDIO_BASE_ADDR + 0x4060,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_DREQ1_REG,0x200,0xffffffff);
+
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes1Write (0x0,0x0,0x2,0x2);
+    osSerdes1Write (0x1,0x0,0x2,0x2);
+    osSerdes1Write (0x2,0x0,0x2,0x2);
+    osSerdes1Write (0x3,0x0,0x2,0x2);
+    osSerdes1Write (0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //1p25Gbps_156p25MHz.memcfg
+    //load the 1.25Gbps_156.25MHz_VSM.txt
+    osSerdes1Write (0,0,101,183);
+    osSerdes1Write (0,0,102,183);
+    osSerdes1Write (0,0,103,12);
+    osSerdes1Write (0,0,104,12);
+    osSerdes1Write (0,0,105,26);
+    osSerdes1Write (0,0,106,26);
+    osSerdes1Write (0,0,107,2);
+    osSerdes1Write (0,0,108,2);
+    osSerdes1Write (0,0,109,17);
+    osSerdes1Write (0,0,110,13);
+    osSerdes1Write (1,0,101,183);
+    osSerdes1Write (1,0,102,183);
+    osSerdes1Write (1,0,103,12);
+    osSerdes1Write (1,0,104,12);
+    osSerdes1Write (1,0,105,26);
+    osSerdes1Write (1,0,106,26);
+    osSerdes1Write (1,0,107,2);
+    osSerdes1Write (1,0,108,2);
+    osSerdes1Write (1,0,109,17);
+    osSerdes1Write (1,0,110,13);
+    osSerdes1Write (2,0,101,183);
+    osSerdes1Write (2,0,102,183);
+    osSerdes1Write (2,0,103,12);
+    osSerdes1Write (2,0,104,12);
+    osSerdes1Write (2,0,105,26);
+    osSerdes1Write (2,0,106,26);
+    osSerdes1Write (2,0,107,2);
+    osSerdes1Write (2,0,108,2);
+    osSerdes1Write (2,0,109,17);
+    osSerdes1Write (2,0,110,13);
+    osSerdes1Write (3,0,101,183);
+    osSerdes1Write (3,0,102,183);
+    osSerdes1Write (3,0,103,12);
+    osSerdes1Write (3,0,104,12);
+    osSerdes1Write (3,0,105,26);
+    osSerdes1Write (3,0,106,26);
+    osSerdes1Write (3,0,107,2);
+    osSerdes1Write (3,0,108,2);
+    osSerdes1Write (3,0,109,17);
+    osSerdes1Write (3,0,110,13);
+    osSerdes1Write (4,0,101,153);
+    osSerdes1Write (4,0,102,0);
+    osSerdes1Write (4,0,103,108);
+    osSerdes1Write (4,0,104,183);
+    osSerdes1Write (4,0,105,183);
+    osSerdes1Write (4,0,106,12);
+    osSerdes1Write (4,0,107,12);
+    osSerdes1Write (4,0,108,26);
+    osSerdes1Write (4,0,109,26);
+    osSerdes1Write (4,0,110,7);
+    osSerdes1Write (4,0,111,12);
+    osSerdes1Write (4,0,112,8);
+    osSerdes1Write (4,0,113,0);
+    osSerdes1Write (4,0,114,8);
+    osSerdes1Write (4,0,115,0);
+    osSerdes1Write (4,0,116,255);
+    osSerdes1Write (4,0,117,179);
+    osSerdes1Write (4,0,118,246);
+    osSerdes1Write (4,0,119,208);
+    osSerdes1Write (4,0,120,239);
+    osSerdes1Write (4,0,121,251);
+    osSerdes1Write (4,0,122,255);
+    osSerdes1Write (4,0,123,255);
+    osSerdes1Write (4,0,124,255);
+    osSerdes1Write (4,0,125,255);
+    osSerdes1Write (4,0,126,255);
+    osSerdes1Write (4,0,127,211);
+    osSerdes1Write (4,0,128,211);
+    osSerdes1Write (4,0,129,226);
+    osSerdes1Write (4,0,130,239);
+    osSerdes1Write (4,0,131,251);
+    osSerdes1Write (4,0,132,251);
+    osSerdes1Write (4,0,133,255);
+    osSerdes1Write (4,0,134,239);
+    osSerdes1Write (4,0,135,255);
+    osSerdes1Write (4,0,136,255);
+    osSerdes1Write (4,0,137,211);
+    osSerdes1Write (4,0,138,211);
+    osSerdes1Write (4,0,139,226);
+    osSerdes1Write (4,0,140,239);
+    osSerdes1Write (4,0,141,251);
+    osSerdes1Write (4,0,142,251);
+    osSerdes1Write (4,0,143,255);
+    osSerdes1Write (4,0,144,239);
+    osSerdes1Write (4,0,145,255);
+    osSerdes1Write (4,0,146,255);
+    osSerdes1Write (4,0,147,251);
+    osSerdes1Write (4,0,148,255);
+    osSerdes1Write (4,0,149,63);
+    osSerdes1Write (4,0,150,0);
+    osSerdes1Write (4,0,151,100);
+    osSerdes1Write (4,0,152,0);
+    osSerdes1Write (4,0,153,4);
+    osSerdes1Write (4,0,154,2);
+    osSerdes1Write (4,0,155,5);
+    osSerdes1Write (4,0,156,5);
+    osSerdes1Write (4,0,157,4);
+    osSerdes1Write (4,0,158,0);
+    osSerdes1Write (4,0,159,0);
+    osSerdes1Write (4,0,160,8);
+    osSerdes1Write (4,0,161,4);
+    osSerdes1Write (4,0,162,0);
+    osSerdes1Write (4,0,163,0);
+    osSerdes1Write (4,0,164,4);
+    osSerdes1Write (0,0,7,0);
+    osSerdes1Write (1,0,7,0);
+    osSerdes1Write (2,0,7,0);
+    osSerdes1Write (3,0,7,0);
+    osSerdes1Write (4,0,13,16);
+    osSerdes1Write (4,0,48,0);
+    osSerdes1Write (4,0,49,0);
+    osSerdes1Write (4,0,54,0);
+    osSerdes1Write (4,0,55,180);
+    osSerdes1Write (4,0,93,2);
+    osSerdes1Write (4,0,165,2);
+    osSerdes1Write (0,0,41,6);
+    osSerdes1Write (1,0,41,6);
+    osSerdes1Write (2,0,41,6);
+    osSerdes1Write (3,0,41,6);
+    osSerdes1Write (4,0,354,3);
+    osSerdes1Write (4,0,355,58);
+    osSerdes1Write (4,0,356,9);
+    osSerdes1Write (4,0,357,3);
+    osSerdes1Write (4,0,358,62);
+    osSerdes1Write (4,0,359,12);
+    osSerdes1Write (0,0,701,0);
+    osSerdes1Write (1,0,701,0);
+    osSerdes1Write (2,0,701,0);
+    osSerdes1Write (3,0,701,0);
+    osSerdesWait(0x1000000);
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes1Write (0x0,0x0,0x55,0x4c);
+    osSerdes1Write (0x0,0x0,0x56,0xe6);
+    osSerdes1Write (0x0,0x0,0x57,0x1f);
+    osSerdes1Write (0x0,0x0,0xe6,0xfe);
+
+    osSerdes1Write (0x1,0x0,0x55,0x4c);
+    osSerdes1Write (0x1,0x0,0x56,0xe6);
+    osSerdes1Write (0x1,0x0,0x57,0x1f);
+    osSerdes1Write (0x1,0x0,0xe6,0xfe);
+
+    osSerdes1Write (0x2,0x0,0x55,0x4c);
+    osSerdes1Write (0x2,0x0,0x56,0xe6);
+    osSerdes1Write (0x2,0x0,0x57,0x1f);
+    osSerdes1Write (0x2,0x0,0xe6,0xfe);
+
+    osSerdes1Write (0x3,0x0,0x55,0x4c);
+    osSerdes1Write (0x3,0x0,0x56,0xe6);
+    osSerdes1Write (0x3,0x0,0x57,0x1f);
+    osSerdes1Write (0x3,0x0,0xe6,0xfe);
+
+    osSerdes1Write (0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes1Write (0x0,0x0,0x3,0x1);
+    osSerdes1Write (0x0,0x0,0x4,0x1);
+
+    osSerdes1Write (0x1,0x0,0x3,0x1);
+    osSerdes1Write (0x1,0x0,0x4,0x1);
+
+    osSerdes1Write (0x2,0x0,0x3,0x1);
+    osSerdes1Write (0x2,0x0,0x4,0x1);
+
+    osSerdes1Write (0x3,0x0,0x3,0x1);
+    osSerdes1Write (0x3,0x0,0x4,0x1);
+
+    osSerdes1Write (0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes1Write (0x0,0x0,0x2,0x3);
+    osSerdes1Write (0x1,0x0,0x2,0x3);
+    osSerdes1Write (0x2,0x0,0x2,0x3);
+    osSerdes1Write (0x3,0x0,0x2,0x3);
+    osSerdes1Write (0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1). PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //prbs7
+    osSerdes1Write (0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes1Write (0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes1Write (0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes1Write (0x0,0x0,0x18,0x0);
+    osSerdes1Write (0x0,0x0,0x19,0x0);
+    osSerdes1Write (0x0,0x0,0x1a,0x8);
+    osSerdes1Write (0x0,0x0,0x1b,0x78);
+    osSerdes1Write (0x0,0x0,0x1c,0x0);
+
+    osSerdes1Write (0x1,0x0,0x18,0x0);
+    osSerdes1Write (0x1,0x0,0x19,0x0);
+    osSerdes1Write (0x1,0x0,0x1a,0x8);
+    osSerdes1Write (0x1,0x0,0x1b,0x78);
+    osSerdes1Write (0x1,0x0,0x1c,0x0);
+
+    osSerdes1Write (0x2,0x0,0x18,0x0);
+    osSerdes1Write (0x2,0x0,0x19,0x0);
+    osSerdes1Write (0x2,0x0,0x1a,0x8);
+    osSerdes1Write (0x2,0x0,0x1b,0x78);
+    osSerdes1Write (0x2,0x0,0x1c,0x0);
+
+    osSerdes1Write (0x3,0x0,0x18,0x0);
+    osSerdes1Write (0x3,0x0,0x19,0x0);
+    osSerdes1Write (0x3,0x0,0x1a,0x8);
+    osSerdes1Write (0x3,0x0,0x1b,0x78);
+    osSerdes1Write (0x3,0x0,0x1c,0x0);
+
+    osSerdes1Write (0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes1Write (0x0,0x0,0x15,0xdf);
+    osSerdes1Write (0x0,0x0,0x16,0x0);
+    osSerdes1Write (0x0,0x0,0x17,0x0);
+
+    osSerdes1Write (0x1,0x0,0x15,0xdf);
+    osSerdes1Write (0x1,0x0,0x16,0x0);
+    osSerdes1Write (0x1,0x0,0x17,0x0);
+
+    osSerdes1Write (0x2,0x0,0x15,0xdf);
+    osSerdes1Write (0x2,0x0,0x16,0x0);
+    osSerdes1Write (0x2,0x0,0x17,0x0);
+
+    osSerdes1Write (0x3,0x0,0x15,0xdf);
+    osSerdes1Write (0x3,0x0,0x16,0x0);
+    osSerdes1Write (0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes1Write (0x0,0x0,0x5,0x11);
+    osSerdes1Write (0x1,0x0,0x5,0x11);
+    osSerdes1Write (0x2,0x0,0x5,0x11);
+    osSerdes1Write (0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV4.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[2:0]    PCSRX_DIVRATE   7   1
+    //TXPCSDATARATE_DIV4.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[6:4]    PCSTX_DIVRATE   7   1
+    osSerdes1Write (0x0,0x0,0x6,0x11);
+    osSerdes1Write (0x1,0x0,0x6,0x11);
+    osSerdes1Write (0x2,0x0,0x6,0x11);
+    osSerdes1Write (0x3,0x0,0x6,0x11);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes1Write (0x4,0x0,0x8,0x54);
+
+    osSerdesWait(0x1000000);
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes1Write (0x0,0x0,0x27,0x2);
+    osSerdes1Write (0x1,0x0,0x27,0x2);
+    osSerdes1Write (0x2,0x0,0x27,0x2);
+    osSerdes1Write (0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes1Write (0x0,0x0,0x3,0x10);
+    osSerdes1Write (0x0,0x0,0x4,0x10);
+
+    osSerdes1Write (0x1,0x0,0x3,0x10);
+    osSerdes1Write (0x1,0x0,0x4,0x10);
+
+    osSerdes1Write (0x2,0x0,0x3,0x10);
+    osSerdes1Write (0x2,0x0,0x4,0x10);
+
+    osSerdes1Write (0x3,0x0,0x3,0x10);
+    osSerdes1Write (0x3,0x0,0x4,0x10);
+
+    osSerdes1Write (0x4,0x0,0x3,0x10);
+#if 0
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    SreShell 1 );osSerdes1Read 0x0,0x0,11);
+    SreShell 1 );osSerdes1Read 0x1,0x0,11);
+    SreShell 1 );osSerdes1Read 0x2,0x0,11);
+    SreShell 1 );osSerdes1Read 0x3,0x0,11);
+#endif
+    osSerdesWait(0x1000000);
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL0_BASE_ADDR + 0x404 == 0xff0\n" );
+#else
+    ulValue = ulValue & 0xFF0;
+    while ( -- ulWaitTime )
+    {
+        if( ulValue != 0xFF0 )
+        {
+            ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+            ulValue = ulValue & 0xFF0;
+        }else
+        {
+            break;
+        }
+    }
+#endif
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitSrio2g5
+输入参数    :   None
+输出参数      :
+Description   :  Macro1 Lane0~3 初始化为SRIO 2.5G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSrio2g5(void)
+{
+
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载1.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0x99 );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb4 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001,*/
+    /*bit28-26=3'b001,bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,*/
+    /*bit16-14=3b001,bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b010,*/
+    /*bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,bit11-9=3'b010,*/
+    /*bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x492492, 0x492492 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitSrio3g125
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为SRIO 3.125G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSrio3g125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载3.125Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001,*/
+    /*bit28-26=3'b001,bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,*/
+    /*bit16-14=3b001,bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b010,*/
+    /*bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,bit11-9=3'b010,*/
+    /*bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x492492, 0x492492 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitXaui3g125
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为XAUI  3.125G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitXaui3g125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载XAUI_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b011, bit28-26=3'b011,*/
+    /*bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,bit16-14=3b011,*/
+    /*bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b010,*/
+    /*bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,bit11-9=3'b010,*/
+    /*bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x492492, 0x492492 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitSrio5g
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为SRIO 5.0G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSrio5g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载5Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0x99 );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb4 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001, bit28-26=3'b001,*/
+    /*bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,bit16-14=3b001,*/
+    /*bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b011,*/
+    /*bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,bit11-9=3'b011,*/
+    /*bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x6DB6DB, 0x6DB6DB );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes1InitSrio6g25
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为SRIO 5.0G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSrio6g25(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载6.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001, bit28-26=3'b001,*/
+    /*bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,bit16-14=3b001,*/
+    /*bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b011,*/
+    /*bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,bit11-9=3'b011,*/
+    /*bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x6DB6DB, 0x6DB6DB );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes1InitXge10g3125
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为10GE 10.3125G
+
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitXge10g3125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载6.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b010, bit28-26=3'b010,*/
+    /*bit25-23=3'b010,bit22-20=3b010,bit19-17=3b010,bit16-14=3b010,*/
+    /*bit13-11=3b010,bit10-8=3b010,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x492492FF, 0x492492FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,bit23-21=3'b011,*/
+    /*bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,bit11-9=3'b011,*/
+    /*bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x6DB6DB, 0x6DB6DB );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitPcie2g5
+输入参数    :   None
+输出参数      :
+Description   :  macro1 Lane0~3 初始化为PCIE GEN1 2.5G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitPcie2g5(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3E0, 0xFFFFFFE0 );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x13 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xa6 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3E0, 0xFFFFFFE0 );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitPcie5g
+输入参数    :   None
+输出参数      :
+Description   :  macro1  Lane0~3 初始化为PCIE GEN2  5.0G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitPcie5g(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3E0, 0xFFFFFFE0 );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x8 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x13 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x31 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x13 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xa6 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3E0, 0xFFFFFFE0 );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitPcie8g
+输入参数    :   None
+输出参数      :
+Description   :  macro1  Lane0~3 初始化为PCIE GEN2  5.0G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitPcie8g(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3E0, 0xFFFFFFE0 );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_Gen3_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x5 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x33 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x33 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x33 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x33 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x22 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xc4 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-5=all 1,bit4-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3E0, 0xFFFFFFE0 );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitSata1g5
+输入参数    :   None
+输出参数      :
+Description   :  macro1  Lane0~3 初始化为SATA GEN2  1.5G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSata1g5(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载SATA_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001,*/
+    /*bit28-26=3'b001,bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,*/
+    /*bit16-14=3b001,bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,*/
+    /*bit23-21=3'b001,bit20-18=3'b001,bit17-15=3'b001,bit14-12=3'b001,*/
+    /*bit11-9=3'b001,bit8-6=3'b001,bit5-3=3'b001,bit2-0=3'b001]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x249249, 0x249249 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1InitSata3g
+输入参数    :   None
+输出参数      :
+Description   :  macro1  Lane0~3 初始化为SATA GEN2  3.0G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSata3g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载SATA_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b011,*/
+    /*bit28-26=3'b011,bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,*/
+    /*bit16-14=3b011,bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,*/
+    /*bit23-21=3'b010,bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,*/
+    /*bit11-9=3'b010,bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x492492, 0x492492 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************
+函数名 :  osSerdes1InitSata6g
+输入参数    :   None
+输出参数      :
+Description   :  macro1  Lane0~3 初始化为SATA GEN2  6.0G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes1InitSata6g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载SATA_100MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b011,*/
+    /*bit28-26=3'b011,bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,*/
+    /*bit16-14=3b011,bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,*/
+    /*bit23-21=3'b011,bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,*/
+    /*bit11-9=3'b011,bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x6DB6DB, 0x6DB6DB );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitGe1g25Srio1g25
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为1000BASE-KX/SRIO 1.25G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitGe1g25Srio1g25(void)
+{
+    UINT32 ulValue = 0x0;
+    INT32 ulWaitTime = 0x10000000;
+    //*********************************************************
+    //serdes2  initialization:sds2_ge_srio_1g25
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_REQ1_REG,0x80000,0xffffffff);
+
+    //1(1); set multi-mode:
+    osSerdesBitWrite (IOCTRL1_BASE_ADDR + 0x00c,0x1400,0xFFFFF7FF);
+
+    //1(2); set pcie-mode:
+    //osSerdesBitWrite (IOCTRL1_BASE_ADDR + 0x00c,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_DREQ1_REG,0x80000,0xffffffff);
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes2Write (0x0,0x0,0x2,0x2);
+    osSerdes2Write (0x1,0x0,0x2,0x2);
+    osSerdes2Write (0x2,0x0,0x2,0x2);
+    osSerdes2Write (0x3,0x0,0x2,0x2);
+    osSerdes2Write (0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //1p25Gbps_156p25MHz.memcfg
+    //load the 1.25Gbps_156.25MHz_VSM.txt
+    osSerdes2Write (0,0,101,183);
+    osSerdes2Write (0,0,102,183);
+    osSerdes2Write (0,0,103,12);
+    osSerdes2Write (0,0,104,12);
+    osSerdes2Write (0,0,105,26);
+    osSerdes2Write (0,0,106,26);
+    osSerdes2Write (0,0,107,2);
+    osSerdes2Write (0,0,108,2);
+    osSerdes2Write (0,0,109,17);
+    osSerdes2Write (0,0,110,13);
+    osSerdes2Write (1,0,101,183);
+    osSerdes2Write (1,0,102,183);
+    osSerdes2Write (1,0,103,12);
+    osSerdes2Write (1,0,104,12);
+    osSerdes2Write (1,0,105,26);
+    osSerdes2Write (1,0,106,26);
+    osSerdes2Write (1,0,107,2);
+    osSerdes2Write (1,0,108,2);
+    osSerdes2Write (1,0,109,17);
+    osSerdes2Write (1,0,110,13);
+    osSerdes2Write (2,0,101,183);
+    osSerdes2Write (2,0,102,183);
+    osSerdes2Write (2,0,103,12);
+    osSerdes2Write (2,0,104,12);
+    osSerdes2Write (2,0,105,26);
+    osSerdes2Write (2,0,106,26);
+    osSerdes2Write (2,0,107,2);
+    osSerdes2Write (2,0,108,2);
+    osSerdes2Write (2,0,109,17);
+    osSerdes2Write (2,0,110,13);
+    osSerdes2Write (3,0,101,183);
+    osSerdes2Write (3,0,102,183);
+    osSerdes2Write (3,0,103,12);
+    osSerdes2Write (3,0,104,12);
+    osSerdes2Write (3,0,105,26);
+    osSerdes2Write (3,0,106,26);
+    osSerdes2Write (3,0,107,2);
+    osSerdes2Write (3,0,108,2);
+    osSerdes2Write (3,0,109,17);
+    osSerdes2Write (3,0,110,13);
+    osSerdes2Write (4,0,101,153);
+    osSerdes2Write (4,0,102,0);
+    osSerdes2Write (4,0,103,108);
+    osSerdes2Write (4,0,104,183);
+    osSerdes2Write (4,0,105,183);
+    osSerdes2Write (4,0,106,12);
+    osSerdes2Write (4,0,107,12);
+    osSerdes2Write (4,0,108,26);
+    osSerdes2Write (4,0,109,26);
+    osSerdes2Write (4,0,110,7);
+    osSerdes2Write (4,0,111,12);
+    osSerdes2Write (4,0,112,8);
+    osSerdes2Write (4,0,113,0);
+    osSerdes2Write (4,0,114,8);
+    osSerdes2Write (4,0,115,0);
+    osSerdes2Write (4,0,116,255);
+    osSerdes2Write (4,0,117,179);
+    osSerdes2Write (4,0,118,246);
+    osSerdes2Write (4,0,119,208);
+    osSerdes2Write (4,0,120,239);
+    osSerdes2Write (4,0,121,251);
+    osSerdes2Write (4,0,122,255);
+    osSerdes2Write (4,0,123,255);
+    osSerdes2Write (4,0,124,255);
+    osSerdes2Write (4,0,125,255);
+    osSerdes2Write (4,0,126,255);
+    osSerdes2Write (4,0,127,211);
+    osSerdes2Write (4,0,128,211);
+    osSerdes2Write (4,0,129,226);
+    osSerdes2Write (4,0,130,239);
+    osSerdes2Write (4,0,131,251);
+    osSerdes2Write (4,0,132,251);
+    osSerdes2Write (4,0,133,255);
+    osSerdes2Write (4,0,134,239);
+    osSerdes2Write (4,0,135,255);
+    osSerdes2Write (4,0,136,255);
+    osSerdes2Write (4,0,137,211);
+    osSerdes2Write (4,0,138,211);
+    osSerdes2Write (4,0,139,226);
+    osSerdes2Write (4,0,140,239);
+    osSerdes2Write (4,0,141,251);
+    osSerdes2Write (4,0,142,251);
+    osSerdes2Write (4,0,143,255);
+    osSerdes2Write (4,0,144,239);
+    osSerdes2Write (4,0,145,255);
+    osSerdes2Write (4,0,146,255);
+    osSerdes2Write (4,0,147,251);
+    osSerdes2Write (4,0,148,255);
+    osSerdes2Write (4,0,149,63);
+    osSerdes2Write (4,0,150,0);
+    osSerdes2Write (4,0,151,100);
+    osSerdes2Write (4,0,152,0);
+    osSerdes2Write (4,0,153,4);
+    osSerdes2Write (4,0,154,2);
+    osSerdes2Write (4,0,155,5);
+    osSerdes2Write (4,0,156,5);
+    osSerdes2Write (4,0,157,4);
+    osSerdes2Write (4,0,158,0);
+    osSerdes2Write (4,0,159,0);
+    osSerdes2Write (4,0,160,8);
+    osSerdes2Write (4,0,161,4);
+    osSerdes2Write (4,0,162,0);
+    osSerdes2Write (4,0,163,0);
+    osSerdes2Write (4,0,164,4);
+    osSerdes2Write (0,0,7,0);
+    osSerdes2Write (1,0,7,0);
+    osSerdes2Write (2,0,7,0);
+    osSerdes2Write (3,0,7,0);
+    osSerdes2Write (4,0,13,16);
+    osSerdes2Write (4,0,48,0);
+    osSerdes2Write (4,0,49,0);
+    osSerdes2Write (4,0,54,0);
+    osSerdes2Write (4,0,55,180);
+    osSerdes2Write (4,0,93,2);
+    osSerdes2Write (4,0,165,2);
+    osSerdes2Write (0,0,41,6);
+    osSerdes2Write (1,0,41,6);
+    osSerdes2Write (2,0,41,6);
+    osSerdes2Write (3,0,41,6);
+    osSerdes2Write (4,0,354,3);
+    osSerdes2Write (4,0,355,58);
+    osSerdes2Write (4,0,356,9);
+    osSerdes2Write (4,0,357,3);
+    osSerdes2Write (4,0,358,62);
+    osSerdes2Write (4,0,359,12);
+    osSerdes2Write (0,0,701,0);
+    osSerdes2Write (1,0,701,0);
+    osSerdes2Write (2,0,701,0);
+    osSerdes2Write (3,0,701,0);
+    osSerdesWait(0x1000000);
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes2Write (0x0,0x0,0x55,0x4c);
+    osSerdes2Write (0x0,0x0,0x56,0xe6);
+    osSerdes2Write (0x0,0x0,0x57,0x1f);
+    osSerdes2Write (0x0,0x0,0xe6,0xfe);
+
+    osSerdes2Write (0x1,0x0,0x55,0x4c);
+    osSerdes2Write (0x1,0x0,0x56,0xe6);
+    osSerdes2Write (0x1,0x0,0x57,0x1f);
+    osSerdes2Write (0x1,0x0,0xe6,0xfe);
+
+    osSerdes2Write (0x2,0x0,0x55,0x4c);
+    osSerdes2Write (0x2,0x0,0x56,0xe6);
+    osSerdes2Write (0x2,0x0,0x57,0x1f);
+    osSerdes2Write (0x2,0x0,0xe6,0xfe);
+
+    osSerdes2Write (0x3,0x0,0x55,0x4c);
+    osSerdes2Write (0x3,0x0,0x56,0xe6);
+    osSerdes2Write (0x3,0x0,0x57,0x1f);
+    osSerdes2Write (0x3,0x0,0xe6,0xfe);
+
+    osSerdes2Write (0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes2Write (0x0,0x0,0x3,0x1);
+    osSerdes2Write (0x0,0x0,0x4,0x1);
+
+    osSerdes2Write (0x1,0x0,0x3,0x1);
+    osSerdes2Write (0x1,0x0,0x4,0x1);
+
+    osSerdes2Write (0x2,0x0,0x3,0x1);
+    osSerdes2Write (0x2,0x0,0x4,0x1);
+
+    osSerdes2Write (0x3,0x0,0x3,0x1);
+    osSerdes2Write (0x3,0x0,0x4,0x1);
+
+    osSerdes2Write (0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes2Write (0x0,0x0,0x2,0x3);
+    osSerdes2Write (0x1,0x0,0x2,0x3);
+    osSerdes2Write (0x2,0x0,0x2,0x3);
+    osSerdes2Write (0x3,0x0,0x2,0x3);
+    osSerdes2Write (0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1);. PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //prbs7
+    osSerdes2Write (0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes2Write (0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes2Write (0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes2Write (0x0,0x0,0x18,0x0);
+    osSerdes2Write (0x0,0x0,0x19,0x0);
+    osSerdes2Write (0x0,0x0,0x1a,0x8);
+    osSerdes2Write (0x0,0x0,0x1b,0x78);
+    osSerdes2Write (0x0,0x0,0x1c,0x0);
+
+    osSerdes2Write (0x1,0x0,0x18,0x0);
+    osSerdes2Write (0x1,0x0,0x19,0x0);
+    osSerdes2Write (0x1,0x0,0x1a,0x8);
+    osSerdes2Write (0x1,0x0,0x1b,0x78);
+    osSerdes2Write (0x1,0x0,0x1c,0x0);
+
+    osSerdes2Write (0x2,0x0,0x18,0x0);
+    osSerdes2Write (0x2,0x0,0x19,0x0);
+    osSerdes2Write (0x2,0x0,0x1a,0x8);
+    osSerdes2Write (0x2,0x0,0x1b,0x78);
+    osSerdes2Write (0x2,0x0,0x1c,0x0);
+
+    osSerdes2Write (0x3,0x0,0x18,0x0);
+    osSerdes2Write (0x3,0x0,0x19,0x0);
+    osSerdes2Write (0x3,0x0,0x1a,0x8);
+    osSerdes2Write (0x3,0x0,0x1b,0x78);
+    osSerdes2Write (0x3,0x0,0x1c,0x0);
+
+    osSerdes2Write (0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes2Write (0x0,0x0,0x15,0xdf);
+    osSerdes2Write (0x0,0x0,0x16,0x0);
+    osSerdes2Write (0x0,0x0,0x17,0x0);
+
+    osSerdes2Write (0x1,0x0,0x15,0xdf);
+    osSerdes2Write (0x1,0x0,0x16,0x0);
+    osSerdes2Write (0x1,0x0,0x17,0x0);
+
+    osSerdes2Write (0x2,0x0,0x15,0xdf);
+    osSerdes2Write (0x2,0x0,0x16,0x0);
+    osSerdes2Write (0x2,0x0,0x17,0x0);
+
+    osSerdes2Write (0x3,0x0,0x15,0xdf);
+    osSerdes2Write (0x3,0x0,0x16,0x0);
+    osSerdes2Write (0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes2Write (0x0,0x0,0x5,0x11);
+    osSerdes2Write (0x1,0x0,0x5,0x11);
+    osSerdes2Write (0x2,0x0,0x5,0x11);
+    osSerdes2Write (0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV4.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //6[2:0]    PCSRX_DIVRATE   7   1
+    //TXPCSDATARATE_DIV4.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //6[6:4]    PCSTX_DIVRATE   7   1
+    osSerdes2Write (0x0,0x0,0x6,0x11);
+    osSerdes2Write (0x1,0x0,0x6,0x11);
+    osSerdes2Write (0x2,0x0,0x6,0x11);
+    osSerdes2Write (0x3,0x0,0x6,0x11);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes2Write (0x4,0x0,0x8,0x54);
+
+    osSerdesWait(0x1000000);
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes2Write (0x0,0x0,0x27,0x2);
+    osSerdes2Write (0x1,0x0,0x27,0x2);
+    osSerdes2Write (0x2,0x0,0x27,0x2);
+    osSerdes2Write (0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes2Write (0x0,0x0,0x3,0x10);
+    osSerdes2Write (0x0,0x0,0x4,0x10);
+
+    osSerdes2Write (0x1,0x0,0x3,0x10);
+    osSerdes2Write (0x1,0x0,0x4,0x10);
+
+    osSerdes2Write (0x2,0x0,0x3,0x10);
+    osSerdes2Write (0x2,0x0,0x4,0x10);
+
+    osSerdes2Write (0x3,0x0,0x3,0x10);
+    osSerdes2Write (0x3,0x0,0x4,0x10);
+
+    osSerdes2Write (0x4,0x0,0x3,0x10);
+#if 0
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    osSerdes2Read (0x0,0x0,11);
+    osSerdes2Read (0x1,0x0,11);
+    osSerdes2Read (0x2,0x0,11);
+    osSerdes2Read (0x3,0x0,11);
+#endif
+    osSerdesWait(0x1000000);
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL1_BASE_ADDR + 0x400 == 0xff0\n" );
+#else
+    while ( -- ulWaitTime)
+    {
+        if( ulValue != 0xFF0 )
+        {
+            ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+            ulValue = ulValue & 0xFF0;
+        }
+        else
+        {
+            break;
+        }
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+#endif
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSrio2g5
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为SRIO 2.5G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitSrio2g5(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    //*********************************************************
+    //serdes2  initialization:init_macro2_srio_2g5
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_REQ1_REG,0x80000,0xffffffff);
+
+    //1(1) set multi-mode:
+    osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1400,0xFFFFF7FF);
+
+    //1(2) set pcie-mode:
+    //osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_DREQ1_REG,0x80000,0xffffffff);
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes2Write(0x0,0x0,0x2,0x2);
+    osSerdes2Write(0x1,0x0,0x2,0x2);
+    osSerdes2Write(0x2,0x0,0x2,0x2);
+    osSerdes2Write(0x3,0x0,0x2,0x2);
+    osSerdes2Write(0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //load the 1.25Gbps_156.25MHz_VSM.txt
+    osSerdes2Write(0,0,101,183);
+    osSerdes2Write(0,0,102,183);
+    osSerdes2Write(0,0,103,12);
+    osSerdes2Write(0,0,104,12);
+    osSerdes2Write(0,0,105,26);
+    osSerdes2Write(0,0,106,26);
+    osSerdes2Write(0,0,107,2);
+    osSerdes2Write(0,0,108,2);
+    osSerdes2Write(0,0,109,17);
+    osSerdes2Write(0,0,110,13);
+    osSerdes2Write(1,0,101,183);
+    osSerdes2Write(1,0,102,183);
+    osSerdes2Write(1,0,103,12);
+    osSerdes2Write(1,0,104,12);
+    osSerdes2Write(1,0,105,26);
+    osSerdes2Write(1,0,106,26);
+    osSerdes2Write(1,0,107,2);
+    osSerdes2Write(1,0,108,2);
+    osSerdes2Write(1,0,109,17);
+    osSerdes2Write(1,0,110,13);
+    osSerdes2Write(2,0,101,183);
+    osSerdes2Write(2,0,102,183);
+    osSerdes2Write(2,0,103,12);
+    osSerdes2Write(2,0,104,12);
+    osSerdes2Write(2,0,105,26);
+    osSerdes2Write(2,0,106,26);
+    osSerdes2Write(2,0,107,2);
+    osSerdes2Write(2,0,108,2);
+    osSerdes2Write(2,0,109,17);
+    osSerdes2Write(2,0,110,13);
+    osSerdes2Write(3,0,101,183);
+    osSerdes2Write(3,0,102,183);
+    osSerdes2Write(3,0,103,12);
+    osSerdes2Write(3,0,104,12);
+    osSerdes2Write(3,0,105,26);
+    osSerdes2Write(3,0,106,26);
+    osSerdes2Write(3,0,107,2);
+    osSerdes2Write(3,0,108,2);
+    osSerdes2Write(3,0,109,17);
+    osSerdes2Write(3,0,110,13);
+    osSerdes2Write(4,0,101,153);
+    osSerdes2Write(4,0,102,0);
+    osSerdes2Write(4,0,103,108);
+    osSerdes2Write(4,0,104,183);
+    osSerdes2Write(4,0,105,183);
+    osSerdes2Write(4,0,106,12);
+    osSerdes2Write(4,0,107,12);
+    osSerdes2Write(4,0,108,26);
+    osSerdes2Write(4,0,109,26);
+    osSerdes2Write(4,0,110,7);
+    osSerdes2Write(4,0,111,12);
+    osSerdes2Write(4,0,112,8);
+    osSerdes2Write(4,0,113,0);
+    osSerdes2Write(4,0,114,8);
+    osSerdes2Write(4,0,115,0);
+    osSerdes2Write(4,0,116,255);
+    osSerdes2Write(4,0,117,179);
+    osSerdes2Write(4,0,118,246);
+    osSerdes2Write(4,0,119,208);
+    osSerdes2Write(4,0,120,239);
+    osSerdes2Write(4,0,121,251);
+    osSerdes2Write(4,0,122,255);
+    osSerdes2Write(4,0,123,255);
+    osSerdes2Write(4,0,124,255);
+    osSerdes2Write(4,0,125,255);
+    osSerdes2Write(4,0,126,255);
+    osSerdes2Write(4,0,127,211);
+    osSerdes2Write(4,0,128,211);
+    osSerdes2Write(4,0,129,226);
+    osSerdes2Write(4,0,130,239);
+    osSerdes2Write(4,0,131,251);
+    osSerdes2Write(4,0,132,251);
+    osSerdes2Write(4,0,133,255);
+    osSerdes2Write(4,0,134,239);
+    osSerdes2Write(4,0,135,255);
+    osSerdes2Write(4,0,136,255);
+    osSerdes2Write(4,0,137,211);
+    osSerdes2Write(4,0,138,211);
+    osSerdes2Write(4,0,139,226);
+    osSerdes2Write(4,0,140,239);
+    osSerdes2Write(4,0,141,251);
+    osSerdes2Write(4,0,142,251);
+    osSerdes2Write(4,0,143,255);
+    osSerdes2Write(4,0,144,239);
+    osSerdes2Write(4,0,145,255);
+    osSerdes2Write(4,0,146,255);
+    osSerdes2Write(4,0,147,251);
+    osSerdes2Write(4,0,148,255);
+    osSerdes2Write(4,0,149,63);
+    osSerdes2Write(4,0,150,0);
+    osSerdes2Write(4,0,151,100);
+    osSerdes2Write(4,0,152,0);
+    osSerdes2Write(4,0,153,4);
+    osSerdes2Write(4,0,154,2);
+    osSerdes2Write(4,0,155,5);
+    osSerdes2Write(4,0,156,5);
+    osSerdes2Write(4,0,157,4);
+    osSerdes2Write(4,0,158,0);
+    osSerdes2Write(4,0,159,0);
+    osSerdes2Write(4,0,160,8);
+    osSerdes2Write(4,0,161,4);
+    osSerdes2Write(4,0,162,0);
+    osSerdes2Write(4,0,163,0);
+    osSerdes2Write(4,0,164,4);
+    osSerdes2Write(0,0,7,0);
+    osSerdes2Write(1,0,7,0);
+    osSerdes2Write(2,0,7,0);
+    osSerdes2Write(3,0,7,0);
+    osSerdes2Write(4,0,13,16);
+    osSerdes2Write(4,0,48,0);
+    osSerdes2Write(4,0,49,0);
+    osSerdes2Write(4,0,54,0);
+    osSerdes2Write(4,0,55,180);
+    osSerdes2Write(4,0,93,2);
+    osSerdes2Write(4,0,165,2);
+    osSerdes2Write(0,0,41,6);
+    osSerdes2Write(1,0,41,6);
+    osSerdes2Write(2,0,41,6);
+    osSerdes2Write(3,0,41,6);
+    osSerdes2Write(4,0,354,3);
+    osSerdes2Write(4,0,355,58);
+    osSerdes2Write(4,0,356,9);
+    osSerdes2Write(4,0,357,3);
+    osSerdes2Write(4,0,358,62);
+    osSerdes2Write(4,0,359,12);
+    osSerdes2Write(0,0,701,0);
+    osSerdes2Write(1,0,701,0);
+    osSerdes2Write(2,0,701,0);
+    osSerdes2Write(3,0,701,0);
+
+    osSerdesWait(0x1000000);
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes2Write(0x0,0x0,0x55,0x4c);
+    osSerdes2Write(0x0,0x0,0x56,0xe6);
+    osSerdes2Write(0x0,0x0,0x57,0x1f);
+    osSerdes2Write(0x0,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x1,0x0,0x55,0x4c);
+    osSerdes2Write(0x1,0x0,0x56,0xe6);
+    osSerdes2Write(0x1,0x0,0x57,0x1f);
+    osSerdes2Write(0x1,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x2,0x0,0x55,0x4c);
+    osSerdes2Write(0x2,0x0,0x56,0xe6);
+    osSerdes2Write(0x2,0x0,0x57,0x1f);
+    osSerdes2Write(0x2,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x3,0x0,0x55,0x4c);
+    osSerdes2Write(0x3,0x0,0x56,0xe6);
+    osSerdes2Write(0x3,0x0,0x57,0x1f);
+    osSerdes2Write(0x3,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes2Write(0x0,0x0,0x3,0x1);
+    osSerdes2Write(0x0,0x0,0x4,0x1);
+
+    osSerdes2Write(0x1,0x0,0x3,0x1);
+    osSerdes2Write(0x1,0x0,0x4,0x1);
+
+    osSerdes2Write(0x2,0x0,0x3,0x1);
+    osSerdes2Write(0x2,0x0,0x4,0x1);
+
+    osSerdes2Write(0x3,0x0,0x3,0x1);
+    osSerdes2Write(0x3,0x0,0x4,0x1);
+
+    osSerdes2Write(0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes2Write(0x0,0x0,0x2,0x3);
+    osSerdes2Write(0x1,0x0,0x2,0x3);
+    osSerdes2Write(0x2,0x0,0x2,0x3);
+    osSerdes2Write(0x3,0x0,0x2,0x3);
+    osSerdes2Write(0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1). PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //clock pattern
+    //osSerdes2Write(0x4,0x0,0x50,0x0);
+    //prbs7
+    osSerdes2Write(0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes2Write(0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes2Write(0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes2Write(0x0,0x0,0x18,0x0);
+    osSerdes2Write(0x0,0x0,0x19,0x0);
+    osSerdes2Write(0x0,0x0,0x1a,0x8);
+    osSerdes2Write(0x0,0x0,0x1b,0x78);
+    osSerdes2Write(0x0,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x1,0x0,0x18,0x0);
+    osSerdes2Write(0x1,0x0,0x19,0x0);
+    osSerdes2Write(0x1,0x0,0x1a,0x8);
+    osSerdes2Write(0x1,0x0,0x1b,0x78);
+    osSerdes2Write(0x1,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x2,0x0,0x18,0x0);
+    osSerdes2Write(0x2,0x0,0x19,0x0);
+    osSerdes2Write(0x2,0x0,0x1a,0x8);
+    osSerdes2Write(0x2,0x0,0x1b,0x78);
+    osSerdes2Write(0x2,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x3,0x0,0x18,0x0);
+    osSerdes2Write(0x3,0x0,0x19,0x0);
+    osSerdes2Write(0x3,0x0,0x1a,0x8);
+    osSerdes2Write(0x3,0x0,0x1b,0x78);
+    osSerdes2Write(0x3,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes2Write(0x0,0x0,0x15,0xdf);
+    osSerdes2Write(0x0,0x0,0x16,0x0);
+    osSerdes2Write(0x0,0x0,0x17,0x0);
+
+    osSerdes2Write(0x1,0x0,0x15,0xdf);
+    osSerdes2Write(0x1,0x0,0x16,0x0);
+    osSerdes2Write(0x1,0x0,0x17,0x0);
+
+    osSerdes2Write(0x2,0x0,0x15,0xdf);
+    osSerdes2Write(0x2,0x0,0x16,0x0);
+    osSerdes2Write(0x2,0x0,0x17,0x0);
+
+    osSerdes2Write(0x3,0x0,0x15,0xdf);
+    osSerdes2Write(0x3,0x0,0x16,0x0);
+    osSerdes2Write(0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes2Write(0x0,0x0,0x5,0x11);
+    osSerdes2Write(0x1,0x0,0x5,0x11);
+    osSerdes2Write(0x2,0x0,0x5,0x11);
+    osSerdes2Write(0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV2.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[2:0]    PCSRX_DIVRATE   7   2
+    //TXPCSDATARATE_DIV2.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[6:4]    PCSTX_DIVRATE   7   2
+    osSerdes2Write(0x0,0x0,0x6,0x22);
+    osSerdes2Write(0x1,0x0,0x6,0x22);
+    osSerdes2Write(0x2,0x0,0x6,0x22);
+    osSerdes2Write(0x3,0x0,0x6,0x22);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes2Write(0x4,0x0,0x8,0x54);
+
+    osSerdesWait(0x1000000);
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes2Write(0x0,0x0,0x27,0x2);
+    osSerdes2Write(0x1,0x0,0x27,0x2);
+    osSerdes2Write(0x2,0x0,0x27,0x2);
+    osSerdes2Write(0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes2Write(0x0,0x0,0x3,0x10);
+    osSerdes2Write(0x0,0x0,0x4,0x10);
+
+    osSerdes2Write(0x1,0x0,0x3,0x10);
+    osSerdes2Write(0x1,0x0,0x4,0x10);
+
+    osSerdes2Write(0x2,0x0,0x3,0x10);
+    osSerdes2Write(0x2,0x0,0x4,0x10);
+
+    osSerdes2Write(0x3,0x0,0x3,0x10);
+    osSerdes2Write(0x3,0x0,0x4,0x10);
+
+    osSerdes2Write(0x4,0x0,0x3,0x10);
+    osSerdesWait(0x1000000);
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    osSerdes2Read(0x0,0x0,11);
+    osSerdes2Read(0x1,0x0,11);
+    osSerdes2Read(0x2,0x0,11);
+    osSerdes2Read(0x3,0x0,11);
+    osSerdesWait(0x1000000);
+    //the initialization is finished
+    //*********************************************************
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+/*****************************************************************
+函数名 :  osSerdes2InitSrio3g125
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为SRIO 3.125G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitSrio3g125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    //*********************************************************
+    //serdes2  initialization:init_macro2_srio_3g125
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_REQ1_REG,0x80000,0xffffffff);
+
+    //1(1) set multi-mode:
+    osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1400,0xFFFFF7FF);
+
+    //1(2) set pcie-mode:
+    //osSerdesBitWrite(IOCTRL1_BASE_ADDR + 00c,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_DREQ1_REG,0x80000,0xffffffff);
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes2Write(0x0,0x0,0x2,0x2);
+    osSerdes2Write(0x1,0x0,0x2,0x2);
+    osSerdes2Write(0x2,0x0,0x2,0x2);
+    osSerdes2Write(0x3,0x0,0x2,0x2);
+    osSerdes2Write(0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //3.125Gbps_156.25MHz_VSM.txt
+    osSerdes2Write(0,0,101,191);
+    osSerdes2Write(0,0,102,191);
+    osSerdes2Write(0,0,103,10);
+    osSerdes2Write(0,0,104,10);
+    osSerdes2Write(0,0,105,14);
+    osSerdes2Write(0,0,106,14);
+    osSerdes2Write(0,0,107,1);
+    osSerdes2Write(0,0,108,1);
+    osSerdes2Write(0,0,109,34);
+    osSerdes2Write(0,0,110,13);
+    osSerdes2Write(1,0,101,191);
+    osSerdes2Write(1,0,102,191);
+    osSerdes2Write(1,0,103,10);
+    osSerdes2Write(1,0,104,10);
+    osSerdes2Write(1,0,105,14);
+    osSerdes2Write(1,0,106,14);
+    osSerdes2Write(1,0,107,1);
+    osSerdes2Write(1,0,108,1);
+    osSerdes2Write(1,0,109,34);
+    osSerdes2Write(1,0,110,13);
+    osSerdes2Write(2,0,101,191);
+    osSerdes2Write(2,0,102,191);
+    osSerdes2Write(2,0,103,10);
+    osSerdes2Write(2,0,104,10);
+    osSerdes2Write(2,0,105,14);
+    osSerdes2Write(2,0,106,14);
+    osSerdes2Write(2,0,107,1);
+    osSerdes2Write(2,0,108,1);
+    osSerdes2Write(2,0,109,34);
+    osSerdes2Write(2,0,110,13);
+    osSerdes2Write(3,0,101,191);
+    osSerdes2Write(3,0,102,191);
+    osSerdes2Write(3,0,103,10);
+    osSerdes2Write(3,0,104,10);
+    osSerdes2Write(3,0,105,14);
+    osSerdes2Write(3,0,106,14);
+    osSerdes2Write(3,0,107,1);
+    osSerdes2Write(3,0,108,1);
+    osSerdes2Write(3,0,109,34);
+    osSerdes2Write(3,0,110,13);
+    osSerdes2Write(4,0,101,170);
+    osSerdes2Write(4,0,102,0);
+    osSerdes2Write(4,0,103,108);
+    osSerdes2Write(4,0,104,191);
+    osSerdes2Write(4,0,105,191);
+    osSerdes2Write(4,0,106,10);
+    osSerdes2Write(4,0,107,10);
+    osSerdes2Write(4,0,108,14);
+    osSerdes2Write(4,0,109,14);
+    osSerdes2Write(4,0,110,7);
+    osSerdes2Write(4,0,111,12);
+    osSerdes2Write(4,0,112,16);
+    osSerdes2Write(4,0,113,0);
+    osSerdes2Write(4,0,114,16);
+    osSerdes2Write(4,0,115,0);
+    osSerdes2Write(4,0,116,255);
+    osSerdes2Write(4,0,117,179);
+    osSerdes2Write(4,0,118,246);
+    osSerdes2Write(4,0,119,208);
+    osSerdes2Write(4,0,120,239);
+    osSerdes2Write(4,0,121,251);
+    osSerdes2Write(4,0,122,255);
+    osSerdes2Write(4,0,123,255);
+    osSerdes2Write(4,0,124,255);
+    osSerdes2Write(4,0,125,255);
+    osSerdes2Write(4,0,126,255);
+    osSerdes2Write(4,0,127,211);
+    osSerdes2Write(4,0,128,211);
+    osSerdes2Write(4,0,129,226);
+    osSerdes2Write(4,0,130,239);
+    osSerdes2Write(4,0,131,251);
+    osSerdes2Write(4,0,132,251);
+    osSerdes2Write(4,0,133,255);
+    osSerdes2Write(4,0,134,239);
+    osSerdes2Write(4,0,135,255);
+    osSerdes2Write(4,0,136,255);
+    osSerdes2Write(4,0,137,211);
+    osSerdes2Write(4,0,138,211);
+    osSerdes2Write(4,0,139,226);
+    osSerdes2Write(4,0,140,239);
+    osSerdes2Write(4,0,141,251);
+    osSerdes2Write(4,0,142,251);
+    osSerdes2Write(4,0,143,255);
+    osSerdes2Write(4,0,144,239);
+    osSerdes2Write(4,0,145,255);
+    osSerdes2Write(4,0,146,255);
+    osSerdes2Write(4,0,147,251);
+    osSerdes2Write(4,0,148,255);
+    osSerdes2Write(4,0,149,63);
+    osSerdes2Write(4,0,150,0);
+    osSerdes2Write(4,0,151,100);
+    osSerdes2Write(4,0,152,0);
+    osSerdes2Write(4,0,153,2);
+    osSerdes2Write(4,0,154,1);
+    osSerdes2Write(4,0,155,5);
+    osSerdes2Write(4,0,156,5);
+    osSerdes2Write(4,0,157,4);
+    osSerdes2Write(4,0,158,0);
+    osSerdes2Write(4,0,159,0);
+    osSerdes2Write(4,0,160,8);
+    osSerdes2Write(4,0,161,4);
+    osSerdes2Write(4,0,162,0);
+    osSerdes2Write(4,0,163,0);
+    osSerdes2Write(4,0,164,4);
+    osSerdes2Write(0,0,7,0);
+    osSerdes2Write(1,0,7,0);
+    osSerdes2Write(2,0,7,0);
+    osSerdes2Write(3,0,7,0);
+    osSerdes2Write(4,0,13,16);
+    osSerdes2Write(4,0,48,0);
+    osSerdes2Write(4,0,49,0);
+    osSerdes2Write(4,0,54,0);
+    osSerdes2Write(4,0,55,156);
+    osSerdes2Write(4,0,93,2);
+    osSerdes2Write(4,0,165,2);
+    osSerdes2Write(0,0,41,6);
+    osSerdes2Write(1,0,41,6);
+    osSerdes2Write(2,0,41,6);
+    osSerdes2Write(3,0,41,6);
+    osSerdes2Write(4,0,354,3);
+    osSerdes2Write(4,0,355,58);
+    osSerdes2Write(4,0,356,9);
+    osSerdes2Write(4,0,357,3);
+    osSerdes2Write(4,0,358,62);
+    osSerdes2Write(4,0,359,12);
+    osSerdes2Write(0,0,701,0);
+    osSerdes2Write(1,0,701,0);
+    osSerdes2Write(2,0,701,0);
+    osSerdes2Write(3,0,701,0);
+
+    osSerdesWait(0x1000000);
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes2Write(0x0,0x0,0x55,0x4c);
+    osSerdes2Write(0x0,0x0,0x56,0xe6);
+    osSerdes2Write(0x0,0x0,0x57,0x1f);
+    osSerdes2Write(0x0,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x1,0x0,0x55,0x4c);
+    osSerdes2Write(0x1,0x0,0x56,0xe6);
+    osSerdes2Write(0x1,0x0,0x57,0x1f);
+    osSerdes2Write(0x1,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x2,0x0,0x55,0x4c);
+    osSerdes2Write(0x2,0x0,0x56,0xe6);
+    osSerdes2Write(0x2,0x0,0x57,0x1f);
+    osSerdes2Write(0x2,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x3,0x0,0x55,0x4c);
+    osSerdes2Write(0x3,0x0,0x56,0xe6);
+    osSerdes2Write(0x3,0x0,0x57,0x1f);
+    osSerdes2Write(0x3,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes2Write(0x0,0x0,0x3,0x1);
+    osSerdes2Write(0x0,0x0,0x4,0x1);
+
+    osSerdes2Write(0x1,0x0,0x3,0x1);
+    osSerdes2Write(0x1,0x0,0x4,0x1);
+
+    osSerdes2Write(0x2,0x0,0x3,0x1);
+    osSerdes2Write(0x2,0x0,0x4,0x1);
+
+    osSerdes2Write(0x3,0x0,0x3,0x1);
+    osSerdes2Write(0x3,0x0,0x4,0x1);
+
+    osSerdes2Write(0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes2Write(0x0,0x0,0x2,0x3);
+    osSerdes2Write(0x1,0x0,0x2,0x3);
+    osSerdes2Write(0x2,0x0,0x2,0x3);
+    osSerdes2Write(0x3,0x0,0x2,0x3);
+    osSerdes2Write(0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1). PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //clock pattern
+    //osSerdes2Write(0x4,0x0,0x50,0x0);
+    //prbs7
+    osSerdes2Write(0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes2Write(0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes2Write(0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes2Write(0x0,0x0,0x18,0x0);
+    osSerdes2Write(0x0,0x0,0x19,0x0);
+    osSerdes2Write(0x0,0x0,0x1a,0x8);
+    osSerdes2Write(0x0,0x0,0x1b,0x78);
+    osSerdes2Write(0x0,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x1,0x0,0x18,0x0);
+    osSerdes2Write(0x1,0x0,0x19,0x0);
+    osSerdes2Write(0x1,0x0,0x1a,0x8);
+    osSerdes2Write(0x1,0x0,0x1b,0x78);
+    osSerdes2Write(0x1,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x2,0x0,0x18,0x0);
+    osSerdes2Write(0x2,0x0,0x19,0x0);
+    osSerdes2Write(0x2,0x0,0x1a,0x8);
+    osSerdes2Write(0x2,0x0,0x1b,0x78);
+    osSerdes2Write(0x2,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x3,0x0,0x18,0x0);
+    osSerdes2Write(0x3,0x0,0x19,0x0);
+    osSerdes2Write(0x3,0x0,0x1a,0x8);
+    osSerdes2Write(0x3,0x0,0x1b,0x78);
+    osSerdes2Write(0x3,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes2Write(0x0,0x0,0x15,0xdf);
+    osSerdes2Write(0x0,0x0,0x16,0x0);
+    osSerdes2Write(0x0,0x0,0x17,0x0);
+
+    osSerdes2Write(0x1,0x0,0x15,0xdf);
+    osSerdes2Write(0x1,0x0,0x16,0x0);
+    osSerdes2Write(0x1,0x0,0x17,0x0);
+
+    osSerdes2Write(0x2,0x0,0x15,0xdf);
+    osSerdes2Write(0x2,0x0,0x16,0x0);
+    osSerdes2Write(0x2,0x0,0x17,0x0);
+
+    osSerdes2Write(0x3,0x0,0x15,0xdf);
+    osSerdes2Write(0x3,0x0,0x16,0x0);
+    osSerdes2Write(0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes2Write(0x0,0x0,0x5,0x11);
+    osSerdes2Write(0x1,0x0,0x5,0x11);
+    osSerdes2Write(0x2,0x0,0x5,0x11);
+    osSerdes2Write(0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV2.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[2:0]    PCSRX_DIVRATE   7   2
+    //TXPCSDATARATE_DIV2.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[6:4]    PCSTX_DIVRATE   7   2
+    osSerdes2Write(0x0,0x0,0x6,0x22);
+    osSerdes2Write(0x1,0x0,0x6,0x22);
+    osSerdes2Write(0x2,0x0,0x6,0x22);
+    osSerdes2Write(0x3,0x0,0x6,0x22);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes2Write(0x4,0x0,0x8,0x54);
+    osSerdesWait(0x1000000);
+
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes2Write(0x0,0x0,0x27,0x2);
+    osSerdes2Write(0x1,0x0,0x27,0x2);
+    osSerdes2Write(0x2,0x0,0x27,0x2);
+    osSerdes2Write(0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes2Write(0x0,0x0,0x3,0x10);
+    osSerdes2Write(0x0,0x0,0x4,0x10);
+
+    osSerdes2Write(0x1,0x0,0x3,0x10);
+    osSerdes2Write(0x1,0x0,0x4,0x10);
+
+    osSerdes2Write(0x2,0x0,0x3,0x10);
+    osSerdes2Write(0x2,0x0,0x4,0x10);
+
+    osSerdes2Write(0x3,0x0,0x3,0x10);
+    osSerdes2Write(0x3,0x0,0x4,0x10);
+
+    osSerdes2Write(0x4,0x0,0x3,0x10);
+    osSerdesWait(0x1000000);
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    osSerdes2Read(0x0,0x0,11);
+    osSerdes2Read(0x1,0x0,11);
+    osSerdes2Read(0x2,0x0,11);
+    osSerdes2Read(0x3,0x0,11);
+    osSerdesWait(0x1000000);
+    //the initialization is finished
+    //*********************************************************
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitXaui3g125
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为XAUI 3.125G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitXaui3g125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl1_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载3.125Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b011, bit28-26=3'b011,*/
+    /*bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,bit16-14=3b011,*/
+    /*bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b010,*/
+    /*bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,bit11-9=3'b010,*/
+    /*bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0xFFC00, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSrio5g
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为Srio 5G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitSrio5g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    //*********************************************************
+    //serdes2  initialization:init_macro2_ srio_5g
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite (SRE_SC_SERDES_RESET_REQ1_REG,0x80000,0xffffffff);
+
+    //1(1) set multi-mode:
+    osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1400,0xFFFFF7FF);
+
+    //1(2) set pcie-mode:
+    //osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_DREQ1_REG,0x80000,0xffffffff);
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes2Write(0x0,0x0,0x2,0x2);
+    osSerdes2Write(0x1,0x0,0x2,0x2);
+    osSerdes2Write(0x2,0x0,0x2,0x2);
+    osSerdes2Write(0x3,0x0,0x2,0x2);
+    osSerdes2Write(0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //load the 5Gbps_156.25MHz_VSM.txt
+    osSerdes2Write(0,0,101,183);
+    osSerdes2Write(0,0,102,183);
+    osSerdes2Write(0,0,103,12);
+    osSerdes2Write(0,0,104,12);
+    osSerdes2Write(0,0,105,26);
+    osSerdes2Write(0,0,106,26);
+    osSerdes2Write(0,0,107,2);
+    osSerdes2Write(0,0,108,2);
+    osSerdes2Write(0,0,109,17);
+    osSerdes2Write(0,0,110,5);
+    osSerdes2Write(1,0,101,183);
+    osSerdes2Write(1,0,102,183);
+    osSerdes2Write(1,0,103,12);
+    osSerdes2Write(1,0,104,12);
+    osSerdes2Write(1,0,105,26);
+    osSerdes2Write(1,0,106,26);
+    osSerdes2Write(1,0,107,2);
+    osSerdes2Write(1,0,108,2);
+    osSerdes2Write(1,0,109,17);
+    osSerdes2Write(1,0,110,5);
+    osSerdes2Write(2,0,101,183);
+    osSerdes2Write(2,0,102,183);
+    osSerdes2Write(2,0,103,12);
+    osSerdes2Write(2,0,104,12);
+    osSerdes2Write(2,0,105,26);
+    osSerdes2Write(2,0,106,26);
+    osSerdes2Write(2,0,107,2);
+    osSerdes2Write(2,0,108,2);
+    osSerdes2Write(2,0,109,17);
+    osSerdes2Write(2,0,110,5);
+    osSerdes2Write(3,0,101,183);
+    osSerdes2Write(3,0,102,183);
+    osSerdes2Write(3,0,103,12);
+    osSerdes2Write(3,0,104,12);
+    osSerdes2Write(3,0,105,26);
+    osSerdes2Write(3,0,106,26);
+    osSerdes2Write(3,0,107,2);
+    osSerdes2Write(3,0,108,2);
+    osSerdes2Write(3,0,109,17);
+    osSerdes2Write(3,0,110,5);
+    osSerdes2Write(4,0,101,153);
+    osSerdes2Write(4,0,102,0);
+    osSerdes2Write(4,0,103,108);
+    osSerdes2Write(4,0,104,183);
+    osSerdes2Write(4,0,105,183);
+    osSerdes2Write(4,0,106,12);
+    osSerdes2Write(4,0,107,12);
+    osSerdes2Write(4,0,108,26);
+    osSerdes2Write(4,0,109,26);
+    osSerdes2Write(4,0,110,7);
+    osSerdes2Write(4,0,111,12);
+    osSerdes2Write(4,0,112,8);
+    osSerdes2Write(4,0,113,0);
+    osSerdes2Write(4,0,114,8);
+    osSerdes2Write(4,0,115,0);
+    osSerdes2Write(4,0,116,255);
+    osSerdes2Write(4,0,117,179);
+    osSerdes2Write(4,0,118,246);
+    osSerdes2Write(4,0,119,208);
+    osSerdes2Write(4,0,120,239);
+    osSerdes2Write(4,0,121,251);
+    osSerdes2Write(4,0,122,255);
+    osSerdes2Write(4,0,123,255);
+    osSerdes2Write(4,0,124,255);
+    osSerdes2Write(4,0,125,255);
+    osSerdes2Write(4,0,126,255);
+    osSerdes2Write(4,0,127,211);
+    osSerdes2Write(4,0,128,211);
+    osSerdes2Write(4,0,129,226);
+    osSerdes2Write(4,0,130,239);
+    osSerdes2Write(4,0,131,251);
+    osSerdes2Write(4,0,132,251);
+    osSerdes2Write(4,0,133,255);
+    osSerdes2Write(4,0,134,239);
+    osSerdes2Write(4,0,135,255);
+    osSerdes2Write(4,0,136,255);
+    osSerdes2Write(4,0,137,211);
+    osSerdes2Write(4,0,138,211);
+    osSerdes2Write(4,0,139,226);
+    osSerdes2Write(4,0,140,239);
+    osSerdes2Write(4,0,141,251);
+    osSerdes2Write(4,0,142,251);
+    osSerdes2Write(4,0,143,255);
+    osSerdes2Write(4,0,144,239);
+    osSerdes2Write(4,0,145,255);
+    osSerdes2Write(4,0,146,255);
+    osSerdes2Write(4,0,147,251);
+    osSerdes2Write(4,0,148,255);
+    osSerdes2Write(4,0,149,63);
+    osSerdes2Write(4,0,150,0);
+    osSerdes2Write(4,0,151,100);
+    osSerdes2Write(4,0,152,0);
+    osSerdes2Write(4,0,153,4);
+    osSerdes2Write(4,0,154,2);
+    osSerdes2Write(4,0,155,5);
+    osSerdes2Write(4,0,156,5);
+    osSerdes2Write(4,0,157,4);
+    osSerdes2Write(4,0,158,0);
+    osSerdes2Write(4,0,159,0);
+    osSerdes2Write(4,0,160,8);
+    osSerdes2Write(4,0,161,4);
+    osSerdes2Write(4,0,162,0);
+    osSerdes2Write(4,0,163,0);
+    osSerdes2Write(4,0,164,4);
+    osSerdes2Write(0,0,7,0);
+    osSerdes2Write(1,0,7,0);
+    osSerdes2Write(2,0,7,0);
+    osSerdes2Write(3,0,7,0);
+    osSerdes2Write(4,0,13,16);
+    osSerdes2Write(4,0,48,0);
+    osSerdes2Write(4,0,49,0);
+    osSerdes2Write(4,0,54,0);
+    osSerdes2Write(4,0,55,180);
+    osSerdes2Write(4,0,93,2);
+    osSerdes2Write(4,0,165,2);
+    osSerdes2Write(0,0,41,6);
+    osSerdes2Write(1,0,41,6);
+    osSerdes2Write(2,0,41,6);
+    osSerdes2Write(3,0,41,6);
+    osSerdes2Write(4,0,354,3);
+    osSerdes2Write(4,0,355,58);
+    osSerdes2Write(4,0,356,9);
+    osSerdes2Write(4,0,357,3);
+    osSerdes2Write(4,0,358,62);
+    osSerdes2Write(4,0,359,12);
+    osSerdes2Write(0,0,701,0);
+    osSerdes2Write(1,0,701,0);
+    osSerdes2Write(2,0,701,0);
+    osSerdes2Write(3,0,701,0);
+
+    osSerdesWait(0x1000000);
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes2Write(0x0,0x0,0x55,0x4c);
+    osSerdes2Write(0x0,0x0,0x56,0xe6);
+    osSerdes2Write(0x0,0x0,0x57,0x1f);
+    osSerdes2Write(0x0,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x1,0x0,0x55,0x4c);
+    osSerdes2Write(0x1,0x0,0x56,0xe6);
+    osSerdes2Write(0x1,0x0,0x57,0x1f);
+    osSerdes2Write(0x1,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x2,0x0,0x55,0x4c);
+    osSerdes2Write(0x2,0x0,0x56,0xe6);
+    osSerdes2Write(0x2,0x0,0x57,0x1f);
+    osSerdes2Write(0x2,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x3,0x0,0x55,0x4c);
+    osSerdes2Write(0x3,0x0,0x56,0xe6);
+    osSerdes2Write(0x3,0x0,0x57,0x1f);
+    osSerdes2Write(0x3,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes2Write(0x0,0x0,0x3,0x1);
+    osSerdes2Write(0x0,0x0,0x4,0x1);
+
+    osSerdes2Write(0x1,0x0,0x3,0x1);
+    osSerdes2Write(0x1,0x0,0x4,0x1);
+
+    osSerdes2Write(0x2,0x0,0x3,0x1);
+    osSerdes2Write(0x2,0x0,0x4,0x1);
+
+    osSerdes2Write(0x3,0x0,0x3,0x1);
+    osSerdes2Write(0x3,0x0,0x4,0x1);
+
+    osSerdes2Write(0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes2Write(0x0,0x0,0x2,0x3);
+    osSerdes2Write(0x1,0x0,0x2,0x3);
+    osSerdes2Write(0x2,0x0,0x2,0x3);
+    osSerdes2Write(0x3,0x0,0x2,0x3);
+    osSerdes2Write(0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1). PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //clock pattern
+    //osSerdes2Write(0x4,0x0,0x50,0x0);
+    //prbs7
+    osSerdes2Write(0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes2Write(0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes2Write(0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes2Write(0x0,0x0,0x18,0x0);
+    osSerdes2Write(0x0,0x0,0x19,0x0);
+    osSerdes2Write(0x0,0x0,0x1a,0x8);
+    osSerdes2Write(0x0,0x0,0x1b,0x78);
+    osSerdes2Write(0x0,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x1,0x0,0x18,0x0);
+    osSerdes2Write(0x1,0x0,0x19,0x0);
+    osSerdes2Write(0x1,0x0,0x1a,0x8);
+    osSerdes2Write(0x1,0x0,0x1b,0x78);
+    osSerdes2Write(0x1,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x2,0x0,0x18,0x0);
+    osSerdes2Write(0x2,0x0,0x19,0x0);
+    osSerdes2Write(0x2,0x0,0x1a,0x8);
+    osSerdes2Write(0x2,0x0,0x1b,0x78);
+    osSerdes2Write(0x2,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x3,0x0,0x18,0x0);
+    osSerdes2Write(0x3,0x0,0x19,0x0);
+    osSerdes2Write(0x3,0x0,0x1a,0x8);
+    osSerdes2Write(0x3,0x0,0x1b,0x78);
+    osSerdes2Write(0x3,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes2Write(0x0,0x0,0x15,0xdf);
+    osSerdes2Write(0x0,0x0,0x16,0x0);
+    osSerdes2Write(0x0,0x0,0x17,0x0);
+
+    osSerdes2Write(0x1,0x0,0x15,0xdf);
+    osSerdes2Write(0x1,0x0,0x16,0x0);
+    osSerdes2Write(0x1,0x0,0x17,0x0);
+
+    osSerdes2Write(0x2,0x0,0x15,0xdf);
+    osSerdes2Write(0x2,0x0,0x16,0x0);
+    osSerdes2Write(0x2,0x0,0x17,0x0);
+
+    osSerdes2Write(0x3,0x0,0x15,0xdf);
+    osSerdes2Write(0x3,0x0,0x16,0x0);
+    osSerdes2Write(0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes2Write(0x0,0x0,0x5,0x11);
+    osSerdes2Write(0x1,0x0,0x5,0x11);
+    osSerdes2Write(0x2,0x0,0x5,0x11);
+    osSerdes2Write(0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV1.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[2:0]    PCSRX_DIVRATE   7   3
+    //TXPCSDATARATE_DIV1.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[6:4]    PCSTX_DIVRATE   7   3
+    osSerdes2Write(0x0,0x0,0x6,0x33);
+    osSerdes2Write(0x1,0x0,0x6,0x33);
+    osSerdes2Write(0x2,0x0,0x6,0x33);
+    osSerdes2Write(0x3,0x0,0x6,0x33);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes2Write(0x4,0x0,0x8,0x54);
+
+    osSerdesWait(0x1000000);
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes2Write(0x0,0x0,0x27,0x2);
+    osSerdes2Write(0x1,0x0,0x27,0x2);
+    osSerdes2Write(0x2,0x0,0x27,0x2);
+    osSerdes2Write(0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes2Write(0x0,0x0,0x3,0x10);
+    osSerdes2Write(0x0,0x0,0x4,0x10);
+
+    osSerdes2Write(0x1,0x0,0x3,0x10);
+    osSerdes2Write(0x1,0x0,0x4,0x10);
+
+    osSerdes2Write(0x2,0x0,0x3,0x10);
+    osSerdes2Write(0x2,0x0,0x4,0x10);
+
+    osSerdes2Write(0x3,0x0,0x3,0x10);
+    osSerdes2Write(0x3,0x0,0x4,0x10);
+
+    osSerdes2Write(0x4,0x0,0x3,0x10);
+    osSerdesWait(0x1000000);
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    osSerdes2Read(0x0,0x0,11);
+    osSerdes2Read(0x1,0x0,11);
+    osSerdes2Read(0x2,0x0,11);
+    osSerdes2Read(0x3,0x0,11);
+    osSerdesWait(0x1000000);
+
+    //the initialization is finished
+    //*********************************************************
+
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSrio6g25
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为Srio 6.25G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitSrio6g25(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    //*********************************************************
+    //serdes2  initialization:init_macro2_ srio_6g25
+    //*********************************************************
+    //1.    POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_REQ1_REG,0x80000,0xffffffff);
+
+    //1(1) set multi-mode:
+    osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1400,0xFFFFF7FF);
+
+    //1(2) set pcie-mode:
+    //osSerdesBitWrite(IOCTRL1_BASE_ADDR + 0x00c,0x1c00,0xFFFFFFFF);
+
+    //2.    Release POR
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_DREQ1_REG,0x80000,0xffffffff);
+    osSerdesWait(0x1000000);
+    //3.    Enable Hard Reset
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASSEN   7   1
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASSEN_SYNTH 4   1
+    //4.    Hard Reset
+    //HARDRST.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   0
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   0
+    osSerdes2Write(0x0,0x0,0x2,0x2);
+    osSerdes2Write(0x1,0x0,0x2,0x2);
+    osSerdes2Write(0x2,0x0,0x2,0x2);
+    osSerdes2Write(0x3,0x0,0x2,0x2);
+    osSerdes2Write(0x4,0x0,0x2,0x1);
+    osSerdesWait(0x1000000);
+    // 5.   Load Different Data Rate Settings
+    //load the 6.25Gbps_156.25MHz_VSM.txt
+    osSerdes2Write(0,0,101,191);
+    osSerdes2Write(0,0,102,191);
+    osSerdes2Write(0,0,103,10);
+    osSerdes2Write(0,0,104,10);
+    osSerdes2Write(0,0,105,14);
+    osSerdes2Write(0,0,106,14);
+    osSerdes2Write(0,0,107,1);
+    osSerdes2Write(0,0,108,1);
+    osSerdes2Write(0,0,109,34);
+    osSerdes2Write(0,0,110,5);
+    osSerdes2Write(1,0,101,191);
+    osSerdes2Write(1,0,102,191);
+    osSerdes2Write(1,0,103,10);
+    osSerdes2Write(1,0,104,10);
+    osSerdes2Write(1,0,105,14);
+    osSerdes2Write(1,0,106,14);
+    osSerdes2Write(1,0,107,1);
+    osSerdes2Write(1,0,108,1);
+    osSerdes2Write(1,0,109,34);
+    osSerdes2Write(1,0,110,5);
+    osSerdes2Write(2,0,101,191);
+    osSerdes2Write(2,0,102,191);
+    osSerdes2Write(2,0,103,10);
+    osSerdes2Write(2,0,104,10);
+    osSerdes2Write(2,0,105,14);
+    osSerdes2Write(2,0,106,14);
+    osSerdes2Write(2,0,107,1);
+    osSerdes2Write(2,0,108,1);
+    osSerdes2Write(2,0,109,34);
+    osSerdes2Write(2,0,110,5);
+    osSerdes2Write(3,0,101,191);
+    osSerdes2Write(3,0,102,191);
+    osSerdes2Write(3,0,103,10);
+    osSerdes2Write(3,0,104,10);
+    osSerdes2Write(3,0,105,14);
+    osSerdes2Write(3,0,106,14);
+    osSerdes2Write(3,0,107,1);
+    osSerdes2Write(3,0,108,1);
+    osSerdes2Write(3,0,109,34);
+    osSerdes2Write(3,0,110,5);
+    osSerdes2Write(4,0,101,170);
+    osSerdes2Write(4,0,102,0);
+    osSerdes2Write(4,0,103,108);
+    osSerdes2Write(4,0,104,191);
+    osSerdes2Write(4,0,105,191);
+    osSerdes2Write(4,0,106,10);
+    osSerdes2Write(4,0,107,10);
+    osSerdes2Write(4,0,108,14);
+    osSerdes2Write(4,0,109,14);
+    osSerdes2Write(4,0,110,7);
+    osSerdes2Write(4,0,111,12);
+    osSerdes2Write(4,0,112,16);
+    osSerdes2Write(4,0,113,0);
+    osSerdes2Write(4,0,114,16);
+    osSerdes2Write(4,0,115,0);
+    osSerdes2Write(4,0,116,255);
+    osSerdes2Write(4,0,117,179);
+    osSerdes2Write(4,0,118,246);
+    osSerdes2Write(4,0,119,208);
+    osSerdes2Write(4,0,120,239);
+    osSerdes2Write(4,0,121,251);
+    osSerdes2Write(4,0,122,255);
+    osSerdes2Write(4,0,123,255);
+    osSerdes2Write(4,0,124,255);
+    osSerdes2Write(4,0,125,255);
+    osSerdes2Write(4,0,126,255);
+    osSerdes2Write(4,0,127,211);
+    osSerdes2Write(4,0,128,211);
+    osSerdes2Write(4,0,129,226);
+    osSerdes2Write(4,0,130,239);
+    osSerdes2Write(4,0,131,251);
+    osSerdes2Write(4,0,132,251);
+    osSerdes2Write(4,0,133,255);
+    osSerdes2Write(4,0,134,239);
+    osSerdes2Write(4,0,135,255);
+    osSerdes2Write(4,0,136,255);
+    osSerdes2Write(4,0,137,211);
+    osSerdes2Write(4,0,138,211);
+    osSerdes2Write(4,0,139,226);
+    osSerdes2Write(4,0,140,239);
+    osSerdes2Write(4,0,141,251);
+    osSerdes2Write(4,0,142,251);
+    osSerdes2Write(4,0,143,255);
+    osSerdes2Write(4,0,144,239);
+    osSerdes2Write(4,0,145,255);
+    osSerdes2Write(4,0,146,255);
+    osSerdes2Write(4,0,147,251);
+    osSerdes2Write(4,0,148,255);
+    osSerdes2Write(4,0,149,63);
+    osSerdes2Write(4,0,150,0);
+    osSerdes2Write(4,0,151,100);
+    osSerdes2Write(4,0,152,0);
+    osSerdes2Write(4,0,153,2);
+    osSerdes2Write(4,0,154,1);
+    osSerdes2Write(4,0,155,5);
+    osSerdes2Write(4,0,156,5);
+    osSerdes2Write(4,0,157,4);
+    osSerdes2Write(4,0,158,0);
+    osSerdes2Write(4,0,159,0);
+    osSerdes2Write(4,0,160,8);
+    osSerdes2Write(4,0,161,4);
+    osSerdes2Write(4,0,162,0);
+    osSerdes2Write(4,0,163,0);
+    osSerdes2Write(4,0,164,4);
+    osSerdes2Write(0,0,7,0);
+    osSerdes2Write(1,0,7,0);
+    osSerdes2Write(2,0,7,0);
+    osSerdes2Write(3,0,7,0);
+    osSerdes2Write(4,0,13,16);
+    osSerdes2Write(4,0,48,0);
+    osSerdes2Write(4,0,49,0);
+    osSerdes2Write(4,0,54,0);
+    osSerdes2Write(4,0,55,156);
+    osSerdes2Write(4,0,93,2);
+    osSerdes2Write(4,0,165,2);
+    osSerdes2Write(0,0,41,6);
+    osSerdes2Write(1,0,41,6);
+    osSerdes2Write(2,0,41,6);
+    osSerdes2Write(3,0,41,6);
+    osSerdes2Write(4,0,354,3);
+    osSerdes2Write(4,0,355,58);
+    osSerdes2Write(4,0,356,9);
+    osSerdes2Write(4,0,357,3);
+    osSerdes2Write(4,0,358,62);
+    osSerdes2Write(4,0,359,12);
+    osSerdes2Write(0,0,701,0);
+    osSerdes2Write(1,0,701,0);
+    osSerdes2Write(2,0,701,0);
+    osSerdes2Write(3,0,701,0);
+
+    osSerdesWait(0x1000000);
+
+    // 6.   Overwrite
+    //PCSOVR_ENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //85[1:1]   LB_LOCWREN  7   0
+    //85[4:4]   PCSRX_LOCWREN   7   0
+    //85[7:7]   PCSTX_LOCWREN   7   0
+    //95[4:4]   CMNPCSBIST_LOCWREN  4   0
+    //86[0:0]   PCSTXBIST_LOCWREN   7   0
+    //87[5:5]   TXDRV_LOCWREN   7   0
+    //86[3:3]   RXCALEQ_LOCWREN 7   0
+    //85[5:5]   PCSRXBIST_LOCWREN   7   0
+    //95[2:2]   CMNPCIEGEN3_LOCWREN 4   0
+    //95[5:5]   CMNPCSPSTATE_LOCWREN    4   0
+    //86[4:4]   RXCALEYEDIAGFSMIN_LOCWREN   7   0
+    //95[3:3]   CMNPCS_LOCWREN  4   0
+    //85[0:0]   LANEPCSPSTATE_LOCWREN   7   0
+    //230[0:0]  RXLOCK2REF_LOCWREN  7   0
+    osSerdes2Write(0x0,0x0,0x55,0x4c);
+    osSerdes2Write(0x0,0x0,0x56,0xe6);
+    osSerdes2Write(0x0,0x0,0x57,0x1f);
+    osSerdes2Write(0x0,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x1,0x0,0x55,0x4c);
+    osSerdes2Write(0x1,0x0,0x56,0xe6);
+    osSerdes2Write(0x1,0x0,0x57,0x1f);
+    osSerdes2Write(0x1,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x2,0x0,0x55,0x4c);
+    osSerdes2Write(0x2,0x0,0x56,0xe6);
+    osSerdes2Write(0x2,0x0,0x57,0x1f);
+    osSerdes2Write(0x2,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x3,0x0,0x55,0x4c);
+    osSerdes2Write(0x3,0x0,0x56,0xe6);
+    osSerdes2Write(0x3,0x0,0x57,0x1f);
+    osSerdes2Write(0x3,0x0,0xe6,0xfe);
+
+    osSerdes2Write(0x4,0x0,0x5f,0xc3);
+    osSerdesWait(0x1000000);
+    // 7.   Set to IDDQ state
+    //PCSPSTATE_IDDQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   1
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   1
+    //4[4:0]    LANEPCSPSTATE_TX    7   1
+    osSerdes2Write(0x0,0x0,0x3,0x1);
+    osSerdes2Write(0x0,0x0,0x4,0x1);
+
+    osSerdes2Write(0x1,0x0,0x3,0x1);
+    osSerdes2Write(0x1,0x0,0x4,0x1);
+
+    osSerdes2Write(0x2,0x0,0x3,0x1);
+    osSerdes2Write(0x2,0x0,0x4,0x1);
+
+    osSerdes2Write(0x3,0x0,0x3,0x1);
+    osSerdes2Write(0x3,0x0,0x4,0x1);
+
+    osSerdes2Write(0x4,0x0,0x3,0x1);
+    osSerdesWait(0x1000000);
+    // 8.   Release Hard Reset
+    //HARDRST_NOT.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //2[0:0]    CMNCTLPOR_HARDRSTBYPASS     7   1
+    //2[1:1]    CMNCTLPOR_HARDRSTBYPASS_SYNTH   4   1
+    osSerdes2Write(0x0,0x0,0x2,0x3);
+    osSerdes2Write(0x1,0x0,0x2,0x3);
+    osSerdes2Write(0x2,0x0,0x2,0x3);
+    osSerdes2Write(0x3,0x0,0x2,0x3);
+    osSerdes2Write(0x4,0x0,0x2,0x3);
+    osSerdesWait(0x1000000);
+    // 9(1). PRBS pattern
+    //TXBIST_PRBS7.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //80[2:0]   CMNPCSBIST_MODESEL  4   1
+    //prbs7
+    osSerdes2Write(0x4,0x0,0x50,0x1);
+    //prbs23
+    //osSerdes2Write(0x4,0x0,0x50,0x2);
+    //prbs31
+    //osSerdes2Write(0x4,0x0,0x50,0x3);
+    osSerdesWait(0x1000000);
+    // 10.  RXEQ setting
+    //RXEQ.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //83[0:0]   RXAGC_DCCOUPLEEN    4   0
+    //24[2:0]   RXCALEQ_DCGAIN      7   0
+    //27[6:4]   RXCALEQ_LOFREQAGCGAIN   7   7
+    //28[7:3]   RXCALEQ_HIFREQAGCCAP    7   0
+    //25[2:0]   RXCALEQ_DFEPSTAPGAIN    7   0
+    //24[5:3]   RXCALEQ_DFEPSTAPF3DB    7   0
+    //25[6:3]   RXCALEQ_DFETAP1GAIN 7   0
+    //26[3:0]   RXCALEQ_DFETAP2GAIN 7   8
+    //26[7:4]   RXCALEQ_DFETAP3GAIN 7   0
+    //27[3:0]   RXCALEQ_DFETAP4GAIN 7   8
+    osSerdes2Write(0x0,0x0,0x18,0x0);
+    osSerdes2Write(0x0,0x0,0x19,0x0);
+    osSerdes2Write(0x0,0x0,0x1a,0x8);
+    osSerdes2Write(0x0,0x0,0x1b,0x78);
+    osSerdes2Write(0x0,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x1,0x0,0x18,0x0);
+    osSerdes2Write(0x1,0x0,0x19,0x0);
+    osSerdes2Write(0x1,0x0,0x1a,0x8);
+    osSerdes2Write(0x1,0x0,0x1b,0x78);
+    osSerdes2Write(0x1,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x2,0x0,0x18,0x0);
+    osSerdes2Write(0x2,0x0,0x19,0x0);
+    osSerdes2Write(0x2,0x0,0x1a,0x8);
+    osSerdes2Write(0x2,0x0,0x1b,0x78);
+    osSerdes2Write(0x2,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x3,0x0,0x18,0x0);
+    osSerdes2Write(0x3,0x0,0x19,0x0);
+    osSerdes2Write(0x3,0x0,0x1a,0x8);
+    osSerdes2Write(0x3,0x0,0x1b,0x78);
+    osSerdes2Write(0x3,0x0,0x1c,0x0);
+
+    osSerdes2Write(0x4,0x0,0x53,0x2);
+    osSerdesWait(0x1000000);
+    // 11.  TXIODRIVER setting
+    //TXIODRIVER.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //21[2:0]   TXDRV_HLEV  7   7
+    //21[7:3]   TXDRV_LEVN  7   1b
+    //22[3:0]   TXDRV_LEVNM1    7   0
+    //22[5:4]   TXDRV_LEVNM2    7   0
+    //23[2:0]   TXDRV_LEVNP1    7   0
+    //23[4:3]   TXDRV_SLEW  7   0
+    osSerdes2Write(0x0,0x0,0x15,0xdf);
+    osSerdes2Write(0x0,0x0,0x16,0x0);
+    osSerdes2Write(0x0,0x0,0x17,0x0);
+
+    osSerdes2Write(0x1,0x0,0x15,0xdf);
+    osSerdes2Write(0x1,0x0,0x16,0x0);
+    osSerdes2Write(0x1,0x0,0x17,0x0);
+
+    osSerdes2Write(0x2,0x0,0x15,0xdf);
+    osSerdes2Write(0x2,0x0,0x16,0x0);
+    osSerdes2Write(0x2,0x0,0x17,0x0);
+
+    osSerdes2Write(0x3,0x0,0x15,0xdf);
+    osSerdes2Write(0x3,0x0,0x16,0x0);
+    osSerdes2Write(0x3,0x0,0x17,0x0);
+    osSerdesWait(0x1000000);
+    // 12.  Change Data Width to 10 bits
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //5[6:4]    PCSTX_DATAWIDTH 7   1
+    //5[2:0]    PCSRX_DATAWIDTH 7   1
+    osSerdes2Write(0x0,0x0,0x5,0x11);
+    osSerdes2Write(0x1,0x0,0x5,0x11);
+    osSerdes2Write(0x2,0x0,0x5,0x11);
+    osSerdes2Write(0x3,0x0,0x5,0x11);
+    osSerdesWait(0x1000000);
+    // 13.  Change DIVRATE
+    //RXPCSDATARATE_DIV1.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[2:0]    PCSRX_DIVRATE   7   3
+    //TXPCSDATARATE_DIV1.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //6[6:4]    PCSTX_DIVRATE   7   3
+    osSerdes2Write(0x0,0x0,0x6,0x33);
+    osSerdes2Write(0x1,0x0,0x6,0x33);
+    osSerdes2Write(0x2,0x0,0x6,0x33);
+    osSerdes2Write(0x3,0x0,0x6,0x33);
+    osSerdesWait(0x1000000);
+    // 15.  Enable PCS TX
+    //CMNPCS_TXENABLE.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //8[2:2]    CMNPCS_TXENABLE 4   1
+    osSerdes2Write(0x4,0x0,0x8,0x54);
+    osSerdesWait(0x1000000);
+
+    // 16.  Overwrite Enable for Lock2Ref
+    //RXLOCK2REF_OVREN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //39[1:1]   RXLOCK2REF_OVREN    7   1
+    osSerdes2Write(0x0,0x0,0x27,0x2);
+    osSerdes2Write(0x1,0x0,0x27,0x2);
+    osSerdes2Write(0x2,0x0,0x27,0x2);
+    osSerdes2Write(0x3,0x0,0x27,0x2);
+    osSerdesWait(0x1000000);
+    // 17.  Power Up to P0
+    //PCSPSTATE_P0.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+    //3[4:0]    LANEPCSPSTATE_RX    7   10
+    //3[4:0]    CMNPCSPSTATE_SYNTH  4   10
+    //4[4:0]    LANEPCSPSTATE_TX    7   10
+    osSerdes2Write(0x0,0x0,0x3,0x10);
+    osSerdes2Write(0x0,0x0,0x4,0x10);
+
+    osSerdes2Write(0x1,0x0,0x3,0x10);
+    osSerdes2Write(0x1,0x0,0x4,0x10);
+
+    osSerdes2Write(0x2,0x0,0x3,0x10);
+    osSerdes2Write(0x2,0x0,0x4,0x10);
+
+    osSerdes2Write(0x3,0x0,0x3,0x10);
+    osSerdes2Write(0x3,0x0,0x4,0x10);
+
+    osSerdes2Write(0x4,0x0,0x3,0x10);
+    osSerdesWait(0x1000000);
+    // 18.  Read out critical status registers
+    //PCSOUTTX_READY    7   11[2:2]     r   expected: 1
+    //PCSOUTRX_READY    7   11[0:0]     r   expected: 1
+    osSerdes2Read(0x0,0x0,11);
+    osSerdes2Read(0x1,0x0,11);
+    osSerdes2Read(0x2,0x0,11);
+    osSerdes2Read(0x3,0x0,11);
+    osSerdesWait(0x1000000);
+    //the initialization is finished
+    //*********************************************************
+
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSrio10g3125
+输入参数    :   None
+输出参数      :
+Description   :  macro2   Lane0~3初始化为Srio 10.3125G
+Author        :  z00228490
+Creation time :  2012/12/29
+*****************************************************************/
+UINT32 osSerdes2InitSrio10g3125(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl1_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载6.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0xa );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0xa );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0xe );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0xe );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0xa );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0xa );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0xe );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0xe );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0x9c );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b010, bit28-26=3'b010,*/
+    /*bit25-23=3'b010,bit22-20=3b010,bit19-17=3b010,bit16-14=3b010,*/
+    /*bit13-11=3b010,bit10-8=3b010,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x492492FF, 0x492492FF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b011,*/
+    /*bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,bit11-9=3'b011,*/
+    /*bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x6DB6DB, 0x6DB6DB );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0xFFC00, 0xffffffff );
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitPcie2g5
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitPcie2g5(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19=1,bit18-15=all 1,bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xF8000, 0xFFFF83FF );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_100MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x13 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xa6 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-15=all 1, bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0xF8000, 0xFFFF83FF );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitPcie5g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitPcie5g(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19=1,bit18-15=all 1,bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xF8000, 0xFFFF83FF );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_100MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x8 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x13 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x31 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x13 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xa6 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-15=all 1, bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0xF8000, 0xFFFF83FF );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes2InitPcie8g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitPcie8g(void)
+{
+    //UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19=1,bit18-15=all 1,bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xF8000, 0xFFFF83FF );
+
+    /*3、设置模式为pcie-mode*/
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x800, 0xFFFFFFFF );
+
+    /*配置pcie controller 这是控制器配置可问冯海/刘君龙*/
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*加载PCIe_100MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x5 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x33 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x33 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x33 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xbf );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x33 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xbf );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x22 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xc4 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x0 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-15=all 1, bit14-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0xF8000, 0xFFFF83FF );
+
+    /*等待pcie linkup*/
+
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSataHostAuto
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitSataHostAuto(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[ioctrl1_base_addr+0x14],data[bit31-24=all 0,bit23-0=24'h249249]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x249249, 0x249249 );
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-8=24'h249249,bit7-0=all 0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x24924900, 0x24924900 );
+    /*Addr[ioctrl1_base_addr+0x30],data[bit27-24=all 0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x30, 0x0, 0xF0FFFFFF );
+
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+
+    /*Addr[sysctrl_base_addr+0x600],data[bit17-16=2'b11]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x600, 0x30000, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0x8],data[bit0=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x8, 0x0, 0xFFFFFFFE );
+
+    /*Addr[sysctrl_base_addr+0x310],data[bit1-0=2'b00]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x310, 0x0, 0xFFFFFFFC );
+
+    /*Addr[sysctrl_base_addr+0x314],data[bit1-0=2'b11]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x314, 0x3, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0x80000, 0xFFF803FF );
+
+    osSerdesWait( 1000 );
+
+    /*SATA_100MHz_VSM.txt*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c], data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0xFFC00, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],等待bit11-4全部为1，即为等到ready*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+
+    /*Addr[ioctrl1_base_addr+0x8],data[bit0=1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x8, 0x1, 0xFFFFFFFF );
+
+    /*Addr[sysctrl_base_addr+0x604],data[bit17-16=2'b11]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x604, 0x30000, 0xFFFFFFFF );
+
+    /*Addr[sysctrl_base_addr+0x310],data[bit1-0=2'b11]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x310, 0x3, 0xFFFFFFFF );
+
+    /*Addr[sysctrl_base_addr+0x314],data[bit1-0=2'b00]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x314, 0x0, 0xFFFFFFFC );
+
+    /*Addr[ioctrl1_base_addr+0x0],data[bit15-12=4'b1,bit11-8=4'b1,bit7-4=4'b1,bit3-0=4'b1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x0, 0x1111, 0xFFFF1111 );
+
+    /*开始配置SATA控制器*/
+
+
+
+    return OS_SUCCESS;
+
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSata1g5
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitSata1g5(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0x80000, 0xFFF803FF );
+
+    osSerdesWait( 0x1000 );
+    /*SATA_100MHz_VSM.txt*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b001, bit28-26=3'b001,*/
+    /*bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,bit16-14=3b001,*/
+    /*bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b001,*/
+    /*bit20-18=3'b001,bit17-15=3'b001,bit14-12=3'b001,bit11-9=3'b001,*/
+    /*bit8-6=3'b001,bit5-3=3'b001,bit2-0=3'b001]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x249249, 0x249249 );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c], data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0xFFC00, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSata3g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitSata3g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0x80000, 0xFFF803FF );
+
+    osSerdesWait( 0x1000 );
+    /*SATA_100MHz_VSM.txt*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b011, bit28-26=3'b011,*/
+    /*bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,bit16-14=3b011,*/
+    /*bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b010,*/
+    /*bit20-18=3'b010,bit17-15=3'b010,bit14-12=3'b010,bit11-9=3'b010,*/
+    /*bit8-6=3'b010,bit5-3=3'b010,bit2-0=3'b010]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x492492, 0x492492 );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c], data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0xFFC00, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2InitSata6g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes2InitSata6g(void)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0x80000, 0xFFF803FF );
+
+    osSerdesWait( 0x1000 );
+    /*SATA_100MHz_VSM.txt*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xc9 );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0x7 );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x18 );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x1 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x22 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0xaa );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x45 );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xc9 );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x18 );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xcf );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf7 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xe1 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xe3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xe7 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xdb );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfd );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xf5 );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x32 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x1 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xb0 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b011, bit28-26=3'b011,*/
+    /*bit25-23=3'b011,bit22-20=3b011,bit19-17=3b011,bit16-14=3b011,*/
+    /*bit13-11=3b011,bit10-8=3b011,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x6DB6DBFF, 0x6DB6DBFF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b011,*/
+    /*bit20-18=3'b011,bit17-15=3'b011,bit14-12=3'b011,bit11-9=3'b011,*/
+    /*bit8-6=3'b011,bit5-3=3'b011,bit2-0=3'b011]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x6DB6DB, 0x6DB6DB );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x58c], data[bit19=1,bit18-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58C, 0xFFC00, 0xFFFFFFFF );
+
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+    while ( ( ulValue != 0xFF0 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+        ulValue = ulValue & 0xFF0;
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes3InitSrio1g25
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitSrio1g25(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[serdes3_base_addr+0x4],data[bit8=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x0, 0xFFFFFEFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b10]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b10]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x90, 0xFFFFFF97 );
+    }
+    /*Addr[serdes3_base_addr+0x100],data[bit12-8=5'h1,bit23-16=8'd16]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x100, 0x100100, 0xFF10E1FF );
+    /*Addr[serdes3_base_addr+0x108],data[bit31-24=8'h7]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x108, 0x7000000, 0x7FFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 1000000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && (-- ulWaitTime ) )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    osSerdesWait( 1000000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes3InitSrio2g5
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitSrio2g5(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[serdes3_base_addr+0x4],data[bit8=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x0, 0xFFFFFEFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+    }
+    /*Addr[serdes3_base_addr+0x100],data[bit12-8=5'h1,bit23-16=8'd20]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x100, 0x140100, 0xFF14E1FF );
+    /*Addr[serdes3_base_addr+0x108],data[bit31-24=8'h7]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x108, 0x7000000, 0x7FFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes3InitSrio3g125
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitSrio3g125(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[serdes3_base_addr+0x4],data[bit8=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x0, 0xFFFFFEFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x88, 0xFFFFFF8F );
+    }
+    /*Addr[serdes3_base_addr+0x100],data[bit12-8=5'h1,bit23-16=8'd25]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x100, 0x190100, 0xFF19E1FF );
+    /*Addr[serdes3_base_addr+0x108],data[bit31-24=8'h6]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x108, 0x6000000, 0x6ffffff );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes3InitSrio5g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitSrio5g(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[serdes3_base_addr+0x4],data[bit8=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x0, 0xFFFFFEFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x80, 0xFFFFFF87 );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x80, 0xFFFFFF87 );
+    }
+    /*Addr[serdes3_base_addr+0x100],data[bit12-8=5'h2,bit23-16=8'd40]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x100, 0x280200, 0xFF28E2FF );
+    /*Addr[serdes3_base_addr+0x108],data[bit31-24=8'h7]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x108, 0x7000000, 0x7ffffff );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes3InitSrio6g25
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitSrio6g25(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[serdes3_base_addr+0x4],data[bit8=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x0, 0xFFFFFEFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81c + 0x80 * ulLoop, 0x80, 0xFFFFFF87 );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b10,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82c + 0x80 * ulLoop, 0x80, 0xFFFFFF87 );
+    }
+    /*Addr[serdes3_base_addr+0x100],data[bit12-8=5'h2,bit23-16=8'd50]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x100, 0x320200, 0xFF32E2FF );
+    /*Addr[serdes3_base_addr+0x108],data[bit31-24=8'h6]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x108, 0x6000000, 0x6ffffff );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes3InitPcie2g5
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitPcie2g5(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0 , 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x590, 0x0 , 0xFFF7FFFF );
+    osSerdesWait( 0x100 );
+
+    /*Addr[serdes3_base_addr+0x4],data[bit8=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x100, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81C + 0x80 * ulLoop, 0x8 , 0xFFFFFF0F );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82C + 0x80 * ulLoop, 0x8 , 0xFFFFFF0F );
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11 , 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000 , 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes3InitPcie5g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitPcie5g(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0 , 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0 , 0xFFF7FFFF );
+
+    osSerdesWait( 0x10000000 );
+
+    /*Addr[serdes3_base_addr+0x4],data[bit8=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x100, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81C + 0x80 * ulLoop, 0x8 , 0xFFFFFF0F );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82C + 0x80 * ulLoop, 0x8 , 0xFFFFFF0F );
+    }
+    osSerdesWait( 0x10000000 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x10000000 );
+
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x10000000 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11 , 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000 , 0xFFFFFFFF );
+
+    osSerdesWait( 0x10000000 );
+
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes3InitPcieS2g5
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitPcieS2g5(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0 , 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x590, 0x0 , 0xFFF7FFFF );
+    osSerdesWait( 0x100 );
+
+    /*Addr[serdes3_base_addr+0x4],data[bit8=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x100, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81C + 0x80 * ulLoop, 0x8 , 0xFFFFFF17 );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b01]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82C + 0x80 * ulLoop, 0x8 , 0xFFFFFF17 );
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11 , 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000 , 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes3InitPcieS5g
+输入参数    :   None
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes3InitPcieS5g(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = SERDES_WART_TIME;
+    //UINT32 ulRet = OS_SUCCESS;
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0 , 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x590, 0x0 , 0xFFF7FFFF );
+    osSerdesWait( 0x100 );
+
+    /*Addr[serdes3_base_addr+0x4],data[bit8=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x4, 0x100, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x81c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x81C + 0x80 * ulLoop, 0x0 , 0xFFFFFF07 );
+    }
+    /*Addr[serdes3_base_addr+0x82c+0x80*0~3],data[bit7-6=2b00,bit5-3=3b00]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x82C + 0x80 * ulLoop, 0x0 , 0xFFFFFF07 );
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+    osSerdesWait( 0x1000 );
+
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x100 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFFFFFFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 3; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11 , 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000 , 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000 , 0xFFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes0ComCfg
+输入参数    :   None
+输出参数      :
+Description   :  serdes0 通用配置
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes0ComCfg(void)
+{
+    //UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    //INT32 ulWaitTime = SERDES_WART_TIME;
+
+    /*1、等待芯片AXI总线复位*/
+    /*2、复位CMU/EOM/DIG，以及相应TX/RX通道*/
+    osSerdesWait(0x100000);
+    /*Addr[sysctrl_base_addr+0x580],data[bit24-0=all 1]*/
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_REQ0_REG,0x1ffffff,0xffffffff);
+
+    /*Addr[sysctrl_base_addr+0x590],data[bit7-0= all 1]*/
+    osSerdesBitWrite(SRE_SC_SERDES_RESET_REQ2_REG,0x1ffffff,0xffffffff);
+
+    /*3、置位chx_fifo_rst_n  chx_bist_rst_n  jtf_rst_n  imp_rst_n*/
+    for ( ulLoop  = 0 ; ulLoop < 4 ; ulLoop++ )
+    {
+        /*Addr[serdes0_low_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+        osSerdesWrite( SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulLoop,0, 0xFFFFFFEE, 1 );
+    }
+    for ( ulLoop  = 0 ; ulLoop < 4 ; ulLoop++ )
+    {
+        /*Addr[serdes0_high_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+        osSerdesWrite( SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulLoop,0, 0xFFFFFFEE, 1 );
+    }
+
+    /*Addr[serdes0_low_base_addr+0x144],data[bit19=0]*/
+    osSerdesWrite( SERDES0_LOW_BASE_ADDR + 0x144, 0, 0xFFF7FFFF, 1 );
+    /*Addr[serdes0_hight_base_addr+0x144],data[bit19=0]*/
+    osSerdesWrite( SERDES0_HIGHT_BASE_ADDR + 0x144, 0, 0xFFF7FFFF, 1 );
+
+    /*Addr[serdes0_low_base_addr+0x0],data[bit29=0]*/
+    osSerdesWrite( SERDES0_LOW_BASE_ADDR, 0, 0xDFFFFFFF, 1 );
+    /*Addr[serdes0_high_base_addr+0x0],data[bit29=0]*/
+    osSerdesWrite( SERDES0_HIGHT_BASE_ADDR, 0, 0xDFFFFFFF, 1 );
+
+    /*4、等待100ns*/
+    osSerdesWait( 0x100000 );
+
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes0WaitForPllCfg
+输入参数    :   None
+输出参数      :
+Description   :  serdes0 线速配置之后的通用配置
+                    等待复位撤离信号
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes0WaitForPllCfg(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    volatile INT32 ulWaitTime = SERDES_WART_TIME;
+    /*撤离CMU复位*/
+    /*Addr[sysctrl_base_addr+0x584],data[bit24=1,bit23-0= all 0]*/
+    /*Addr[sysctrl_base_addr+0x594],data[bit7-0= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x584, 0x1ffffff, 0xFFffffff );
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1ffffff, 0xFFffffff );
+
+    /*等待1ms*/
+    osSerdesWait( 0x10000000);
+
+    /*等待pll lock*/
+    /*Addr[ioctrl0_base_addr+0x400],data[bit9-8=2’b11, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x400, 0 );
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL0_BASE_ADDR + 0x400 == 0x300\n" );
+
+#else
+    SRE_printf( "ulValue = %#x == 0x300\n",ulValue );
+    while (-- ulWaitTime )
+    {
+        if(0x300 != ( ulValue & 0x300 ))
+        {
+            ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x400, 0 );
+        }
+        else
+        {
+            break;
+        }
+    }
+    if ( ulWaitTime <= 0 )
+    {
+		SRE_printf( "ulValue = %#x == 0x300\n",ulValue );
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+
+#endif
+    /*等待100ns*/
+    osSerdesWait( 0x10000 );
+
+    /*复位撤离，chx_fifo_rst_n  chx_bist_rst_n   jtf_rst_n  imp_rst_n*/
+    /*Addr[serdes0_low_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    /*Addr[serdes0_high_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    /*Addr[serdes0_low_base_addr+0x144],data[bit19=1]*/
+    /*Addr[serdes0_high_base_addr+0x144],data[bit19=1]*/
+    /*Addr[serdes0_low_base_addr+0x0],data[bit29=1]*/
+    /*Addr[serdes0_high_base_addr+0x0],data[bit29=1]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop ++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xffffffff );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xffffffff );
+    }
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x144, 0x80000, 0xffffffff );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x144, 0x80000, 0xffffffff );
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x0, 0x20000000, 0xffffffff );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x0, 0x20000000, 0xffffffff );
+
+    /*等1ms 可以收发数据了*/
+    osSerdesWait( 0x1000000 );
+
+    return OS_SUCCESS;
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdesWrite
+输入参数    :  ulAddr   寄存器地址
+              ulIndex   下标
+              ulMask   掩码
+              ulType   0 为与1为或
+输出参数      :
+Description   :  修改其中某几比特
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdesWrite( UINT32 ulAddr, UINT32 ulIndex, UINT32 ulMask, UINT32 ulType )
+{
+    UINT32 ulValue = 0;
+
+    ulValue = OS_READ_REG( ulAddr, ulIndex );
+
+    if ( !ulType )
+    {
+        OS_SDS_WRITE_REG( ulAddr, ulIndex, ulValue | ulMask );
+    }
+    else
+    {
+        OS_SDS_WRITE_REG( ulAddr, ulIndex, ulValue & ulMask );
+    }
+    return OS_SUCCESS;
+    /*回读*/
+}
+
+/*****************************************************************
+函数名 :  osSerdesBitWrite
+输入参数    :  ulAddr
+              ulOrMask  置1掩码
+              ulAndMask 置0掩码
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+void osSerdesBitWrite( UINT32 ulAddr, UINT32 ulOrMask, UINT32 ulAndMask )
+{
+    UINT32 ulValue = 0;
+    ulValue = OS_READ_REG( ulAddr, 0 );
+    ulValue = ( ulValue | ulOrMask ) & ulAndMask;
+    OS_SDS_WRITE_REG( ulAddr, 0, ulValue );
+}
+
+
+/*****************************************************************
+函数名 :  osSerdesWait
+输入参数    :  ulLoop
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+void osSerdesWait( volatile UINT32 ulLoop )
+{
+    while ( ulLoop -- )
+    {
+        ;
+    }
+}
+
+UINT32 SRE_SetSerdes0LowRdOn(UINT32 ulLaneMask)
+{
+    UINT32 ulValue = 0x0;
+    for(ulValue = 0;ulValue < 0x4;ulValue ++)
+    {
+        if((0x1 << ulValue) & ulLaneMask)
+        {
+            OS_SDS_WRITE_REG(SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulValue, 0x0, 0x17);
+        }
+    }
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SetSerdes0LowRdOff(UINT32 ulLaneMask)
+{
+    UINT32 ulValue = 0x0;
+    for(ulValue = 0;ulValue < 0x4;ulValue ++)
+    {
+        if((0x1 << ulValue) & ulLaneMask)
+        {
+            OS_SDS_WRITE_REG(SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulValue, 0x0, 0x11);
+        }
+    }
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SetSerdes0HighRdOn(UINT32 ulLaneMask)
+{
+    UINT32 ulValue = 0x0;
+    for(ulValue = 0;ulValue < 0x4;ulValue ++)
+    {
+        if((0x1 << ulValue) & ulLaneMask)
+        {
+            OS_SDS_WRITE_REG(SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulValue, 0x0, 0x17);
+        }
+    }
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SetSerdes0HighRdOff(UINT32 ulLaneMask)
+{
+    UINT32 ulValue = 0x0;
+    for(ulValue = 0;ulValue < 0x4;ulValue ++)
+    {
+        if((0x1 << ulValue) & ulLaneMask)
+        {
+            OS_SDS_WRITE_REG(SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulValue, 0x0, 0x11);
+        }
+    }
+    return OS_SUCCESS;
+}
+UINT32 SRE_SetSerdes1RdOn(void)
+{
+     //the initialization is finished
+    //*********************************************************
+
+// 21.  Enable LB
+//LB_TX2RXBUFTIMEDEN.memcfg
+//Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane) Value
+//13[2:2]LB_SYNTHPLLFBCLK2CDRREFCLKEN   4   0
+//13[1:1]LB_SYNTHCDRDIVCLK2TXEN     4   0
+//7[1:1]    LB_CDRDIVCLK2EXTEN      7   0
+//7[0:0]    LB_CDRCLK2TXEN          7   0
+//7[5:5]    LB_TX2RXBUFTIMEDEN      7   0
+//7[6:6]    LB_TX2RXIOTIMEDEN       7   1
+//7[7:7]    LB_PARRX2TXTIMEDEN      7   0
+//7[4:4]    LB_RX2TXUNTIMEDEN       7   0
+//7[2:2]    LB_CDRDIVCLK2TXEN       7   0
+//7[3:3]    LB_PLLFBCLK2CDRREFCLKEN     7   0
+//85[1:1]   LB_LOCWREN      7   0
+//osSerdes1Write (0x0,0x0,0x7,0x40);
+//jaki suggestion
+osSerdes1Write (0x0,0x0,0x7,0x20);
+osSerdes1Write (0x0,0x0,0x55,0x4c);
+osSerdes1Write (0x1,0x0,0x7,0x20);
+osSerdes1Write (0x1,0x0,0x55,0x4c);
+osSerdes1Write (0x2,0x0,0x7,0x20);
+osSerdes1Write (0x2,0x0,0x55,0x4c);
+osSerdes1Write (0x3,0x0,0x7,0x20);
+osSerdes1Write (0x3,0x0,0x55,0x4c);
+osSerdes1Write (0x4,0x0,0xd,0x10);
+
+    return OS_SUCCESS;
+}
+
+UINT32 SRE_SetSerdes2RdOn(void)
+{
+     //the initialization is finished
+    //*********************************************************
+
+    // 21.  Enable LB
+    //LB_TX2RXBUFTIMEDEN.memcfg
+    //Address   RegisterName    LaneIdentifier(7:singleLane; 4: commonLane);    Value
+    //13[2:2]LB_SYNTHPLLFBCLK2CDRREFCLKEN   4   0
+    //13[1:1]LB_SYNTHCDRDIVCLK2TXEN     4   0
+    //7[1:1]    LB_CDRDIVCLK2EXTEN      7   0
+    //7[0:0]    LB_CDRCLK2TXEN          7   0
+    //7[5:5]    LB_TX2RXBUFTIMEDEN      7   0
+    //7[6:6]    LB_TX2RXIOTIMEDEN       7   1
+    //7[7:7]    LB_PARRX2TXTIMEDEN      7   0
+    //7[4:4]    LB_RX2TXUNTIMEDEN       7   0
+    //7[2:2]    LB_CDRDIVCLK2TXEN       7   0
+    //7[3:3]    LB_PLLFBCLK2CDRREFCLKEN     7   0
+    //85[1:1]   LB_LOCWREN      7   0
+    //osSerdes2Write (0x0,0x0,0x7,0x40);
+    //jaki suggestion
+    osSerdes2Write (0x0,0x0,0x7,0x20);
+    osSerdes2Write (0x0,0x0,0x55,0x4c);
+    osSerdes2Write (0x1,0x0,0x7,0x20);
+    osSerdes2Write (0x1,0x0,0x55,0x4c);
+    osSerdes2Write (0x2,0x0,0x7,0x20);
+    osSerdes2Write (0x2,0x0,0x55,0x4c);
+    osSerdes2Write (0x3,0x0,0x7,0x20);
+    osSerdes2Write (0x3,0x0,0x55,0x4c);
+    osSerdes2Write (0x4,0x0,0xd,0x10);
+
+    return OS_SUCCESS;
+}
+
+/*===================封装的debug 函数接口函数=============*/
+
+#define SERDES1   (0x1)
+#define SERDES2    (0x2)
+UINT32 osSerdesVsemiTxDriverWrite(
+                                        UINT32 ulSdsx,
+                                        UINT32 ulLanex,
+                                        UINT32 ulHlev,
+                                        UINT32 ulLevn,
+                                        UINT32 levnm1,
+                                        UINT32 levnm2,
+                                        UINT32 levnp1,
+                                        UINT32 slew
+)
+{
+    UINT32 ulValue = 0;
+
+    SRE_printf("VsemiTxDriverWrite:sdsx= %s,lanex=%d\n",
+                    ulSdsx == SERDES1?"serdes1":"serdes2",ulLanex);
+        /*如果sdsx=sds1, Macro1_rd(lanex,0x0,0x57),bit4=0回写*/
+        /*如果sdsx=sds2, Macro2_rd(lanex,0x0,0x57),bit4=0回写*/
+    if(ulSdsx == SERDES1)
+    {
+        ulValue = osSerdes1Read(ulLanex,0x0,0x57);
+        osSerdes1Write(ulLanex,0,0x57,ulValue & 0xffffffef);
+        /*macro1_rd(lanex,0x0,0x15);bit2-0=hlev,bit7-3=levn,回写*/
+        /*macro1_rd(lanex,0x0,0x16);bit3-0=levnm1,bit5-4=levnm2,回写*/
+        /*macro1_rd(lanex,0x0,0x17);bit2-0=levnp1,bit4-3=slew,回写*/
+        ulValue = 0x0;//osSerdes1Read(ulLanex,0x0,0x15);
+        ulValue = ( (ulHlev&0x7))  |
+                    (((ulLevn & 0x1f)<<0x3));
+        osSerdes1Write(ulLanex,0x0,0x15,ulValue);
+
+        ulValue = 0x0;//osSerdes1Read(ulLanex,0x0,0x16);
+        ulValue = ( (levnm1&0xF))  |
+                    ( ((levnm2 & 0x3)<<0x4));
+        osSerdes1Write(ulLanex,0x0,0x16,ulValue);
+
+        ulValue = 0x0;//osSerdes1Read(ulLanex,0x0,0x17);
+        ulValue = ( (levnp1&0x7))  |
+                    ( ((slew & 0x3)<<0x3));
+        osSerdes1Write(ulLanex,0x0,0x17,ulValue);
+
+
+    }
+    else
+    {
+        ulValue = osSerdes2Read(ulLanex,0x0,0x57);
+        osSerdes2Write(ulLanex,0,0x57,ulValue & 0xffffffef);
+
+        ulValue = osSerdes2Read(ulLanex,0x0,0x57);
+        osSerdes2Write(ulLanex,0,0x57,ulValue & 0xffffffef);
+        /*macro1_rd(lanex,0x0,0x15);bit2-0=hlev,bit7-3=levn,回写*/
+        /*macro1_rd(lanex,0x0,0x16);bit3-0=levnm1,bit5-4=levnm2,回写*/
+        /*macro1_rd(lanex,0x0,0x17);bit2-0=levnp1,bit4-3=slew,回写*/
+        ulValue = 0x0;//osSerdes2Read(ulLanex,0x0,0x15);
+        ulValue = ( (ulHlev&0x7))  |
+                    (((ulLevn & 0x1f)<<0x3));
+        osSerdes2Write(ulLanex,0x0,0x15,ulValue);
+
+        ulValue = 0x0;//osSerdes2Read(ulLanex,0x0,0x16);
+        ulValue = ( (levnm1&0xF))  |
+                    ( ((levnm2 & 0x3)<<0x4));
+        osSerdes2Write(ulLanex,0x0,0x16,ulValue);
+
+        ulValue = 0x0;//osSerdes2Read(ulLanex,0x0,0x17);
+        ulValue = ( (levnp1&0x7))  |
+                    ( ((slew & 0x3)<<0x3));
+        osSerdes2Write(ulLanex,0x0,0x17,ulValue);
+    }
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdesVsemiTxDriverRead(UINT32 sdsx,UINT32 lanex)
+{
+    UINT32 ulValue = 0;
+    SRE_printf("VsemiTxDriverRead:sdsx= %s,lanex=%d\n",
+                    sdsx == SERDES1?"serdes1":"serdes2",lanex);
+    if(sdsx == SERDES1)
+    {
+        ulValue = osSerdes1Read(lanex,0x0,0x57);
+        osSerdes1Write(lanex,0,0x57,ulValue & 0xffffffef);
+
+        /*macro1_rd(lanex,0x0,0x15); hlev= bit2-0, levn= bit7-3*/
+        /*macro1_rd(lanex,0x0,0x16); levnm1=bit3-0, levnm2= bit5-4*/
+        /*macro1_rd(lanex,0x0,0x17); levnp1=bit2-0, slew=bit4-3*/
+        ulValue = osSerdes1Read(lanex,0x0,0x15);
+        SRE_printf("ulValue = 0x%08x,hlev = 0x%08x,levn = 0x%08x\n",ulValue,ulValue & 0x7,(ulValue &0xF8) >> 0x3 );
+        ulValue = osSerdes1Read(lanex,0x0,0x16);
+        SRE_printf("ulValue = 0x%08x,levnm1 = 0x%08x,levnm2 = 0x%08x\n",ulValue,ulValue & 0xf,(ulValue &0x30) >> 0x4 );
+        ulValue = osSerdes1Read(lanex,0x0,0x17);
+        SRE_printf("ulValue = 0x%08x,levnp1 = 0x%08x,slew = 0x%08x\n",ulValue,ulValue & 0x7,(ulValue &0x18) >> 0x3 );
+
+
+    }
+    else
+    {
+        ulValue = osSerdes2Read(lanex,0x0,0x57);
+        osSerdes2Write(lanex,0,0x57,ulValue & 0xffffffef);
+
+        /*macro1_rd(lanex,0x0,0x15); hlev= bit2-0, levn= bit7-3*/
+        /*macro1_rd(lanex,0x0,0x16); levnm1=bit3-0, levnm2= bit5-4*/
+        /*macro1_rd(lanex,0x0,0x17); levnp1=bit2-0, slew=bit4-3*/
+        ulValue = osSerdes2Read(lanex,0x0,0x15);
+        SRE_printf("ulValue = 0x%08x,hlev = 0x%08x,levn = 0x%08x\n",ulValue,ulValue & 0x7,(ulValue &0xF8) >> 0x3 );
+        ulValue = osSerdes2Read(lanex,0x0,0x16);
+        SRE_printf("ulValue = 0x%08x,levnm1 = 0x%08x,levnm2 = 0x%08x\n",ulValue,ulValue & 0xf,(ulValue &0x30) >> 0x4 );
+        ulValue = osSerdes2Read(lanex,0x0,0x17);
+        SRE_printf("ulValue = 0x%08x,levnp1 = 0x%08x,slew = 0x%08x\n",ulValue,ulValue & 0x7,(ulValue &0x18) >> 0x3 );
+
+    }
+
+     return OS_SUCCESS;
+}
+
+UINT32 osSerdes1PmaBistOnNormal(UINT32 ulLane,UINT32 ulPrbsPatten,UINT32 LpMode)
+{
+    //UINT32 ulRet = OS_SUCCESS;
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 1000000;
+    /*配置prbs pattern和 on-chip loopback*/
+    /*Macro1_rd(3'h4,1'h0,12'h5f,data[7:0]);data[4:4]=0,回写*/
+    ulData = osSerdes1Read(0x4,0x0,0x5f);
+    ulData &= 0xffffffef;
+    osSerdes1Write(0x4,0x0,0x5f,ulData);
+
+    /*Macro1_rd(3'h4,1'h0,12'h50,data[7:0]);data[2:0]=x2[2:0]*/
+    ulData = osSerdes1Read(0x4,0x0,0x50);
+    ulData = (ulData & 0xfffffff8 ) | ulPrbsPatten;
+    osSerdes1Write(0x4,0x0,0x5f,ulData);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0,回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulData = (ulData & 0xfffffffd );
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*环回*/
+    osSerdes1PmaLp(ulLane, LpMode);
+
+    /*Enable p0 state*/
+    /*Macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[0:0]=0,回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulData &= 0xFFFFFFFE;
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h3,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x3);
+    ulData = (ulData | 0x10)  & 0xFFFFFFF0;
+    osSerdes1Write(ulLane & 0x7,0x0,0x3,ulData);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h4,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x4);
+    ulData = (ulData | 0x10)  & 0xFFFFFFF0;
+    osSerdes1Write(ulLane & 0x7,0x0,0x4,ulData);
+
+    /*3.开启PMA BIST*/
+    /*macro1_rd(x1[2:0],1'h0,12'h56,data[7:0])，data[0:0]=0,回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x56);
+    ulData = (ulData )  & 0xFFFFFFFE;
+    osSerdes1Write(ulLane & 0x7,0x0,0x56,ulData);
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1; 回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulData = (ulData )  | 0x2;
+    osSerdes1Write(ulLane & 0x7,0x0,0x8,ulData);
+
+    /*等待CDR锁定 register-based*/
+    /*macro1_rd(x1[2:0], 1'h0,12'h28,data[7:0]);data[5:5]=1'b1;data[6:6] =1'b0;回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x28);
+    ulData = (ulData  | 0x20 ) & 0xFFFFFFBF;
+    osSerdes1Write(ulLane & 0x7,0x0,0x28,ulData);
+
+    /*等待macro1_rd(x1[2:0], 1'h0,12'hB,data[7:0]);直到data[5:5]==1*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0xB);
+    while(0x20 != (ulData & 0x20) && ulWaitTime -- )
+    {
+        ulData = osSerdes1Read(ulLane & 0x7,0x0,0xB);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("cdr didn't lock at LINE[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    /*开始PMA BIST receiver检查*/
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[5:5]=0;回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulData = (ulData  ) & 0xFFFFFFDF;
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1;回写*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulData = (ulData  | 0x2);
+    osSerdes1Write(ulLane & 0x7,0x0,0x8,ulData);
+
+    /*等待symbol lock*/
+    /*一直进行macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[4:4]=1'b1;*/
+    ulData = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulWaitTime = 1000000;
+    while(0x10 != (ulData & 0x10) && ulWaitTime --)
+    {
+        ulData = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("symbol lock over time at line[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdes1PmaBistOnReset(UINT32 ulLane,UINT32 ulPrbsPatten,UINT32 ulLpMode)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = 50000000;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit9-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0x3FF, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl0_base_addr+0x60],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x60, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x200, 0xFFFFFE00 );
+
+    /*等待500ns*/
+    osSerdesWait( 500 );
+
+    /*加载1.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes1Write( 0x0, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x0, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x0, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x1, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x1, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x1, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x1, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x1, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x2, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x2, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x2, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x2, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x2, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x3, 0x0, 0x65, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x66, 0xb7 );
+    osSerdes1Write( 0x3, 0x0, 0x67, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x68, 0xc );
+    osSerdes1Write( 0x3, 0x0, 0x69, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6a, 0x1a );
+    osSerdes1Write( 0x3, 0x0, 0x6b, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6c, 0x2 );
+    osSerdes1Write( 0x3, 0x0, 0x6d, 0x11 );
+    osSerdes1Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes1Write( 0x4, 0x0, 0x65, 0x99 );
+    osSerdes1Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes1Write( 0x4, 0x0, 0x68, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x69, 0xb7 );
+    osSerdes1Write( 0x4, 0x0, 0x6a, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6b, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x6c, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6d, 0x1a );
+    osSerdes1Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes1Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes1Write( 0x4, 0x0, 0x70, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x72, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes1Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes1Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes1Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes1Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes1Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes1Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes1Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes1Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes1Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes1Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x99, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9a, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes1Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes1Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes1Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes1Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes1Write( 0x4, 0x0, 0x37, 0xb4 );
+    osSerdes1Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes1Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes1Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes1Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes1Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes1Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes1Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes1Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes1Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes1Write( 0x3, 0x0, 0x2bd, 0x0 );
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl0_base_addr+0x64],data[bit31-29=3'b001,*/
+    /*bit28-26=3'b001,bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,*/
+    /*bit16-14=3b001,bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x64, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl0_base_addr+0x68],data[bit31-24=all0,*/
+    /*bit23-21=3'b001,bit20-18=3'b001,bit17-15=3'b001,bit14-12=3'b001,*/
+    /*bit11-9=3'b001,bit8-6=3'b001,bit5-3=3'b001,bit2-0=3'b001]*/
+    osSerdesBitWrite( IOCTRL0_BASE_ADDR + 0x68, 0x249249, 0x249249 );
+
+    /*配置prbs pattern和 on-chip loopback*/
+    /*Macro1_rd(3'h4,1'h0,12'h5f,data[7:0]);data[4:4]=0,回写*/
+    ulValue = osSerdes1Read(0x4,0x0,0x5f);
+    ulValue &= 0xffffffef;
+    osSerdes1Write(0x4,0x0,0x5f,ulValue);
+
+    /*Macro1_rd(3'h4,1'h0,12'h50,data[7:0]);data[2:0]=x2[2:0]*/
+    ulValue = osSerdes1Read(0x4,0x0,0x50);
+    ulValue = (ulValue & 0xfffffff8 ) | ulPrbsPatten;
+    osSerdes1Write(0x4,0x0,0x5f,ulValue);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0,回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulValue = (ulValue & 0xfffffffd );
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*环回*/
+    osSerdes1PmaLp(ulLane, ulLpMode);
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+   /*Enable p0 state*/
+    /*Macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[0:0]=0,回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulValue &= 0xFFFFFFFE;
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h3,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x3);
+    ulValue = (ulValue | 0x10)  & 0xFFFFFFF0;
+    osSerdes1Write(ulLane & 0x7,0x0,0x3,ulValue);
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h4,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x4);
+    ulValue = (ulValue | 0x10)  & 0xFFFFFFF0;
+    osSerdes1Write(ulLane & 0x7,0x0,0x4,ulValue);
+
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl0_base_addr+0x404],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL0_BASE_ADDR + 0x404 == 0xff0\n" );
+#else
+    ulValue = ulValue & 0xFF0;
+    while (  ulWaitTime -- )
+    {
+        if( ulValue != 0xFF0 )
+        {
+            ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x404, 0 );
+            ulValue = ulValue & 0xFF0;
+        }
+        else
+        {
+            break;
+        }
+    }
+#endif
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+
+    /*3.开启PMA BIST*/
+    /*macro1_rd(x1[2:0],1'h0,12'h56,data[7:0])，data[0:0]=0,回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x56);
+    ulValue = (ulValue )  & 0xFFFFFFFE;
+    osSerdes1Write(ulLane & 0x7,0x0,0x56,ulValue);
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1; 回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulValue = (ulValue )  | 0x2;
+    osSerdes1Write(ulLane & 0x7,0x0,0x8,ulValue);
+
+    /*等待CDR锁定 register-based*/
+    /*macro1_rd(x1[2:0], 1'h0,12'h28,data[7:0]);data[5:5]=1'b1;data[6:6] =1'b0;回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x28);
+    ulValue = (ulValue  | 0x20 ) & 0xFFFFFFBF;
+    osSerdes1Write(ulLane & 0x7,0x0,0x28,ulValue);
+
+    /*等待macro1_rd(x1[2:0], 1'h0,12'hB,data[7:0]);直到data[5:5]==1*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0xB);
+    while(0x20 != (ulValue & 0x20) && ulWaitTime -- )
+    {
+        ulValue = osSerdes1Read(ulLane & 0x7,0x0,0xB);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("cdr didn't lock at LINE[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    /*开始PMA BIST receiver检查*/
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[5:5]=0;回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x55);
+    ulValue = (ulValue  ) & 0xFFFFFFDF;
+    osSerdes1Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1;回写*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulValue = (ulValue  | 0x2);
+    osSerdes1Write(ulLane & 0x7,0x0,0x8,ulValue);
+
+    /*等待symbol lock*/
+    /*一直进行macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[4:4]=1'b1;*/
+    ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    ulWaitTime = 1000000;
+    while(0x10 != (ulValue & 0x10) && ulWaitTime --)
+    {
+        ulValue = osSerdes1Read(ulLane & 0x7,0x0,0x8);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("symbol lock over time at line[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdes2PmaBistOnNormal(UINT32 ulLane,UINT32 ulPrbsPatten,UINT32 LpMode)
+{
+    //UINT32 ulRet = OS_SUCCESS;
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 1000000;
+    /*配置prbs pattern和 on-chip loopback*/
+    /*Macro2_rd(3'h4,1'h0,12'h5f,data[7:0]);data[4:4]=0,回写*/
+    ulData = osSerdes2Read(0x4,0x0,0x5f);
+    ulData &= 0xffffffef;
+    osSerdes2Write(0x4,0x0,0x5f,ulData);
+
+    /*Macro2_rd(3'h4,1'h0,12'h50,data[7:0]);data[2:0]=x2[2:0]*/
+    ulData = osSerdes2Read(0x4,0x0,0x50);
+    ulData = (ulData & 0xfffffff8 ) | ulPrbsPatten;
+    osSerdes2Write(0x4,0x0,0x5f,ulData);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0,回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulData = (ulData & 0xfffffffd );
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*环回*/
+    osSerdes2PmaLp(ulLane, LpMode);
+
+    /*Enable p0 state*/
+    /*Macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[0:0]=0,回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulData &= 0xFFFFFFFE;
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h3,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x3);
+    ulData = (ulData | 0x10)  & 0xFFFFFFF0;
+    osSerdes2Write(ulLane & 0x7,0x0,0x3,ulData);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h4,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x4);
+    ulData = (ulData | 0x10)  & 0xFFFFFFF0;
+    osSerdes2Write(ulLane & 0x7,0x0,0x4,ulData);
+
+    /*3.开启PMA BIST*/
+    /*macro2_rd(x1[2:0],1'h0,12'h56,data[7:0])，data[0:0]=0,回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x56);
+    ulData = (ulData )  & 0xFFFFFFFE;
+    osSerdes2Write(ulLane & 0x7,0x0,0x56,ulData);
+
+    /*macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1; 回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulData = (ulData )  | 0x2;
+    osSerdes2Write(ulLane & 0x7,0x0,0x8,ulData);
+
+    /*等待CDR锁定 register-based*/
+    /*macro2_rd(x1[2:0], 1'h0,12'h28,data[7:0]);data[5:5]=1'b1;data[6:6] =1'b0;回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x28);
+    ulData = (ulData  | 0x20 ) & 0xFFFFFFBF;
+    osSerdes2Write(ulLane & 0x7,0x0,0x28,ulData);
+
+    /*等待macro2_rd(x1[2:0], 1'h0,12'hB,data[7:0]);直到data[5:5]==1*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0xB);
+    while(0x20 != (ulData & 0x20) && ulWaitTime -- )
+    {
+        ulData = osSerdes2Read(ulLane & 0x7,0x0,0xB);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("cdr didn't lock at LINE[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    /*开始PMA BIST receiver检查*/
+    /*macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[5:5]=0;回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulData = (ulData  ) & 0xFFFFFFDF;
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulData);
+
+    /*macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1;回写*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulData = (ulData  | 0x2);
+    osSerdes2Write(ulLane & 0x7,0x0,0x8,ulData);
+
+    /*等待symbol lock*/
+    /*一直进行macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[4:4]=1'b1;*/
+    ulData = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulWaitTime = 1000000;
+    while(0x10 != (ulData & 0x10) && ulWaitTime --)
+    {
+        ulData = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("symbol lock over time at line[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdes2PmaBistOnReset(UINT32 ulLane,UINT32 ulPrbsPatten,UINT32 ulLpMode)
+{
+    UINT32 ulValue = 0;
+    //UINT32 ulLoop = 0;
+    INT32 ulWaitTime = 50000000;
+    //UINT32 ulRet = OS_SUCCESS;
+    /*1、等待芯片初始化完成，然后开始该serdes的初始化*/
+    /*2.power on reset/Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x588],data[bit19-10=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x588, 0xFFC00, 0xFFFFFFFF );
+
+    /*3、设置模式为multi-mode*/
+    /*Addr[ioctrl1_base_addr+0xC],data[bit11=0]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0xC, 0x0, 0xFFFFF7FF );
+
+    /*等待500ns*/
+    osSerdesWait( 500 );
+
+    /*撤离Power on reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit19=1,bit18-10=all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x80000, 0xFFF803FF );
+
+    /*等待500ns*/
+    osSerdesWait( 500 );
+
+    /*加载1.25Gbps_156.25MHz_VSM.txt配置文件*/
+    osSerdes2Write( 0x0, 0x0, 0x65, 0xb7 );
+    osSerdes2Write( 0x0, 0x0, 0x66, 0xb7 );
+    osSerdes2Write( 0x0, 0x0, 0x67, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x68, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x69, 0x1a );
+    osSerdes2Write( 0x0, 0x0, 0x6a, 0x1a );
+    osSerdes2Write( 0x0, 0x0, 0x6b, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x6c, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x6d, 0x11 );
+    osSerdes2Write( 0x0, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x1, 0x0, 0x65, 0xb7 );
+    osSerdes2Write( 0x1, 0x0, 0x66, 0xb7 );
+    osSerdes2Write( 0x1, 0x0, 0x67, 0xc );
+    osSerdes2Write( 0x1, 0x0, 0x68, 0xc );
+    osSerdes2Write( 0x1, 0x0, 0x69, 0x1a );
+    osSerdes2Write( 0x1, 0x0, 0x6a, 0x1a );
+    osSerdes2Write( 0x1, 0x0, 0x6b, 0x2 );
+    osSerdes2Write( 0x1, 0x0, 0x6c, 0x2 );
+    osSerdes2Write( 0x1, 0x0, 0x6d, 0x11 );
+    osSerdes2Write( 0x1, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x2, 0x0, 0x65, 0xb7 );
+    osSerdes2Write( 0x2, 0x0, 0x66, 0xb7 );
+    osSerdes2Write( 0x2, 0x0, 0x67, 0xc );
+    osSerdes2Write( 0x2, 0x0, 0x68, 0xc );
+    osSerdes2Write( 0x2, 0x0, 0x69, 0x1a );
+    osSerdes2Write( 0x2, 0x0, 0x6a, 0x1a );
+    osSerdes2Write( 0x2, 0x0, 0x6b, 0x2 );
+    osSerdes2Write( 0x2, 0x0, 0x6c, 0x2 );
+    osSerdes2Write( 0x2, 0x0, 0x6d, 0x11 );
+    osSerdes2Write( 0x2, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x3, 0x0, 0x65, 0xb7 );
+    osSerdes2Write( 0x3, 0x0, 0x66, 0xb7 );
+    osSerdes2Write( 0x3, 0x0, 0x67, 0xc );
+    osSerdes2Write( 0x3, 0x0, 0x68, 0xc );
+    osSerdes2Write( 0x3, 0x0, 0x69, 0x1a );
+    osSerdes2Write( 0x3, 0x0, 0x6a, 0x1a );
+    osSerdes2Write( 0x3, 0x0, 0x6b, 0x2 );
+    osSerdes2Write( 0x3, 0x0, 0x6c, 0x2 );
+    osSerdes2Write( 0x3, 0x0, 0x6d, 0x11 );
+    osSerdes2Write( 0x3, 0x0, 0x6e, 0xd );
+    osSerdes2Write( 0x4, 0x0, 0x65, 0x99 );
+    osSerdes2Write( 0x4, 0x0, 0x66, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x67, 0x6c );
+    osSerdes2Write( 0x4, 0x0, 0x68, 0xb7 );
+    osSerdes2Write( 0x4, 0x0, 0x69, 0xb7 );
+    osSerdes2Write( 0x4, 0x0, 0x6a, 0xc );
+    osSerdes2Write( 0x4, 0x0, 0x6b, 0xc );
+    osSerdes2Write( 0x4, 0x0, 0x6c, 0x1a );
+    osSerdes2Write( 0x4, 0x0, 0x6d, 0x1a );
+    osSerdes2Write( 0x4, 0x0, 0x6e, 0x7 );
+    osSerdes2Write( 0x4, 0x0, 0x6f, 0xc );
+    osSerdes2Write( 0x4, 0x0, 0x70, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0x71, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x72, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0x73, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x74, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x75, 0xb3 );
+    osSerdes2Write( 0x4, 0x0, 0x76, 0xf6 );
+    osSerdes2Write( 0x4, 0x0, 0x77, 0xd0 );
+    osSerdes2Write( 0x4, 0x0, 0x78, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x79, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x7a, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7b, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7c, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7d, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7e, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x7f, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x80, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x81, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x82, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x83, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x84, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x85, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x86, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x87, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x88, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x89, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8a, 0xd3 );
+    osSerdes2Write( 0x4, 0x0, 0x8b, 0xe2 );
+    osSerdes2Write( 0x4, 0x0, 0x8c, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x8d, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8e, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x8f, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x90, 0xef );
+    osSerdes2Write( 0x4, 0x0, 0x91, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x92, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x93, 0xfb );
+    osSerdes2Write( 0x4, 0x0, 0x94, 0xff );
+    osSerdes2Write( 0x4, 0x0, 0x95, 0x3f );
+    osSerdes2Write( 0x4, 0x0, 0x96, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x97, 0x64 );
+    osSerdes2Write( 0x4, 0x0, 0x98, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x99, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9a, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0x9b, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9c, 0x5 );
+    osSerdes2Write( 0x4, 0x0, 0x9d, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0x9e, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x9f, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa0, 0x8 );
+    osSerdes2Write( 0x4, 0x0, 0xa1, 0x4 );
+    osSerdes2Write( 0x4, 0x0, 0xa2, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa3, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xa4, 0x4 );
+    osSerdes2Write( 0x0, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x7, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0xd, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x30, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x31, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x36, 0x0 );
+    osSerdes2Write( 0x4, 0x0, 0x37, 0xb4 );
+    osSerdes2Write( 0x4, 0x0, 0x5d, 0x2 );
+    osSerdes2Write( 0x4, 0x0, 0xa5, 0x2 );
+    osSerdes2Write( 0x0, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x1, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x2, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x3, 0x0, 0x29, 0x6 );
+    osSerdes2Write( 0x4, 0x0, 0x162, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x163, 0x3a );
+    osSerdes2Write( 0x4, 0x0, 0x164, 0x9 );
+    osSerdes2Write( 0x4, 0x0, 0x165, 0x3 );
+    osSerdes2Write( 0x4, 0x0, 0x166, 0x3e );
+    osSerdes2Write( 0x4, 0x0, 0x167, 0xc );
+    osSerdes2Write( 0x0, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x1, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x2, 0x0, 0x2bd, 0x0 );
+    osSerdes2Write( 0x3, 0x0, 0x2bd, 0x0 );
+
+
+    /*配置并行数据接口的数据位宽和速率*/
+    /*Addr[ioctrl1_base_addr+0x10],data[bit31-29=3'b001, bit28-26=3'b001,*/
+    /*bit25-23=3'b001,bit22-20=3b001,bit19-17=3b001,bit16-14=3b001,*/
+    /*bit13-11=3b001,bit10-8=3b001,bit7-0=all 1]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x10, 0x249249FF, 0x249249FF );
+
+    /*addr[ioctrl1_base_addr+0x14],data[bit31-24=all0,bit23-21=3'b001,*/
+    /*bit20-18=3'b001,bit17-15=3'b001,bit14-12=3'b001,bit11-9=3'b001,*/
+    /*bit8-6=3'b001,bit5-3=3'b001,bit2-0=3'b001]*/
+    osSerdesBitWrite( IOCTRL1_BASE_ADDR + 0x14, 0x249249, 0x249249 );
+
+    /*配置prbs pattern和 on-chip loopback*/
+    /*Macro2_rd(3'h4,1'h0,12'h5f,data[7:0]);data[4:4]=0,回写*/
+    ulValue = osSerdes2Read(0x4,0x0,0x5f);
+    ulValue &= 0xffffffef;
+    osSerdes2Write(0x4,0x0,0x5f,ulValue);
+
+    /*Macro2_rd(3'h4,1'h0,12'h50,data[7:0]);data[2:0]=x2[2:0]*/
+    ulValue = osSerdes2Read(0x4,0x0,0x50);
+    ulValue = (ulValue & 0xfffffff8 ) | ulPrbsPatten;
+    osSerdes2Write(0x4,0x0,0x5f,ulValue);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0,回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulValue = (ulValue & 0xfffffffd );
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*环回*/
+    osSerdes2PmaLp(ulLane, ulLpMode);
+
+
+    /*等待500ns*/
+    osSerdesWait( 0x1000 );
+
+    /*复位撤离，Lane reset/syn reset*/
+    /*Addr[sysctrl_base_addr+0x58c],data[bit9=1,bit8-0=all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x58c, 0x3ff, 0xffffffff );
+
+   /*Enable p0 state*/
+    /*Macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[0:0]=0,回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulValue &= 0xFFFFFFFE;
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h3,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x3);
+    ulValue = (ulValue | 0x10)  & 0xFFFFFFF0;
+    osSerdes2Write(ulLane & 0x7,0x0,0x3,ulValue);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h4,data[7:0]);data[4:0]=5'b10000,回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x4);
+    ulValue = (ulValue | 0x10)  & 0xFFFFFFF0;
+    osSerdes2Write(ulLane & 0x7,0x0,0x4,ulValue);
+
+
+    /*等待lanex tx/rx ready,synth ready，至此初始化完成*/
+    /*Addr[ioctrl1_base_addr+0x400],data[bit11-4==all 1],*/
+    /*等待bit11-4全部为1，即为等到ready*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+    ulValue = ulValue & 0xFF0;
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL1_BASE_ADDR + 0x400 == 0xff0\n" );
+#else
+    while ( ulWaitTime -- )
+    {
+        if(ulValue != 0xFF0)
+        {
+            ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x400, 0 );
+            ulValue = ulValue & 0xFF0;
+        }
+        else
+        {
+            break;
+        }
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "waiting for lanex tx/rx ready,synth ready over time at FILE:%s,LINE:%d \n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+#endif
+
+    /*3.开启PMA BIST*/
+    /*macro2_rd(x1[2:0],1'h0,12'h56,data[7:0])，data[0:0]=0,回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x56);
+    ulValue = (ulValue )  & 0xFFFFFFFE;
+    osSerdes2Write(ulLane & 0x7,0x0,0x56,ulValue);
+
+    /*macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1; 回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulValue = (ulValue )  | 0x2;
+    osSerdes2Write(ulLane & 0x7,0x0,0x8,ulValue);
+
+    /*等待CDR锁定 register-based*/
+    /*macro2_rd(x1[2:0], 1'h0,12'h28,data[7:0]);data[5:5]=1'b1;data[6:6] =1'b0;回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x28);
+    ulValue = (ulValue  | 0x20 ) & 0xFFFFFFBF;
+    osSerdes2Write(ulLane & 0x7,0x0,0x28,ulValue);
+
+    /*等待macro2_rd(x1[2:0], 1'h0,12'hB,data[7:0]);直到data[5:5]==1*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0xB);
+    while(0x20 != (ulValue & 0x20) && ulWaitTime -- )
+    {
+        ulValue = osSerdes2Read(ulLane & 0x7,0x0,0xB);
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("cdr didn't lock at LINE[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+
+    /*开始PMA BIST receiver检查*/
+    /*macro2_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[5:5]=0;回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x55);
+    ulValue = (ulValue  ) & 0xFFFFFFDF;
+    osSerdes2Write(ulLane & 0x7,0x0,0x55,ulValue);
+
+    /*macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);data[1:1]=1'b1;回写*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulValue = (ulValue  | 0x2);
+    osSerdes2Write(ulLane & 0x7,0x0,0x8,ulValue);
+
+    /*等待symbol lock*/
+    /*一直进行macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[4:4]=1'b1;*/
+    ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+    ulWaitTime = 1000000;
+    while( ulWaitTime --)
+    {
+        if(0x10 != (ulValue & 0x10))
+        {
+             ulValue = osSerdes2Read(ulLane & 0x7,0x0,0x8);
+        }
+        else
+        {
+            break;
+        }
+    }
+    if(ulWaitTime <= 0)
+    {
+        SRE_printf("symbol lock over time at line[%d]\n",__LINE__);
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdes1TbusRead( UINT32 addr0, UINT32 addr1 )
+{
+    //UINT32 ulRet = OS_SUCCESS;
+    UINT32 ulData = 0;
+    UINT32 ulData2 = 0;
+     UINT32 ulData3 = 0;
+      UINT32 ulData4 = 0;
+        UINT32 ulData5 = 0;
+    ulData = osSerdes1Read( 0x4, 0x0, 0x60 );
+    osSerdes1Write( 0x4, 0x0, 0x60, ulData & 0xFFFFFFFB );
+
+    ulData = osSerdes1Read( 0x4, 0x0, 0x10 );
+    osSerdes1Write( 0x4, 0x0, 0x10, ulData & 0xFFFFFFF7 );
+
+    /*macro1_wr(3'h4,1'h0,12'h16,{x1,x2});*/
+    osSerdes1Write( 0x4, 0x0, 0x16,  ((addr0 & 0x7) << 0x5) | (addr1 & 0x1F));
+
+    ulData = osSerdes1Read( 0x4, 0x0, 0x10 );
+    /*macro1_rd(3'h4,1'h0,12'h10,data[7:0]);data[3:3]=1*/
+    osSerdes1Write( 0x4, 0x0, 0x10, ulData | 0x8 );
+
+    /*macro1_rd(3'h4,1'h0,12'h11,rdata1[7:0]); macro1_rd(3'h4,1'h0,12'h12,rdata2[7:0]); */
+    ulData = (osSerdes1Read( 0x4, 0x0, 0x11 ) & 0xff) << 0;
+    ulData2 = (osSerdes1Read( 0x4, 0x0, 0x12 ) & 0xff) << 8;
+   /*macro1_rd(3'h4,1'h0,12'h13,rdata3[7:0]); macro1_rd(3'h4,1'h0,12'h14,rdata4[7:0]); */
+    ulData3 = (osSerdes1Read( 0x4, 0x0, 0x13 ) & 0xff) << 16;
+    ulData4 = (osSerdes1Read( 0x4, 0x0, 0x14 ) & 0xff) << 24;
+    /*macro1_rd(3'h4,1'h0,12'h15,rdata5[7:0]);*/
+    ulData5 = osSerdes1Read( 0x4, 0x0, 0x15 );
+
+    SRE_printf("osSerdes1ThusRead : addr[0x%08x] , value[0x%08x]\n",ulData5,ulData4 | ulData3 | ulData2 |ulData);
+
+    return OS_SUCCESS;
+}
+
+
+UINT32 osSerdes2TbusRead( UINT32 addr0, UINT32 addr1 )
+{
+    //UINT32 ulRet = OS_SUCCESS;
+    UINT32 ulData = 0;
+    UINT32 ulData2 = 0;
+     UINT32 ulData3 = 0;
+      UINT32 ulData4 = 0;
+        UINT32 ulData5 = 0;
+    ulData = osSerdes2Read( 0x4, 0x0, 0x60 );
+    osSerdes2Write( 0x4, 0x0, 0x60, ulData & 0xFFFFFFFB );
+
+    ulData = osSerdes2Read( 0x4, 0x0, 0x10 );
+    osSerdes2Write( 0x4, 0x0, 0x10, ulData & 0xFFFFFFF7 );
+
+    /*macro1_wr(3'h4,1'h0,12'h16,{x1,x2});*/
+    osSerdes2Write( 0x4, 0x0, 0x16,  ((addr0 & 0x7) << 0x5) | (addr1 & 0x1F));
+
+    ulData = osSerdes2Read( 0x4, 0x0, 0x10 );
+    /*macro1_rd(3'h4,1'h0,12'h10,data[7:0]);data[3:3]=1*/
+    osSerdes2Write( 0x4, 0x0, 0x10, ulData | 0x8 );
+
+    /*macro1_rd(3'h4,1'h0,12'h11,rdata1[7:0]); macro1_rd(3'h4,1'h0,12'h12,rdata2[7:0]); */
+    ulData = (osSerdes2Read( 0x4, 0x0, 0x11 ) & 0xff) << 0;
+    ulData2 = (osSerdes2Read( 0x4, 0x0, 0x12 ) & 0xff) << 8;
+   /*macro1_rd(3'h4,1'h0,12'h13,rdata3[7:0]); macro1_rd(3'h4,1'h0,12'h14,rdata4[7:0]); */
+    ulData3 = (osSerdes2Read( 0x4, 0x0, 0x13 ) & 0xff) << 16;
+    ulData4 = (osSerdes2Read( 0x4, 0x0, 0x14 ) & 0xff) << 24;
+    /*macro1_rd(3'h4,1'h0,12'h15,rdata5[7:0]);*/
+    ulData5 = osSerdes2Read( 0x4, 0x0, 0x15 );
+
+    SRE_printf("osSerdes2ThusRead : addr[0x%08x] , value[0x%08x]\n",ulData5,ulData4 | ulData3 | ulData2 |ulData);
+
+    return OS_SUCCESS;
+}
+
+
+
+/*****************************************************************
+函数名 :  osSerdes1PmaLp
+输入参数    :  ulLane
+              ulLpMode
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes1PmaLp( UINT32 ulLane, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0; macro1_wr(a,1'h0,12'h55,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x55 );
+    ulData &= 0xFFFFFFFD;
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x55 ,ulData);
+
+    /*macro1_rd(x1[2:0],1'h0,12'h7,data[7:0]);*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x7 );
+
+    switch ( ulLpMode )
+    {
+        case 0:
+            /*data[4:4]=1'b1, data[5:5]=1'b0,data[6:6]=1'b0, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x10 ) & 0xFFFFFF1E;
+            break;
+        case 1:
+            /*data[4:4]=1'b0, data[5:5]=1'b1,data[6:6]=1'b0, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x20 ) & 0xFFFFFF2E;
+            break;
+        case 2:
+            /*data[4:4]=1'b0, data[5:5]=1'b0,data[6:6]=1'b1, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x40 ) & 0xFFFFFF4E;
+            break;
+        case 3:
+            /*data[4:4]=1'b0, data[5:5]=1'b0,data[6:6]=1'b0, data[7:7]=1'b1;bit[0:0]=1'b1*/
+            ulData = ( ulData | 0x81 ) & 0xFFFFFF8F;
+            break;
+        default:
+            SRE_printf( "ERROR ulLpMode at FILE:%s,LINE %d\n", __FILE__, __LINE__ );
+            return OS_FAIL;
+    }
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x7, ulData );
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2PmaLp
+输入参数    :  ulLane
+              ulLpMode
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes2PmaLp( UINT32 ulLane, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0; macro1_wr(a,1'h0,12'h55,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x55 );
+    ulData &= 0xFFFFFFFD;
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x55 ,ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h7,data[7:0]);*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x7 );
+
+    switch ( ulLpMode )
+    {
+        case 0:
+            /*data[4:4]=1'b1, data[5:5]=1'b0,data[6:6]=1'b0, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x10 ) & 0xFFFFFF1E;
+            break;
+        case 1:
+            /*data[4:4]=1'b0, data[5:5]=1'b1,data[6:6]=1'b0, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x20 ) & 0xFFFFFF2E;
+            break;
+        case 2:
+            /*data[4:4]=1'b0, data[5:5]=1'b0,data[6:6]=1'b1, data[7:7]=1'b0;bit[0:0]=1'b0*/
+            ulData = ( ulData | 0x40 ) & 0xFFFFFF4E;
+            break;
+        case 3:
+            /*data[4:4]=1'b0, data[5:5]=1'b0,data[6:6]=1'b0, data[7:7]=1'b1;bit[0:0]=1'b1*/
+            ulData = ( ulData | 0x81 ) & 0xFFFFFF8F;
+            break;
+        default:
+            SRE_printf( "ERROR ulLpMode at FILE:%s,LINE %d\n", __FILE__, __LINE__ );
+            return OS_FAIL;
+    }
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x7, ulData );
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes1PcsLp
+输入参数    :  ulLane
+              ulLpMode
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes1PcsLp( UINT32 ulLane, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0; macro1_wr(a,1'h0,12'h55,data[7:0]);*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x55 );
+    ulData = ulData & 0xFFFFFFFD;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x55, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'hC,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0xc );
+
+    if ( ulLpMode == 1 )
+    {
+        ulData = ( ulData | 0x8 ) & 0xFFFFFFEF;
+    }
+    else if ( ulLpMode == 2 )
+    {
+        ulData = ( ulData | 0x10 ) & 0xFFFFFFF7;
+    }
+    else
+    {
+        SRE_printf( "ERROR ulLpMode at FILE:%s,LINE %d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdes1Write( ulLane & 0x7, 0x1, 0xc, ulData );
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes2PcsLp
+输入参数    :  ulLane
+              ulLpMode
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes2PcsLp( UINT32 ulLane, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0]);data[1:1]=0; macro1_wr(a,1'h0,12'h55,data[7:0]);*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x1, 0x55 );
+    ulData = ulData & 0xFFFFFFFD;
+    osSerdes2Write( ulLane & 0x7, 0x1, 0x55, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'hC,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x1, 0xc );
+
+    if ( ulLpMode == 1 )
+    {
+        ulData = ( ulData | 0x8 ) & 0xFFFFFFEF;
+    }
+    else if ( ulLpMode == 2 )
+    {
+        ulData = ( ulData | 0x10 ) & 0xFFFFFFF7;
+    }
+    else
+    {
+        SRE_printf( "ERROR ulLpMode at FILE:%s,LINE %d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdes2Write( ulLane & 0x7, 0x1, 0xc, ulData );
+    return OS_SUCCESS;
+}
+
+/*****************************************************************
+函数名 :  osSerdes1PmaBistOn
+输入参数    :  ulLane
+              ulPrabPatten
+              ulLpMode
+输出参数      :
+Description   :  serdes1 开启bist测试
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes1PmaBistOn( UINT32 ulLane, UINT32 ulPrabPatten, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 0x10000;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x55 );
+    ulData = ulData & 0xFFFFFFDE;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h55,data[7:0])*/
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x55, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h56,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x56 );
+    ulData = ulData & 0xFFFFFFFE;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h56,data[7:0]);*/
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x56, ulData );
+
+    /*macro1_rd(3'h4,1'h0,12'h50,data[7:0]);*/
+    ulData = osSerdes1Read( 0x4, 0x0, 0x50 );
+    ulData = ( ulData & 0xFFFFFFF8 ) | ( ulPrabPatten & 0x7 );
+
+    /*macro1_wr(3'h4,1'h0,12'h50,data[7:0]);*/
+    osSerdes1Write( 0x4, 0x0, 0x50, ulData );
+
+    osSerdes1PmaLp( ulLane, ulLpMode );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData | 0x2;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0], 1'h0,12'h28,data[7:0]);*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x28 );
+    ulData = ( ulData | 0x20 ) & 0xFFFFFFBF;
+
+    /*macro1_wr(x1[2:0], 1'h0,12'h28,data[7:0]);*/
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x28, ulData );
+
+    /*macro1_rd(x1[2:0], 1'h0,12'hB,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0xB );
+    while ( 0x20 != ( ulData & 0x20 ) && ulWaitTime -- )
+    {
+        ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0xB );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData | 0x2;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    ulWaitTime = 0x10000;
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    while ( 0x10 != ( ulData & 0x10 ) && ulWaitTime-- )
+    {
+        ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes2PmaBistOn
+输入参数    :  ulLane
+              ulPrabPatten
+              ulLpMode
+输出参数      :
+Description   :  serdes1 开启bist测试
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes2PmaBistOn( UINT32 ulLane, UINT32 ulPrabPatten, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 0x10000;
+    /*macro1_rd(x1[2:0],1'h0,12'h55,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x55 );
+    ulData = ulData & 0xFFFFFFDE;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h55,data[7:0])*/
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x55, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h56,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x56 );
+    ulData = ulData & 0xFFFFFFFE;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h56,data[7:0]);*/
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x56, ulData );
+
+    /*macro1_rd(3'h4,1'h0,12'h50,data[7:0]);*/
+    ulData = osSerdes2Read( 0x4, 0x0, 0x50 );
+    ulData = ( ulData & 0xFFFFFFF8 ) | ( ulPrabPatten & 0x7 );
+
+    /*macro1_wr(3'h4,1'h0,12'h50,data[7:0]);*/
+    osSerdes2Write( 0x4, 0x0, 0x50, ulData );
+
+    osSerdes2PmaLp( ulLane, ulLpMode );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData | 0x2;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0], 1'h0,12'h28,data[7:0]);*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x28 );
+    ulData = ( ulData | 0x20 ) & 0xFFFFFFBF;
+
+    /*macro1_wr(x1[2:0], 1'h0,12'h28,data[7:0]);*/
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x28, ulData );
+
+    /*macro1_rd(x1[2:0], 1'h0,12'hB,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0xB );
+    while ( 0x20 != ( ulData & 0x20 ) && ulWaitTime -- )
+    {
+        ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0xB );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData | 0x2;
+
+    /*macro1_wr(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);*/
+    ulWaitTime = 0x10000;
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    while ( 0x10 != ( ulData & 0x10 ) && ulWaitTime-- )
+    {
+        ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    return OS_SUCCESS;
+}
+
+UINT32 osSerdes1PmaBistOff( UINT32 ulLane, UINT32 ulPrabPatten, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 0x10000;
+    UINT32 ulBistCnt1, ulBistCnt2;
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData & 0xFFFFFFFD;
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[2:2]=1'b1*/
+    ulWaitTime = 0x10000;
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    while ( 0x8 != ( ulData & 0x8 ) && ulWaitTime -- )
+    {
+        ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    ulBistCnt1 = osSerdes1Read( ulLane & 0x7, 0x0, 0x9 );
+    ulBistCnt2 = osSerdes1Read( ulLane & 0x7, 0x0, 0xA );
+
+    SRE_printf("ulBistCnt1 : [%d],ulBistCnt2 : [%d]\n",ulBistCnt1,ulBistCnt2);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]); data[3:3]=1*/
+    ulBistCnt1 = osSerdes1Read( ulLane & 0x7, 0x0, 0x8 );
+
+    if(0x8 == (ulBistCnt1 & 0x8))
+    {
+        SRE_printf("error is too many !osSerdes1PmaBistOff \n");
+    }
+
+    return OS_SUCCESS;
+}
+UINT32 osSerdes2PmaBistOff( UINT32 ulLane, UINT32 ulPrabPatten, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 0x10000;
+    UINT32 ulBistCnt1, ulBistCnt2;
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0])*/
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    ulData = ulData & 0xFFFFFFFD;
+    osSerdes2Write( ulLane & 0x7, 0x0, 0x8, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h8,data[7:0]);直到data[2:2]=1'b1*/
+    ulWaitTime = 0x10000;
+    ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    while ( 0x8 != ( ulData & 0x8 ) && ulWaitTime -- )
+    {
+        ulData = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "wait for bit change over time at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    ulBistCnt1 = osSerdes2Read( ulLane & 0x7, 0x0, 0x9 );
+    ulBistCnt2 = osSerdes2Read( ulLane & 0x7, 0x0, 0xA );
+
+    SRE_printf("ulBistCnt1 : [%d],ulBistCnt2 : [%d]\n",ulBistCnt1,ulBistCnt2);
+
+    /*Macro2_rd(x1[2:0],1'h0,12'h8,data[7:0]); data[3:3]=1*/
+    ulBistCnt1 = osSerdes2Read( ulLane & 0x7, 0x0, 0x8 );
+
+    if(0x8 == (ulBistCnt1 & 0x8))
+    {
+        SRE_printf("error is too many !osSerdes2PmaBistOff \n");
+    }
+
+    return OS_SUCCESS;
+}
+
+UINT32 osSerdes3BistTest(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = 0x10000;
+    /*Addr[sysctrl_base_addr+0x590],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0x1FFFF00, 0xffffffff );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR, 0x0, 0x36 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x4 , 0x0, 0x26 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x100 , 0x0, 0x21010c );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x104 , 0x0, 0x210affa0 );
+
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x82c , 0x0, 0x40000 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x838  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x8ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x8b8  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x92c , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x938  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x9ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + 0x9b8  , 0x0, 0xd33 );
+
+    osSerdesWait( 0x1000 );
+
+    /*Addr[sysctrl_base_addr+0x594],data[bit24=1, bit23-8= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1000000, 0xFF0000FF );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl1_base_addr+0x434],data[bit4=1, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    while ( 0x10 != ( ulValue & 0x10 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x434, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit24-8= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0x1FFFF00, 0xFFffffFF );
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES3_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES3_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    /**/
+
+    return OS_SUCCESS;
+}
+
+UINT32 osSerdes0BistTest(void)
+{
+    UINT32 ulValue = 0;
+    UINT32 ulLoop = 0;
+    INT32 ulWaitTime = 0x10000;
+    /*Addr[sysctrl_base_addr+0x580],data[bit24-0= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x580, 0x1FFFFFF, 0xffffffff );
+    /*Addr[sysctrl_base_addr+0x590],data[bit7-0= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x590, 0xFF, 0xffffffff );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=0,bit4=0]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x0, 0xFFFFFFEE );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=0]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x144, 0x0, 0xFFF7FFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=0]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR, 0x0, 0xDFFFFFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR, 0x0, 0xDFFFFFFF );
+
+    osSerdesWait( 0x1000 );
+
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR, 0x0, 0x36 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x4 , 0x0, 0x26 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x100 , 0x0, 0x21010c );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x104 , 0x0, 0x210affa0 );
+
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR, 0x0, 0x36 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x4 , 0x0, 0x26 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x100 , 0x0, 0x21010c );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x104 , 0x0, 0x210affa0 );
+
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x82c , 0x0, 0x40000 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x838  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x8ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x8b8  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x92c , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x938  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x9ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + 0x9b8  , 0x0, 0xd33 );
+
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x82c , 0x0, 0x40000 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x838  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x8ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x8b8  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x92c , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x938  , 0x0, 0xd33 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x9ac , 0x0, 0x0 );
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + 0x9b8  , 0x0, 0xd33 );
+
+    osSerdesWait( 0x1000 );
+
+    /*Addr[sysctrl_base_addr+0x584],data[bit24=1, bit23-0= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x584, 0x1000000, 0xFF000000 );
+    /*Addr[sysctrl_base_addr+0x594],data[bit7-0= all 0]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x584, 0x0, 0xFFFFFF00 );
+
+    osSerdesWait( 0x1000 );
+    /*Addr[ioctrl0_base_addr+0x400],data[bit9-8=2'b11, means pll is locked]*/
+    ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x400, 0 );
+    while ( 0x300 != ( ulValue & 0x300 ) && ulWaitTime -- )
+    {
+        ulValue = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x400, 0 );
+    }
+    if ( ulWaitTime <= 0 )
+    {
+        SRE_printf( "osSerdes0WaitForPllCfg error at FILE:%s,LINE:%d\n", __FILE__, __LINE__ );
+        return OS_FAIL;
+    }
+    osSerdesWait( 0x1000 );
+    /*Addr[sysctrl_base_addr+0x584],data[bit24-0= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x584, 0x1FFFFFF, 0xFFffffFF );
+    /*Addr[sysctrl_base_addr+0x594],data[bit7-0= all 1]*/
+    osSerdesBitWrite( SYSCTRL_BASE_ADDR + 0x594, 0xFF, 0xFFffffFF );
+
+    /*Addr[serdes3_base_addr+0x838+0x80*0~3],data[bit0=1,bit4=1]*/
+    for ( ulLoop = 0; ulLoop < 4; ulLoop++ )
+    {
+        osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+        osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x838 + 0x80 * ulLoop, 0x11, 0xFFFFFFFF );
+    }
+    /*Addr[serdes3_base_addr+0x144],data[bit19=1]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x144, 0x80000, 0xFFFFFFFF );
+    /*Addr[serdes3_base_addr+0x0],data[bit29=1]*/
+    osSerdesBitWrite( SERDES0_LOW_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+    osSerdesBitWrite( SERDES0_HIGHT_BASE_ADDR + 0x0, 0x20000000, 0xFFFFFFFF );
+
+    /**/
+
+    return OS_SUCCESS;
+}
+
+
+#if 0
+/*****************************************************************
+函数名 :  osSerdes1PcsBistOn
+输入参数    :  ulLane
+              ulPrabPatten
+              ulLpMode
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/31
+*****************************************************************/
+UINT32 osSerdes1PcsBistOn( UINT32 ulLane, UINT32 ulPrabPatten, UINT32 ulLpMode )
+{
+    UINT32 ulData = 0;
+    INT32 ulWaitTime = 0x10000;
+    UINT32 ulTemp1, ulTemp2;
+
+    /*Macro1_rd(x1[2:0],1'h0,12'h55,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x55 );
+    ulData = ulData & 0xFFFFFFDD;
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x55, ulData );
+
+    /*macro1_rd(x1[2:0],1'h0,12'h56,data[7:0])*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x56 );
+    ulData = ulData & 0xFFFFFFFE;
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x55, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h0, 12'h7,data[7:0]);data[6:6]=1;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x0, 0x7 );
+    ulData = ulData | 0x40;
+    osSerdes1Write( ulLane & 0x7, 0x0, 0x7, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h7,data[7:0]);data[6:6]=1;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x7 );
+    ulData = ulData | 0x40;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x7, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h7,data[7:0]);data[1:1]=1;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x7 );
+    ulData = ulData | 0x2;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x7, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h9,data[7:0]);data[6:6]=0;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x9 );
+    ulData = ulData & 0xFFFFFFBF;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x9, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h9,data[7:0]);data[1:1]=0;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x9 );
+    ulData = ulData & 0xFFFFFFFD;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x9, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h7,data[7:0]);data[0:0]=0;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x7 );
+    ulData = ulData & 0xFFFFFFFE;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x7, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h7,data[7:0]);data[2:2]=0;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x7 );
+    ulData = ulData & 0xFFFFFFFB;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x7, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h9,data[7:0]);data[5:2]=0;再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x9 );
+    ulData = ulData & 0xFFFFFFC3;
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x9, ulData );
+
+    /*Macro1_rd(x1[2:0],1'h1, 12'h8,data[7:0]);data[1:0]=x2[1:0];再回写*/
+    ulData = osSerdes1Read( ulLane & 0x7, 0x1, 0x8 );
+    ulData = ( ulData & 0xFFFFFFFC ) | ( ulPrabPatten & 0x3 );
+    osSerdes1Write( ulLane & 0x7, 0x1, 0x8, ulData );
+
+    /*Macro1_rd(3'h4,1'h1, 12'h11,data[7:0]);data[2:0]= 3'b1;再回写*/
+    ulData = osSerdes1Read( 0x4, 0x1, 0x11 );
+    ulData = ( ulData | 0x1 ) & 0xFFFFFFF9;
+    osSerdes1Write( 0x4, 0x1, 0x11, ulData );
+
+    /*Macro1_rd(3'h4,1'h1, 12'h7,data1[7:0])*/
+    ulTemp1 = osSerdes1Read( 0x4, 0x1, 0x7 );
+    ulTemp2 = osSerdes1Read( 0x4, 0x1, 0x8 );
+    ulData = ( ( ulTemp1 & 0xFF ) << 0x8 ) | ( ulTemp2 & 0xFF );
+    while ( 0x4B0 != ( ulData & 0xFFFF ) && ulWaitTime -- )
+    {
+        ulTemp1 = osSerdes1Read( 0x4, 0x1, 0x7 );
+        ulTemp2 = osSerdes1Read( 0x4, 0x1, 0x8 );
+        ulData = ( ( ulTemp1 & 0xFF ) << 0x8 ) | ( ulTemp2 & 0xFF );
+    }
+    osSerdes1Write( 0x4, 0x1, 0x11, ulData );
+
+
+}
+
+#endif
+/*****************************************************************
+函数名 :  osSerdes0Write
+输入参数    :  ulAddr   地址
+              ulValue    写数据
+输出参数      :
+Description   :  serdes0 debug读写接口
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+void osSerdes0LowWrite( UINT32 ulAddr, UINT32 ulValue )
+{
+    OS_SDS_WRITE_REG( SERDES0_LOW_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+/*****************************************************************
+函数名 :  osSerdes0LowRead
+输入参数    :  ulAddr   地址
+              ulValue    写数据
+输出参数      :
+Description   :  serdes0 debug读写接口
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes0LowRead( UINT32 ulAddr )
+{
+    return OS_READ_REG( SERDES0_LOW_BASE_ADDR + ulAddr, 0 );
+}
+
+/*****************************************************************
+函数名 :  osSerdes0HighWrite
+输入参数    :  ulAddr   地址
+              ulValue    写数据
+输出参数      :
+Description   :  serdes0 debug读写接口
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+void osSerdes0HighWrite( UINT32 ulAddr, UINT32 ulValue )
+{
+    OS_SDS_WRITE_REG( SERDES0_HIGHT_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+/*****************************************************************
+函数名 :  osSerdes0HighRead
+输入参数    :  ulAddr   地址
+              ulValue    写数据
+输出参数      :
+Description   :  serdes0 debug读写接口
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes0HighRead( UINT32 ulAddr )
+{
+    return OS_READ_REG( SERDES0_HIGHT_BASE_ADDR + ulAddr, 0 );
+}
+
+
+/*****************************************************************
+函数名 :  osSerdes1Write
+输入参数    :  ulPage  :3bit
+              ulType  : 1bit
+              ulOffset :12 bit
+              ulValue  :8 bit
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+void osSerdes1Write( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset, UINT32 ulValue )
+{
+    /*1、:write addr[ioctrl0_base_addr+0x9c],data[bit31-27=all 0,*/
+    /*bit26=0,bit25=1,bit24=1,bit23-16=x4,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    UINT32 ulTemp = 0;
+    UINT32 ulRdata = 0;
+    INT32 ulLoop = SREDES_LOOP_TIME;
+    UINT32 ulStepChoose = 0;
+    ulTemp = ( ( ulTemp | 0x3000000 ) | ( ulValue << 16 ) | \
+               ( ulOffset & 0xfff ) | ( ulType << 12 ) | ( ulPage << 13 ) );
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp );
+
+    /*2:write addr[ioctrl0_base_addr+0x9c],*/
+    /*data[bit31-27=all 0,bit26=0,bit25=0,bit24=1,*/
+    /*bit23-16=x4,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp & 0xFDFFFFFF );
+
+    /*第3步：read addr[ioctrl0_base_addr+0x42c], 回读的数据为rdata*/
+    ulRdata = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x42c, 0 );
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL0_BASE_ADDR + 0x42c == 0x100\n" );
+
+#else
+
+    /*第4步：如果第3步中rdata[bit8==0],回到第3步；如果1ms内，*/
+    /*rdata[bit8==1],走到第5步；如果超过1ms后，直接走到第6步*/
+    while ( --ulLoop )
+    {
+        if ( 0x100 == ( ulRdata & 0x100 ) )
+        {
+            ulStepChoose = 5;
+            break;
+        }
+        else
+        {
+            ulRdata = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x42c, 0 );
+        }
+    }
+
+#endif
+    if(gulDebugOpen)
+    {
+        if ( 5 == ulStepChoose )
+        {
+            SRE_printf( "serdes1 write ok page=%x sel=%x offset=%x rdata=%x", ulPage, ulType, ulOffset, ulRdata );
+        }
+    }
+    if ( ulLoop <= 0 )
+    {
+            SRE_printf( "serdes1 write outoftime page=%x sel=%x offset=%x", ulPage, ulType, ulOffset );
+    }
+
+    /*第7步：write addr[ioctrl0_base_addr+0x9c],*/
+    /*data[bit31-27=all 0,bit26=1,bit25=0,bit24=1,bit23-16=X4,bit15-13=x1,*/
+    /*bit12=x2,bit11-0=x3]*/
+    ulTemp = 0;
+    ulTemp = ( ulTemp | 0x5000000 ) | ( ulPage << 13 ) | ( ulType << 12 ) | ( ulOffset & 0xfff ) | (ulValue << 16);
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp );
+
+    /*等1us，在执行其他操作*/
+    osSerdesWait(0x1000);
+}
+
+/*****************************************************************
+函数名 :  osSerdes1Read
+输入参数    :  ulPage  : 3bit
+              ulType    : 1 bit
+              ulOffset  :12 bit
+输出参数      :     value : 8bit
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/30
+*****************************************************************/
+UINT32 osSerdes1Read( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset )
+{
+    UINT32 ulTemp = 0;
+    UINT32 ulRdata = 0;
+    INT32 ulLoop = SREDES_LOOP_TIME;
+    UINT32 ulStepChoose = 0;
+
+    /*write addr[ioctrl0_base_addr+0x9c],data[bit31-27=all 0,bit26=0,bit25=1,*/
+    /*bit24=0,bit23-16=all 0,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    ulTemp = ( ( ulTemp | 0x2000000 ) | \
+               ( ulOffset & 0xfff) | ( ulType << 12 ) | ( ulPage << 13 ) );
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp );
+
+    /*write addr[ioctrl0_base_addr+0x9c], data[bit31-27=all 0,bit26=0,*/
+    /*bit25=0,bit24=0,bit23-16=all 0,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp & 0xFDFFFFFF );
+
+    /*第3步：read addr[ioctrl0_base_addr+0x42c], 回读的数据为rdata*/
+    ulRdata = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x42c, 0 );
+    /*第4步：如果第3步中rdata[bit8==0],回到第3步；如果1ms内，*/
+    /*rdata[bit8==1],走到第5步；如果超过1ms后，直接走到第6步*/
+    while ( --ulLoop )
+    {
+        if ( 0x100 == ( ulRdata & 0x100 ) )
+        {
+            ulStepChoose = 5;
+            break;
+        }
+        else
+        {
+            ulRdata = OS_READ_REG( IOCTRL0_BASE_ADDR + 0x42c, 0 );
+        }
+    }
+
+    if(gulDebugOpen)
+    {
+
+        if ( 5 == ulStepChoose )
+        {
+            SRE_printf( "serdes2 read ok page=%x sel=%x offset=%x rdata=%x", ulPage, ulType, ulOffset, ulRdata );
+        }
+    }
+    if ( ulLoop <= 0 )
+    {
+        SRE_printf( "serdes2 read outoftime page=%x sel=%x offset=%x", ulPage, ulType, ulOffset );
+    }
+    /*第7步：write addr[ioctrl0_base_addr+0x9c],*/
+    /*data[bit31-27=all 0,bit26=1,bit25=0,bit24=0,bit23-16=all 0,bit15-13=x1,*/
+    /*bit12=x2,bit11-0=x3]*/
+    ulTemp = 0;
+    ulTemp = ( ulTemp | 0x4000000 ) | ( ulPage << 13 ) | ( ulType << 12 ) | ( ulOffset & 0xfff );
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + 0x9c, 0, ulTemp );
+
+    return ulRdata & 0x1FF;
+}
+
+/*****************************************************************
+函数名 :  osSerdes2Write
+输入参数    :  ulPage  :3bit
+              ulType  : 1bit
+              ulOffset :12 bit
+              ulValue  :8 bit
+输出参数      :
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+void osSerdes2Write( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset, UINT32 ulValue )
+{
+    /*1、:write addr[ioctrl1_base_addr+0x48],data[bit31-27=all 0,*/
+    /*bit26=0,bit25=1,bit24=1,bit23-16=x4,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    UINT32 ulTemp = 0;
+    UINT32 ulRdata = 0;
+    INT32 ulLoop = SREDES_LOOP_TIME;
+    UINT32 ulStepChoose = 0;
+    ulTemp = ( ( ulTemp | 0x3000000 ) | ( ulValue << 16 ) | \
+               ( ulOffset & 0xfff ) | ( ulType << 12 ) | ( ulPage << 13 ) );
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp );
+
+    /*2:write addr[ioctrl1_base_addr+0x48],*/
+    /*data[bit31-27=all 0,bit26=0,bit25=0,bit24=1,*/
+    /*bit23-16=x4,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp & 0xFDFFFFFF );
+
+    /*第3步：read addr[ioctrl1_base_addr+0x428], 回读的数据为rdata*/
+    ulRdata = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x428, 0 );
+#if SERDES_DEBUG_OPEN
+    SRE_printf( "check IOCTRL1_BASE_ADDR + 0x428 == 0x100\n" );
+#else
+    /*第4步：如果第3步中rdata[bit8==0],回到第3步；如果1ms内，*/
+    /*rdata[bit8==1],走到第5步；如果超过1ms后，直接走到第6步*/
+    while ( --ulLoop )
+    {
+        if ( 0x100 == ( ulRdata & 0x100 ) )
+        {
+            ulStepChoose = 5;
+            break;
+        }
+        else
+        {
+            ulRdata = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x428, 0 );
+        }
+    }
+#endif
+    if(gulDebugOpen)
+    {
+
+        if ( 5 == ulStepChoose )
+        {
+            SRE_printf( "serdes2 read ok page=%x sel=%x offset=%x rdata=%x", ulPage, ulType, ulOffset, ulRdata );
+        }
+    }
+    if ( ulLoop <= 0 )
+    {
+        SRE_printf( "serdes2 read outoftime page=%x sel=%x offset=%x", ulPage, ulType, ulOffset );
+    }
+    /*第7步：write addr[ioctrl1_base_addr+0x48],*/
+    /*data[bit31-27=all 0,bit26=1,bit25=0,bit24=1,bit23-16=x4,bit15-13=x1,*/
+    /*bit12=x2,bit11-0=x3]*/
+    ulTemp = 0;
+    ulTemp = ( ulTemp | 0x5000000 ) | ( ulPage << 13 ) | ( ulType << 12 ) | ( ulOffset & 0xfff ) | (ulValue << 16);
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp );
+
+    osSerdesWait(1000);
+
+}
+
+/*****************************************************************
+函数名 :  osSerdes2Read
+输入参数    :  ulPage  :3bit
+              ulType  : 1bit
+              ulOffset :12 bit
+
+输出参数      :  ulValue  :8 bit
+Description   :
+
+Author        :  z00228490
+Creation time :  2012/12/28
+*****************************************************************/
+UINT32 osSerdes2Read( UINT32 ulPage, UINT32 ulType, UINT32 ulOffset )
+{
+    /*1、:write addr[ioctrl1_base_addr+0x48],data[bit31-27=all 0,*/
+    /*bit26=0,bit25=1,bit24=0,bit23-16 all 0,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    UINT32 ulTemp = 0;
+    UINT32 ulRdata = 0;
+    INT32 ulLoop = SREDES_LOOP_TIME;
+    UINT32 ulStepChoose = 0;
+    ulTemp = ( ( ulTemp | 0x2000000 )  | \
+               ( ulOffset ) | ( ulType << 12 ) | ( ulPage << 13 ) );
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp );
+
+    /*2:write addr[ioctrl1_base_addr+0x48],*/
+    /*data[bit31-27=all 0,bit26=0,bit25=0,bit24=0,*/
+    /*bit23-16 all 0,bit15-13=x1,bit12=x2,bit11-0=x3]*/
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp & 0xFDFFFFFF );
+
+    /*第3步：read addr[ioctrl1_base_addr+0x428], 回读的数据为rdata*/
+    ulRdata = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x428, 0 );
+
+    /*第4步：如果第3步中rdata[bit8==0],回到第3步；如果1ms内，*/
+    /*rdata[bit8==1],走到第5步；如果超过1ms后，直接走到第6步*/
+    while (--ulLoop )
+    {
+        if ( 0x100 == ( ulRdata & 0x100 ) )
+        {
+            ulStepChoose = 5;
+            break;
+        }
+        else
+        {
+            ulRdata = OS_READ_REG( IOCTRL1_BASE_ADDR + 0x428, 0 );
+        }
+    }
+
+    if(gulDebugOpen)
+    {
+        if ( 5 == ulStepChoose )
+        {
+             SRE_printf( "serdes2 read ok page=%x sel=%x offset=%x rdata=%x", ulPage, ulType, ulOffset, ulRdata );
+        }
+    }
+    if ( ulLoop <= 0 )
+    {
+        SRE_printf( "serdes2 read outoftime page=%x sel=%x offset=%x", ulPage, ulType, ulOffset );
+    }
+    /*第7步：write addr[ioctrl1_base_addr+0x48],*/
+    /*data[bit31-27=all 0,bit26=1,bit25=0,bit24=0,bit23-16=all 0,bit15-13=x1,*/
+    /*bit12=x2,bit11-0=x3]*/
+    ulTemp = 0;
+    ulTemp = ( ulTemp | 0x4000000 ) | ( ulPage << 13 ) | ( ulType << 12 ) | ( ulOffset & 0xfff );
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + 0x48, 0, ulTemp );
+
+    osSerdesWait(1000);
+
+    return ulRdata & 0x1FF;
+}
+
+
+
+void osSerdes3Write( UINT32 ulAddr, UINT32 ulValue )
+{
+    /*Write addr[serdes3_base_addr +x1],data[bit31-0=x2]*/
+    OS_SDS_WRITE_REG( SERDES3_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+UINT32 osSerdes3Read( UINT32 ulAddr )
+{
+    return OS_READ_REG( SERDES3_BASE_ADDR + ulAddr, 0 );
+}
+
+void osIoCtrl0Write( UINT32 ulAddr, UINT32 ulValue )
+{
+    OS_SDS_WRITE_REG( IOCTRL0_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+UINT32 osIoCtrl0Read( UINT32 ulAddr )
+{
+    return OS_READ_REG( IOCTRL0_BASE_ADDR + ulAddr, 0 );
+}
+
+void osIoCtrl1Write( UINT32 ulAddr, UINT32 ulValue )
+{
+    OS_SDS_WRITE_REG( IOCTRL1_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+UINT32 osIoCtrl1Read( UINT32 ulAddr )
+{
+    return OS_READ_REG( IOCTRL1_BASE_ADDR + ulAddr, 0 );
+}
+
+void osSysCtrlWrite( UINT32 ulAddr, UINT32 ulValue )
+{
+    OS_SDS_WRITE_REG( SYSCTRL_BASE_ADDR + ulAddr, 0, ulValue );
+}
+
+UINT32 osSysCtrlRead( UINT32 ulAddr )
+{
+    return OS_READ_REG( SYSCTRL_BASE_ADDR + ulAddr, 0 );
+}
+
+void    OS_SDS_WRITE_REG ( UINT32 pRegBase, UINT32 ulRegIndex, UINT32  ulValue )
+{
+#if  SERDES_DEBUG_OPEN
+    SRE_printf( "addr:0x%8x,ulValue:0x%8x\n", pRegBase, ulValue );
+#else
+    OS_WRITE_REG( pRegBase, ulRegIndex, ulValue );
+#endif
+}
+
+void  osSerdesDebugOn(void)
+{
+    gulDebugOpen = 1;
+}
+
+void  osSerdesDebugOff(void)
+{
+    gulDebugOpen = 0;
+}
+
+
diff --git a/drivers/misc/serdes/SRE_serdes.h b/drivers/misc/serdes/SRE_serdes.h
new file mode 100644
index 0000000..111c0f0
--- /dev/null
+++ b/drivers/misc/serdes/SRE_serdes.h
@@ -0,0 +1,65 @@
+/*******************************************************************
+              Copyright 2007 - 2011, Huawei Tech. Co., Ltd.
+                      ALL RIGHTS RESERVED
+
+Filename      : SRE_serdes.h
+Author        : z00228490
+Creation time : 2012/12/27
+Description   :
+                 serdes 驱动头文件
+Version       : 1.0
+********************************************************************/
+
+#include "SRE_drv.h"
+
+#ifndef _SRE_SERDES_H_
+#define _SRE_SERDES_H_
+
+extern UINT32 SRE_SerdesInit(VOID);
+
+/*serdes 可以复用类型*/
+typedef enum  enSerdesInitType
+{
+    GE,
+    XGE_XAUI,
+    XGE_SFI,
+    SRIO,
+    PCIE,
+    SATA,
+    NOT_USED     //未使用
+}SRE_SERDES_INIT_TYPE;
+
+
+/*serdes 典型速率*/
+typedef enum  enSerdesSpeed
+{
+    S1G25,
+    S1G5,
+    S2G5,
+    S3G,
+    S3G125,
+    S5G,
+    S6G,
+    S6G25,
+    S8G,
+    S10G3125
+}SRE_SERDES_SPEED;
+
+
+typedef struct tarSerdesCfg
+{
+    SRE_SERDES_INIT_TYPE enSerdes0InitType;
+    SRE_SERDES_INIT_TYPE enSerdes1InitType;
+    SRE_SERDES_INIT_TYPE enSerdes2InitType;
+    SRE_SERDES_INIT_TYPE enSerdes3InitType;
+    SRE_SERDES_SPEED    enSerdes0Speed;
+    SRE_SERDES_SPEED    enSerdes1Speed;
+    SRE_SERDES_SPEED    enSerdes2Speed;
+    SRE_SERDES_SPEED    enSerdes3Speed;
+}SRE_SERDES_CFG;
+
+extern int serdes_init(void);
+extern void serdes_exit(void);
+
+#endif /* _SRE_SERDES_H_ */
+
-- 
1.9.1

